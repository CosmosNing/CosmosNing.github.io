<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CosmosNing的个人博客</title>
  <icon>https://gitee.com/CosmosNing/MyPicGo/raw/master/images/avatar-32.ico</icon>
  <subtitle>探索·好奇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cosmosning.github.io/"/>
  <updated>2020-04-06T04:56:53.712Z</updated>
  <id>https://cosmosning.github.io/</id>
  
  <author>
    <name>CosmosNing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Hexo搭建并部署个人博客</title>
    <link href="https://cosmosning.github.io/2020/03/12/shi-yong-hexo-da-jian-bing-bu-shu-ge-ren-bo-ke/"/>
    <id>https://cosmosning.github.io/2020/03/12/shi-yong-hexo-da-jian-bing-bu-shu-ge-ren-bo-ke/</id>
    <published>2020-03-12T15:15:36.000Z</published>
    <updated>2020-04-06T04:56:53.712Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前段时间，看到 Hexo 官方文档更新了使用 TravisCI 自动化部署部分。趁着这个机会，我将我的博客重新构建了一遍。这里记下简略过程，供读者参考。通过本篇文章，你将获得：</p><ol><li>使用 Hexo 构建静态博客</li><li>简单配置 NexT 主题</li><li>使用 TravisCI + GitHubPages 完成自动化部署</li></ol></blockquote><h1 id="前置需求"><a href="#前置需求" class="headerlink" title="前置需求"></a>前置需求</h1><p>在安装 Hexo 之前，你必须保证你的机器上安装了<strong>Node.js</strong>及<strong>Git</strong>。如果你未安装，你需要到如下网址，下载安装。</p><ul><li>Node.js：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></li><li>Git：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></li></ul><p>然后，你可以在命令行中输入如下命令，完成 <strong>Hexo</strong> 的安装</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span></span><br></pre></td></tr></table></figure><p>此外，为了部署在 Github 上，你需要有一个 <strong>GitHub 账号</strong>。如果没有，你可以到<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>注册一个。</p><h1 id="Hexo-最小配置"><a href="#Hexo-最小配置" class="headerlink" title="Hexo 最小配置"></a>Hexo 最小配置</h1><p>打开命令行（Windows 上可以使用 <strong>Git Bash</strong> 或者 <strong>PowerShell</strong>），输入如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>等待片刻，<strong>Hexo</strong> 会帮我们做初始化网站的工作。</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/hexo-init-blog.PNG" alt="Hexo初始化"></p><p>为方便后面部署，我们在 <code>blog</code> 中初始化一个 git 仓库，并配置好 git 相关信息。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 blog 文件夹</span></span><br><span class="line">cd blog</span><br><span class="line"><span class="comment"># 初始化 Git 仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 查看 Git 状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 配置个人信息（与你注册 GitHub 的用户名、邮箱一致）</span></span><br><span class="line">git config -<span class="literal">-local</span> user.name &lt;你的用户名&gt;</span><br><span class="line">git config -<span class="literal">-local</span> user.email &lt;你的邮箱名&gt;</span><br><span class="line"><span class="comment"># 查看配置，user.name、user.email 是否配置成功</span></span><br><span class="line">git config -<span class="literal">-local</span> -<span class="literal">-list</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/git-init-and-config.PNG" alt="初始化Git仓库"></p><p>接着，将仓库里的已有改动添加、提交。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">"init with hexo-cli"</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/git-add-and-commit.PNG" alt="Git提交改动"></p><p>在 blog 根目录，使用任意文本编辑器打开 <code>_config.yml</code> 文件，并在 <code>#Site</code> 部分输入你网站的信息。一个示例如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">CosmosNing的个人博客</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">探索·好奇</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">编程·学习·生活</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">个人博客;编程;学习;生活</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">CosmosNing</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure><p>到现在， Hexo 最小配置已经完成。我们来看看效果如何。继续在命令行下输入如下命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果使用 PowerShell，则选择输入下一条命令（下同）</span></span><br><span class="line">hexo g; hexo s</span><br><span class="line"><span class="comment"># 如果使用 Git Bash 或者 Linux 终端，则选择输入下一条命令（下同）</span></span><br><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/hexo-g-and-hexo-s.PNG" alt="Hexo本地预览命令"></p><p>打开浏览器，访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><p>你应该能得到类似这个画面</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/basic-result.PNG" alt="Hexo最小化配置效果"></p><div class="note info">            <h2 id="提示-终止预览"><a href="#提示-终止预览" class="headerlink" title="提示-终止预览"></a>提示-终止预览</h2><p>你可以在命令行中，按下 <code>Ctrl + C</code> 终止上述预览命令</p>          </div><h1 id="设置-NexT-主题"><a href="#设置-NexT-主题" class="headerlink" title="设置 NexT 主题"></a>设置 NexT 主题</h1><p>默认的主题不太美观，而且功能有限。下面，我将介绍目前 <strong>Hexo</strong> 中最受欢迎的主题——NexT 的安装与配置。</p><h2 id="最小配置"><a href="#最小配置" class="headerlink" title="最小配置"></a>最小配置</h2><p>首先，在命令行中输入如下命令，安装 <strong>NexT</strong> 主题</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme<span class="literal">-next</span>/hexo<span class="literal">-theme</span><span class="literal">-next</span> themes/next</span><br></pre></td></tr></table></figure><p>使用文本编辑器，打开项目根目录的 <code>_config.yml</code> 文件，将 <code>theme</code> 配置成 <code>next</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><p>至此，<strong>NexT</strong> 最小配置已经完成。我们来看看效果吧</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean; hexo g; hexo s</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/next-hexo-g.PNG" alt="Hexo本地预览"></p><p>打开浏览器，访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><p>你应该能得到类似这个画面</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/next-basic-result.PNG" alt="next最小配置效果"></p><p>使用 <code>Ctrl + C</code> 终止上述命令。接下来，我们将这一阶段的改动提交到 Git 仓库。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 NexT 主题作为子模块加入仓库</span></span><br><span class="line">git submodule add https://github.com/theme<span class="literal">-next</span>/hexo<span class="literal">-theme</span><span class="literal">-next</span> themes/next</span><br><span class="line"><span class="comment"># 添加改动至暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">"add common site config with theme next(default config)"</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/git-commit-next-default.PNG" alt="NexT最小化配置提交"></p><h2 id="配置功能页面及资源文件"><a href="#配置功能页面及资源文件" class="headerlink" title="配置功能页面及资源文件"></a>配置功能页面及资源文件</h2><p>一个完整的博客应该包括 <code>主页</code> 、<code>分类</code>、<code>标签</code>、 <code>归档</code> 等功能页面。而在 <strong>Hexo</strong> 帮我们初始化时，只是完成了博文页的设置。其他功能页需要手动设置。具体步骤如下</p><ul><li>创建 <code>关于</code> 页</li></ul><p>在项目根目录下的 <code>source</code> 文件夹中，创建一个 <code>about</code> 文件夹。在 <code>about</code> 文件夹下，创建 <code>index.md</code> ，并在 <code>index.md</code> 中输入如下文字：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 关于我</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">在这里输入你的个人介绍</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>创建 <code>分类</code> 页</li></ul><p>在项目根目录下的 <code>source</code> 文件夹中，创建一个 <code>categories</code> 文件夹。在 <code>categories</code> 文件夹下，创建 <code>index.md</code> ，并在 <code>index.md</code> 中输入如下文字：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">type: "categories"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ul><li>创建 <code>标签云</code> 页</li></ul><p>在项目根目录下的 <code>source</code> 文件夹中，创建一个 <code>tags</code> 文件夹。在 <code>tags</code> 文件夹下，创建 <code>index.md</code> ，并在 <code>index.md</code> 中输入如下文字：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签云</span><br><span class="line">type: "tags"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>至此，你可以在 <code>_config.yml</code> 配置使用这些页面</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加主题配置</span></span><br><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">    <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">    <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure><p>另外，你可以将博客中常用的图片（如 logo 、头像等）内置在博客站点中。你需要在项目根目录下的 <code>source</code> 文件夹中，创建 <code>images</code> 文件夹。然后将图片文件拷贝到这里即可。这样，你在 <code>_config.yml</code> 中可以通过 <code>/images/&lt;图片名&gt;</code> 来引用。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p><strong>Hexo</strong> 开放的设计使得开发者可以通过插件的方式增强其能力。为了使得我们的博客功能更加完善，这里我们需要安装一些有用的插件。</p><ul><li><a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a></li></ul><p><code>hexo-generator-feed</code> 是一个 RSS Feed 生成器，通过它可以为我们的博客生成可用于 RSS 订阅的文件。默认配置下，它会在你的站点根目录生成 <code>atom.xml</code> 。</p><p>你可以输入如下命令安装插件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator</span><span class="literal">-feed</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><p>然后，在 <code>_config.yml</code> 中配置使用</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">140</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">' '</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="comment"># 这个是自定义的 icon</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">/images/avatar-32.ico</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/theme-next/hexo-generator-searchdb" target="_blank" rel="noopener">hexo-generator-searchdb</a></li></ul><p><code>hexo-generator-searchdb</code>是一个本地搜索索引生成器，通过它可以为我们的博客生成可用于本地搜索的文件。默认配置下，它会在你的站点根目录生成 <code>search.xml</code> 。你不需要额外书写搜索算法，因为强大的 <code>NexT</code> 主题已经内置了搜索功能。</p><p>你可以输入如下命令安装插件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator</span><span class="literal">-searchdb</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><p>然后，在 <code>_config.yml</code> 中配置使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="comment"># 注意需要将下列配置增加在 theme_config 中，并保持相对缩进</span></span><br><span class="line">  <span class="attr">local_search:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">    <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">    <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">    <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">    <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">    <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">    <span class="attr">preload:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a></li></ul><p><code>hexo-permalink-pinyin</code>是一个中文链接转拼音的工具，使用它有助于搜索引擎的抓取我们的博客页面（当然，如果你部署在 GitHub 上，百度无法抓取，因为 GitHub 禁止百度对此类页面的抓取）。</p><p>你可以输入如下命令安装插件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo<span class="literal">-permalink</span><span class="literal">-pinyin</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><p>然后，在 <code>_config.yml</code> 中配置使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink_pinyin:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">separator:</span> <span class="string">'-'</span> <span class="comment"># default: '-'</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">hexo-symbols-count-time</a></li></ul><p><code>hexo-symbols-count-time</code>是一个统计文章字数、估计阅读时间的工具，使用它有助于读者提高阅读效率。</p><p>你可以输入如下命令安装插件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-symbols</span><span class="literal">-count</span><span class="literal">-time</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><p>然后，在 <code>_config.yml</code> 中配置使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="comment"># 注意需要将下列配置增加在 theme_config 中，并保持相对缩进</span></span><br><span class="line">  <span class="attr">symbols_count_time:</span></span><br><span class="line">    <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">exclude_codeblock:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">awl:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">wpm:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="noopener">hexo-generator-sitemap</a></li></ul><p><code>hexo-generator-sitemap</code>是一个生成网站 <code>sitemap</code> 工具，你可以主动将生成的 <code>sitemap.xml</code> 提交给搜索引擎，这样搜索引擎就可以更好的抓取你的博文。</p><p>你可以输入如下命令安装插件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator</span><span class="literal">-sitemap</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><p>然后，在 <code>_config.yml</code> 中配置使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line">    <span class="attr">rel:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>至此，插件部分已配置完成。</p><div class="note info">            <h2 id="提示-更多配置"><a href="#提示-更多配置" class="headerlink" title="提示-更多配置"></a>提示-更多配置</h2><p>更多 NexT 主题的配置，可以查看 <code>themes/next/_config.yml</code>，将你需要改动的配置拷贝到根目录下 <code>_config.yml</code> 中的 <code>theme_config</code> 结点下。（<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/DATA-FILES.md#选择-1hexo-方式" target="_blank" rel="noopener">参考</a>）</p><p>如果你懒得自定义，可以参考我的<a href="https://github.com/CosmosNing/CosmosNing.github.io/blob/source/_config.yml" target="_blank" rel="noopener">主题配置</a></p>          </div><p>我们来看看效果如何。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean; hexo g; hexo s</span><br></pre></td></tr></table></figure><p>打开浏览器，访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><p>我得到了以下画面</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/my-result.PNG" alt="效果预览"></p><h2 id="定制主题颜色及简单样式"><a href="#定制主题颜色及简单样式" class="headerlink" title="定制主题颜色及简单样式"></a>定制主题颜色及简单样式</h2><p>NexT 主题非常灵活，用户可以高度自定义，包括颜色，布局等。本节将浅显的介绍如何自定义主题的颜色及样式。</p><div class="note default">            <p>推荐你使用 <code>Chrome</code> 浏览器作为调试工具</p>          </div><p>首先，在根目录的 <code>source</code> 文件夹下创建 <code>_data</code> 文件夹。在 <code>_data</code> 文件夹下，创建 <code>styles.styl</code> 文件。</p><p>然后，配置根目录下 <code>_config.yml</code> ，以确保生成器将使用你自定义的样式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="comment"># 注意需要将下列配置增加在 theme_config 中，并保持相对缩进</span></span><br><span class="line">  <span class="attr">custom_file_path:</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure><p>接下来，我们就可以使用 <code>Chrome</code> 浏览器对主题的样式进行微调。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地预览命令</span></span><br><span class="line">hexo clean; hexo g; hexo s</span><br></pre></td></tr></table></figure><p>打开浏览器，访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><p>按下 <code>F12</code> 打开<code>Chrome</code> 浏览器开发者工具。并点选左上角红框所示的按钮。这样，你就可以使用鼠标快速找到网页中某块元素的样式。然后修改右半部分（如蓝框所示） <code>Styles</code> 的样式，并观察网页效果。如果合适，将对应的样式类，复制到上述创建的 <code>styles.styl</code> 文件中，并保存。下次预览生成，你就会得到定制化的主题样式。</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/ChromeDevTools.PNG" alt="ChromeDevTools"></p><div class="note default">            <p>点<a href="https://github.com/CosmosNing/CosmosNing.github.io/blob/source/source/_data/styles.styl" target="_blank" rel="noopener">这里</a>，查看我的样式配置。</p>          </div><p>至此，我们的主题配置已经完成。下面，将改动提交至仓库</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">"&lt;你的提交信息&gt;"</span></span><br></pre></td></tr></table></figure><h1 id="使用-TravisCI-GitHubPages-实现自动化部署"><a href="#使用-TravisCI-GitHubPages-实现自动化部署" class="headerlink" title="使用 TravisCI + GitHubPages 实现自动化部署"></a>使用 TravisCI + GitHubPages 实现自动化部署</h1><h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><p>由于 Github Pages 目前只是支持 master 分支的页面渲染，所以我们需要提前做一些准备工作。打开命令行，输入如下命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于最新提交，创建名为 source 的分支</span></span><br><span class="line">git branch source</span><br><span class="line"><span class="comment"># 切换到 source 分支</span></span><br><span class="line">git checkout source</span><br><span class="line"><span class="comment"># 删除 master ，供静态页面的部署</span></span><br><span class="line">git branch <span class="literal">-d</span> master</span><br></pre></td></tr></table></figure><h2 id="创建-GithubPages-仓库"><a href="#创建-GithubPages-仓库" class="headerlink" title="创建 GithubPages 仓库"></a>创建 GithubPages 仓库</h2><p>登录你的 GitHub 账号，在主页的左侧，点击 <code>New</code> ，新建一个 GithubPages 仓库。你应该将其命名为 <code>&lt;你的 GitHub 用户名&gt;.github.io</code>，并点击 <code>Create repository</code> 完成创建。</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/new-repo.png" alt="创建仓库"></p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/new-repo-info.PNG" alt="填写仓库信息"></p><p>接下来，需要将本地的博客仓库，推送到 GitHub。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:&lt;你的用户名&gt;/&lt;你的用户名&gt;.github.io.git</span><br><span class="line">git push <span class="literal">-u</span> origin source</span><br></pre></td></tr></table></figure><h2 id="创建-Personal-Access-Token"><a href="#创建-Personal-Access-Token" class="headerlink" title="创建 Personal Access Token"></a>创建 Personal Access Token</h2><p>在浏览器新建一个标签页，前往 GitHub <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">新建 Personal Access Token</a>，只勾选 <code>repo</code> 的权限并生成一个新的 Token。Token 生成后请<strong>复制并保存好</strong>（因为只会出现一次，刷新页面就再也看不见了）。</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/token.PNG" alt="token"></p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/token-info.PNG" alt="token-info"></p><h2 id="安装及配置-TravisCI"><a href="#安装及配置-TravisCI" class="headerlink" title="安装及配置 TravisCI"></a>安装及配置 TravisCI</h2><p>在你的 GitHub 主页，点击上方菜单栏中的 <code>Marketplace</code>。</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/travis01.png" alt="Travis-01"></p><p>在搜索框中，搜索 <code>travis</code></p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/travis02.PNG" alt="Travis-02"></p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/travis03.PNG" alt="Travis-03"></p><p>点选第一个 <code>Travis CI</code> ，并滑动到最后，选择 <code>Open Source</code>，再点击 <code>Install it for free</code>。</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/travis04.PNG" alt="Travis-04"></p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/travis05.PNG" alt="Travis-05"></p><p>继续点 <code>绿色</code> 按钮。</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/travis06.PNG" alt="Travis-06"></p><p><code>Install</code> !</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/travis07.PNG" alt="Travis-07"></p><p>现在我们可以在 <code>Travis CI</code> 官网上，登录并设置它了。</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/travis08.PNG" alt="Travis-08"></p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/travis09.PNG" alt="Travis-09"></p><p>点击你的博客仓库，新建一个环境变量。<strong>Name</strong> 为 <code>GH_TOKEN</code>，<strong>Value</strong> 为刚才你在 GitHub 生成的 Token。确保 <strong>DISPLAY VALUE IN BUILD LOG</strong> 保持 <strong>不被勾选</strong> 避免你的 Token 泄漏。点击 <strong>Add</strong> 保存</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/travis10.PNG" alt="Travis-10"></p><p>在你的 Hexo 站点文件夹中新建一个 <code>.travis.yml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10</span> <span class="comment"># use nodejs v10 LTS</span></span><br><span class="line"><span class="attr">cache:</span> <span class="string">npm</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source</span> <span class="comment"># build source branch only</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="comment"># generate static files</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github-token:</span> <span class="string">$GH_TOKEN</span></span><br><span class="line">  <span class="attr">keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">target_branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">source</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure><p>最后，将改动提交，并推送到 GitHub 上:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">"你的提交信息"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>你的工作至此完成，可以泡杯咖啡，等待 <code>Travis CI</code> 运行结果（在你的 GitHub 博客仓库主页可以查看，如下图。如果是绿色的 ✅，那么成功；❎ 则代表失败）。</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/build-status.PNG" alt="build-status"></p><h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><p>接下来你就可以自由的写博客啦。这里为你总结一些常用命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建博文</span></span><br><span class="line">hexo new &lt;标题名&gt;</span><br><span class="line"><span class="comment"># 本地预览</span></span><br><span class="line">hexo clean; hexo g; hexo s</span><br><span class="line"><span class="comment"># Git 推送</span></span><br><span class="line">git add .</span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">"你的提交信息"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a></p>]]></content>
    
    <summary type="html">
    
      手把手教你从零开始搭建一个个人博客
    
    </summary>
    
    
      <category term="指南" scheme="https://cosmosning.github.io/categories/%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="前端" scheme="https://cosmosning.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Hexo" scheme="https://cosmosning.github.io/tags/Hexo/"/>
    
      <category term="GitHubPages" scheme="https://cosmosning.github.io/tags/GitHubPages/"/>
    
      <category term="TravisCI" scheme="https://cosmosning.github.io/tags/TravisCI/"/>
    
  </entry>
  
  <entry>
    <title>译文-程序员是如何排版简历的</title>
    <link href="https://cosmosning.github.io/2020/03/02/yi-wen-cheng-xu-yuan-shi-ru-he-pai-ban-jian-li-de/"/>
    <id>https://cosmosning.github.io/2020/03/02/yi-wen-cheng-xu-yuan-shi-ru-he-pai-ban-jian-li-de/</id>
    <published>2020-03-02T09:30:09.000Z</published>
    <updated>2020-04-06T04:56:53.716Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>（译者按）又是一年招聘季，找工作的第一步便是要制作自己的简历。一份排版精美、可读性高的简历十分重要。那么，该如何高效的排版自己的简历？读者可以尝试一下本文示例的 CSS Grid 布局。</p><p>原标题：New Year, New Job? Let’s Make a Grid-Powered Resume!</p><p>作者：Ali Churcher</p><p>原文链接：<a href="https://css-tricks.com/new-year-new-job-lets-make-a-grid-powered-resume/" target="_blank" rel="noopener">https://css-tricks.com/new-year-new-job-lets-make-a-grid-powered-resume/</a></p></blockquote><h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>许多受欢迎的简历都利用网格形状组织自己的简历的不同部分，以充分利用有限的页面空间。下面，请与我一起，使用 CSS 中的网格（Grid），创建一个无论是在打印情况下、还是在不同屏幕尺寸下浏览都看上去很棒的布局吧！这样，我们可以在线和离线使用简历，还可能在新的一年中派上用场！</p><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/resume_preview.png" alt="简历效果预览"></p><p>首先，我们创建一个简历的容器和简历子部分。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"resume"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"photo"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"about"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"work"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"community"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"skills"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要开始使用 CSS 中的网格，我们向 <code>resume</code> 样式类中添加 <code>display: grid</code> 。然后，我们得规定，容器内的元素如何在网格中放置。在这个示例中，我们将容器划分为 4 行 2 列。</p><p>与此同时，我们使用 CSS 网格中规定网格大小的单位 <code>fr</code> 来明确各个网格的比例大小关系。我们将每行等分（也就是每一行的大小都是 <code>1fr</code>），并设置第一列是第二列的两倍 （ <code>2fr</code> ）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.resume</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/resume-01-1.jpg" alt="简历容器布局示意图"></p><p>接下来，我们将使用 <code>grid-template-areas</code> 属性来描述元素在网格中摆放的位置。首先，我们需要为每一个简历子部分的 <code>grid-area</code> 指定一个名字。你可以使用任何名字，但是在这里，我们采用与简历子部分相同的名字：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.name</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.photo</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: photo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现在，我们到了最有趣的部分。在样式类 <code>resume</code> 中的 <code>grid-template-areas</code> 属性中按你的需求放置上述定义好的 <code>grid-area</code> 的名字。例如，我们在 <code>grid-template-areas</code> 的左上角添加了 <code>name</code> ，这意味着我们将我们的名字放在了简历的左上角。我们的 <code>work</code> 部分有很多内容，因此我们将其添加了两次，使得它能够占据两个网格单元。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.resume</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>:</span><br><span class="line">        <span class="string">"name photo"</span></span><br><span class="line">        <span class="string">"work about"</span></span><br><span class="line">        <span class="string">"work education"</span></span><br><span class="line">        <span class="string">"community skills"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是我们目前完成的成果：</p><iframe name="cp_embed_1" src="https://codepen.io/alichur/embed/xxbKdKZ?height=367&amp;theme-id=1&amp;default-tab=result&amp;user=alichur&amp;slug-hash=xxbKdKZ&amp;pen-title=grid%20resume%20%20lines&amp;name=cp_embed_1" scrolling="no" frameborder="0" height="367" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="grid resume  lines" class="cp_embed_iframe " style="width: 100%; overflow: hidden; display: block;" id="cp_embed_xxbKdKZ"></iframe><h1 id="调整布局"><a href="#调整布局" class="headerlink" title="调整布局"></a>调整布局</h1><p>属性<code>grid-template-areas</code> 使你能够轻松改变你的布局。比如，如果你认为，和教育（<code>education</code>）相比，雇主对你的技能（<code>skills</code>）更感兴趣，你仅仅只需要在 <code>grid-template-areas</code> 中调换它们的位置即可（也就意味着，它们在显示时，也会调换位置），而不需要做其他任何改动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.resume</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>:</span><br><span class="line">    <span class="string">"name photo"</span></span><br><span class="line">    <span class="string">"work about"</span></span><br><span class="line">    <span class="string">"work skills"</span></span><br><span class="line">    <span class="string">"community education"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/resume-02.jpg" alt="调整布局示例"></p><iframe name="cp_embed_2" src="https://codepen.io/alichur/embed/bGNGGNP?height=367&amp;theme-id=1&amp;default-tab=result&amp;user=alichur&amp;slug-hash=bGNGGNP&amp;pen-title=grid%20resume%20%20swapping%20sections&amp;name=cp_embed_2" scrolling="no" frameborder="0" height="367" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="grid resume  swapping sections" class="cp_embed_iframe " style="width: 100%; overflow: hidden; display: block;" id="cp_embed_bGNGGNP"></iframe>只需很小的 CSS 代码改动，我们就可以获得较窄一列靠左的简历布局。那就是网格布局的优势之一，即我们可以通过重新排列已经命名的 `grid-area` 来移动子块，而保证其他源代码保持其原有位置。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.resume</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>:</span><br><span class="line">    <span class="string">"photo education"</span></span><br><span class="line">    <span class="string">"name work"</span></span><br><span class="line">    <span class="string">"about work"</span></span><br><span class="line">    <span class="string">"skills community"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/resume-03-1.jpg" alt="窄列靠左示例"></p><iframe name="cp_embed_3" src="https://codepen.io/alichur/embed/XWJrRjb?height=367&amp;theme-id=default&amp;default-tab=result&amp;user=alichur&amp;slug-hash=XWJrRjb&amp;pen-title=grid%20resume%20%20left%20design&amp;name=cp_embed_3" scrolling="no" frameborder="0" height="367" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="grid resume  left design" class="cp_embed_iframe " style="width: 100%; overflow: hidden; display: block;" id="cp_embed_XWJrRjb"></iframe><h1 id="划分更多列"><a href="#划分更多列" class="headerlink" title="划分更多列"></a>划分更多列</h1><p>也许你想在简历中添加个人参考。我们可以向网格模板中增添第三列，并把它放在最底部一行。要注意的是，我们也需要等比例的改变列的大小，然后更新模板区域。这样会使得某些元素占据了两列，但是这保持整体布局的正确。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.resume</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>:</span><br><span class="line">    <span class="string">"name name photo"</span></span><br><span class="line">    <span class="string">"work work about"</span></span><br><span class="line">    <span class="string">"work work education"</span></span><br><span class="line">    <span class="string">"community references skills"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/resume-04-1.jpg" alt="划分列示例"></p><iframe name="cp_embed_4" src="https://codepen.io/alichur/embed/gObYWvd?height=367&amp;theme-id=default&amp;default-tab=result&amp;user=alichur&amp;slug-hash=gObYWvd&amp;pen-title=grid%20resume%20%20split%20columns&amp;name=cp_embed_4" scrolling="no" frameborder="0" height="367" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="grid resume  split columns" class="cp_embed_iframe " style="width: 100%; overflow: hidden; display: block;" id="cp_embed_gObYWvd"></iframe><h1 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h1><p>对于小屏幕，比如移动设备，我们可以在单列展示简历。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.resume</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>:</span><br><span class="line">      <span class="string">"photo"</span></span><br><span class="line">      <span class="string">"name"</span></span><br><span class="line">      <span class="string">"about"</span></span><br><span class="line">      <span class="string">"work"</span></span><br><span class="line">      <span class="string">"education"</span></span><br><span class="line">      <span class="string">"skills"</span></span><br><span class="line">      <span class="string">"community"</span></span><br><span class="line">      <span class="string">"references"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们可以采用媒介查询（media query），当遇到更宽的屏幕时，改变布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.resume</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>:</span><br><span class="line">      <span class="string">"name photo"</span></span><br><span class="line">      <span class="string">"work about"</span></span><br><span class="line">      <span class="string">"work education"</span></span><br><span class="line">      <span class="string">"community skills"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于屏幕尺寸的响应，可以增加更多的临界点。例如，在平板电脑等中型屏幕上，我们可能希望所有内容都放在一个栏中，但“个人”和“图像”部分需要并排放置在顶部。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">900px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.resume</span> &#123;</span><br><span class="line">      <span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr;</span><br><span class="line">      <span class="attribute">grid-template-areas</span>:</span><br><span class="line">        <span class="string">"name photo"</span></span><br><span class="line">        <span class="string">"about about"</span></span><br><span class="line">        <span class="string">"work work"</span></span><br><span class="line">        <span class="string">"education education"</span></span><br><span class="line">        <span class="string">"skills skills"</span></span><br><span class="line">        <span class="string">"community community"</span></span><br><span class="line">        <span class="string">"references references"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做好单页打印的准备"><a href="#做好单页打印的准备" class="headerlink" title="做好单页打印的准备"></a>做好单页打印的准备</h1><p>如果你需要在一张纸上精美的打印你的简历，则需要牢记一些注意事项。最困难的挑战通常是缩减字数，以满足一页纸的要求。</p><p>避免减小字体大小以挤压更多信息，因为它可能变得难以阅读。一个处理技巧便是在你制作简历时，为简历增加一个暂时的大小限制。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.resume</span> &#123;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">210mm</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">297mm</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过设置 A4 纸张大小的边界，我们可以清晰的看到内容尺寸是否太小，亦或者是内容超出边界（这意味着它会被打印到第二页）。</p><p>你可以告诉 CSS 在打印时将一些不必要的东西隐藏，比如浏览器会插入的像时间和页数等信息。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@page</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0cm</span>;</span><br><span class="line">  <span class="attribute">size</span>: A4 portrait;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一件事是，不同的浏览器可能会使用大小略有不同的不同字体来呈现简历。 如果你想要非常精确的打印简历，另一种选择是将其另存为PDF，并在你的站点上提供下载链接。</p><h1 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h1><p>CSS Grid 在现代浏览器中具有良好的支持。</p><p>Internet Explorer（IE）支持使用前缀的 CSS Grid 规范的较旧版本。 例如，<code>grid-template-columns</code> 被编写为 <code>-ms-grid-columns</code> 。 通过 Autoprefixer 运行代码可以帮助添加这些前缀，但是由于在旧规范中某些属性的行为有所不同，而导致某些属性不存在，因此将需要进行手动更改和全面测试。 丹尼尔·托农（Daniel Tonon）的<a href="https://css-tricks.com/css-grid-in-ie-css-grid-and-the-new-autoprefixer/" target="_blank" rel="noopener">文章</a>值得一看，其中介绍了如何配置 Autoprefixer 以使事情尽可能正常地工作。</p><p>自动前缀的另一种方法是<a href="https://www.smashingmagazine.com/2017/11/css-grid-supporting-browsers-without-grid/" target="_blank" rel="noopener">提供回退</a>，例如通过使用 float 布局。 无法识别 CSS 网格属性的浏览器将使用此显示。 不管你是否需要支持IE，回退都是明智的，因为它确保了不支持 CSS Grid 的浏览器仍然正确显示你的内容。</p>]]></content>
    
    <summary type="html">
    
      用 Word 排版很难受？试试程序员的方式！
    
    </summary>
    
    
      <category term="前端" scheme="https://cosmosning.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="简历" scheme="https://cosmosning.github.io/tags/%E7%AE%80%E5%8E%86/"/>
    
      <category term="CSS" scheme="https://cosmosning.github.io/tags/CSS/"/>
    
      <category term="排版" scheme="https://cosmosning.github.io/tags/%E6%8E%92%E7%89%88/"/>
    
      <category term="Grid" scheme="https://cosmosning.github.io/tags/Grid/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-66-plus-one</title>
    <link href="https://cosmosning.github.io/2020/02/17/leetcode-66-plus-one/"/>
    <id>https://cosmosning.github.io/2020/02/17/leetcode-66-plus-one/</id>
    <published>2020-02-17T10:42:55.000Z</published>
    <updated>2020-04-06T04:56:53.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul><li><input checked="" disabled="" type="checkbox"> 第一遍</li><li><input disabled="" type="checkbox"> 第二遍</li><li><input disabled="" type="checkbox"> 第三遍</li><li><input disabled="" type="checkbox"> 第四遍</li><li><input disabled="" type="checkbox"> 第五遍</li></ul><h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1:</p><p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br>示例 2:</p><p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/plus-one" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>编写 <code>public int[] plusOne(int[] digits)</code> 函数</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的思路可以简单描述为，模拟竖式加法运算。</p><h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 思路：模拟竖式计算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 末位加一</span></span><br><span class="line">    digits[digits.length - <span class="number">1</span>] = digits[digits.length - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            digits[i] = digits[i] % <span class="number">10</span>;</span><br><span class="line">            digits[i - <span class="number">1</span>] = digits[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理原有位数不够</span></span><br><span class="line">    <span class="keyword">if</span> (digits[<span class="number">0</span>] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; digits.length; i++) &#123;</span><br><span class="line">            result[i+<span class="number">1</span>] = digits[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>为 $O(n)$</li><li><strong>空间复杂度</strong><ul><li>最好 $O(1)$ </li><li>最坏 $O(n)$ （最高位进位情况）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      本篇文章带来有关 &quot;LeetCode-66-plus-one&quot; 我的求解过程
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://cosmosning.github.io/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="https://cosmosning.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1-two-sum</title>
    <link href="https://cosmosning.github.io/2020/02/17/leetcode-1-two-sum/"/>
    <id>https://cosmosning.github.io/2020/02/17/leetcode-1-two-sum/</id>
    <published>2020-02-17T08:24:28.000Z</published>
    <updated>2020-04-06T04:56:53.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul><li><input checked="" disabled="" type="checkbox"> 第一遍</li><li><input disabled="" type="checkbox"> 第二遍</li><li><input disabled="" type="checkbox"> 第三遍</li><li><input disabled="" type="checkbox"> 第四遍</li><li><input disabled="" type="checkbox"> 第五遍</li></ul><h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>编写 <code>public int[] twoSum(int[] nums, int target)</code> 函数</p></blockquote><h2 id="思路：暴力法"><a href="#思路：暴力法" class="headerlink" title="思路：暴力法"></a>思路：暴力法</h2><p>很容易想到一种暴力解法，即，</p><ul><li>枚举每一种可能，按条件返回结果</li></ul><h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力解法：枚举每一种可能</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = j;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>为 $O(n^2)$</li><li><strong>空间复杂度</strong>为 $O(1)$ </li></ul><h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><p>上述暴力法的时间效率实在是不堪入目。一种比较常规的优化思路便是<strong>空间换时间</strong>，来看一看<a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/" target="_blank" rel="noopener">高手的解法</a>。</p><h2 id="思路：一遍哈希表"><a href="#思路：一遍哈希表" class="headerlink" title="思路：一遍哈希表"></a>思路：一遍哈希表</h2><p>上述暴力法时间的低效主要是由于，程序只记住了两个待检验的数组下标，而重复遍历了数组很多次。其实，没必要重复遍历：<strong>遍历的时候，存储起来</strong>，就会使得时间效率提高。</p><p>对于本题，可以用<strong>哈希表</strong>，存储<strong>数</strong>和<strong>下标</strong>之间的关系。这样在通常情况下，只需 $O(1)$ 的时间，便可访问到哈希表中已存在的元素。从而使得整个程序的时间复杂度降到 $O(n)$ 。</p><h2 id="Java-实现-1"><a href="#Java-实现-1" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement)) &#123;               <span class="comment">// 如果存在满足条件的数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(complement), i &#125;; <span class="comment">// 直接返回结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);                             <span class="comment">// 否则，存储到哈希表中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>为 $O(n)$ </li><li><strong>空间复杂度</strong>为 $O(n)$ </li></ul><h1 id="类似题目：15-3sum"><a href="#类似题目：15-3sum" class="headerlink" title="类似题目：15.3sum"></a>类似题目：15.3sum</h1><blockquote><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例：</p><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br>[<br> [-1, 0, 1],<br> [-1, -1, 2]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="刷题标记-1"><a href="#刷题标记-1" class="headerlink" title="刷题标记"></a>刷题标记</h2><ul><li><input checked="" disabled="" type="checkbox"> 第一遍</li><li><input disabled="" type="checkbox"> 第二遍</li><li><input disabled="" type="checkbox"> 第三遍</li><li><input disabled="" type="checkbox"> 第四遍</li><li><input disabled="" type="checkbox"> 第五遍</li></ul><h2 id="高手方案-1"><a href="#高手方案-1" class="headerlink" title="高手方案"></a>高手方案</h2><p>这道题，我没什么思路，直接参考了<a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/" target="_blank" rel="noopener">高手题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || len &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    Arrays.sort(nums); <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">int</span> L = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> R = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                ans.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line">                <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++; <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R-<span class="number">1</span>]) R--; <span class="comment">// 去重</span></span><br><span class="line">                L++;</span><br><span class="line">                R--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) L++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><strong>空间换时间</strong>是一种常见的优化思路</li><li>另外，根据题意，<strong>舍弃遍历过程中绝不可能的组合</strong>，也是一种优化手段</li><li>已经<strong>有序</strong>的元素有着非常良好的性质，可以<strong>先排序</strong>，<strong>再解题</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      本篇文章带来有关 &quot;LeetCode-1-two-sum&quot; 我的求解过程
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://cosmosning.github.io/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="https://cosmosning.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="https://cosmosning.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="排序" scheme="https://cosmosning.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>合并有序线性表</title>
    <link href="https://cosmosning.github.io/2020/02/17/he-bing-you-xu-xian-xing-biao/"/>
    <id>https://cosmosning.github.io/2020/02/17/he-bing-you-xu-xian-xing-biao/</id>
    <published>2020-02-17T07:06:02.000Z</published>
    <updated>2020-04-06T04:56:53.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul><li><input checked="" disabled="" type="checkbox"> 第一遍</li><li><input disabled="" type="checkbox"> 第二遍</li><li><input disabled="" type="checkbox"> 第三遍</li><li><input disabled="" type="checkbox"> 第四遍</li><li><input disabled="" type="checkbox"> 第五遍</li></ul><h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>编写 <code>public ListNode mergeTwoLists(ListNode l1, ListNode l2)</code> 函数</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>合并有序线性表 L1、L2，有一个通用的思路，如下</p><ol><li>初始化每个表的遍历指针 Lp1，Lp2；并且新建一个线性表 L3，存储结果。</li><li>循环比较，将较小元素放入 L3</li><li>如果 L1 还有元素未遍历，处理 L1 剩余元素</li><li>处理 L2 剩余元素未遍历，处理 L2 剩余元素</li></ol><h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建带有头指针的链表，方便操作</span></span><br><span class="line">    ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 新建一个 p 指针用于遍历</span></span><br><span class="line">    ListNode p = l3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环比较，并把较小的结点加入链表 l3</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val)&#123;</span><br><span class="line">            p.next = l1;</span><br><span class="line">            p = p.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.next = l2;</span><br><span class="line">            p = p.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 l1 剩余元素加入 l3</span></span><br><span class="line">    <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p.next = l1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 l2 剩余元素加入 l3</span></span><br><span class="line">    <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p.next = l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 l3 的头指针</span></span><br><span class="line">    <span class="keyword">return</span> l3.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>为 $O(n+m)$</li><li><strong>空间复杂度</strong>为 $O(1)$</li></ul><h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><h2 id="思路：递归"><a href="#思路：递归" class="headerlink" title="思路：递归"></a>思路：递归</h2><p>高手还另外提供了一种<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/" target="_blank" rel="noopener">递归思路</a>：</p><ul><li>两个链表头部较小的一个与剩下元素的 <code>merge</code> 操作结果合并</li></ul><h2 id="Java-实现-1"><a href="#Java-实现-1" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>为 $O(n+m)$</li><li><strong>空间复杂度</strong>为 $O(n+m)$ ：最多消耗 n+m 层栈空间</li></ul><h1 id="类似题：88-merge-sorted-array"><a href="#类似题：88-merge-sorted-array" class="headerlink" title="类似题：88.merge-sorted-array"></a>类似题：88.merge-sorted-array</h1><blockquote><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p><p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p><p>输出: [1,2,2,3,5,6]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="刷题标记-1"><a href="#刷题标记-1" class="headerlink" title="刷题标记"></a>刷题标记</h2><ul><li><input checked="" disabled="" type="checkbox"> 第一遍</li><li><input disabled="" type="checkbox"> 第二遍</li><li><input disabled="" type="checkbox"> 第三遍</li><li><input disabled="" type="checkbox"> 第四遍</li><li><input disabled="" type="checkbox"> 第五遍</li></ul><h2 id="Java-实现-2"><a href="#Java-实现-2" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先把 nums 所有元素移到最后，记录开始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        nums1[i + n] = nums1[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再遍历比较，写入到 nums1 前半部分</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = n;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n + m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[j] &lt; nums2[i]) &#123;</span><br><span class="line">            nums1[k++] = nums1[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k++] = nums2[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 nums1 剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n + m)&#123;</span><br><span class="line">        nums1[k++] = nums1[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 nums2 剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)&#123;</span><br><span class="line">        nums1[k++] = nums2[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>为 $O(n+m)$</li><li><strong>空间复杂度</strong>为 $O(1)$</li></ul><h2 id="高手方案-1"><a href="#高手方案-1" class="headerlink" title="高手方案"></a>高手方案</h2><ul><li>思路<ul><li>从后往前遍历，将大的放到 nums1 的指定位置</li></ul></li><li>Java 实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：LeetCode</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// two get pointers for nums1 and nums2</span></span><br><span class="line">    <span class="keyword">int</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// set pointer for nums1</span></span><br><span class="line">    <span class="keyword">int</span> p = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while there are still elements to compare</span></span><br><span class="line">    <span class="keyword">while</span> ((p1 &gt;= <span class="number">0</span>) &amp;&amp; (p2 &gt;= <span class="number">0</span>))</span><br><span class="line">        <span class="comment">// compare two elements from nums1 and nums2 </span></span><br><span class="line">        <span class="comment">// and add the largest one in nums1 </span></span><br><span class="line">        nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add missing elements from nums2</span></span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2 + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>为 $O(n+m)$</li><li><strong>空间复杂度</strong>为 $O(1)$</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>合并有序线性表</strong> L1、L2，有一个<strong>通用的思路</strong>，如下</p><ol><li>初始化每个表的遍历指针 Lp1，Lp2；并且新建一个线性表 L3，存储结果。</li><li>循环比较，将较小元素放入 L3</li><li>如果 L1 还有元素未遍历，处理 L1 剩余元素</li><li>处理 L2 剩余元素未遍历，处理 L2 剩余元素</li></ol>]]></content>
    
    <summary type="html">
    
      本篇文章带来有关两道有关 &quot;合并有序线性表&quot; 的求解过程
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://cosmosning.github.io/categories/LeetCode/"/>
    
    
      <category term="合并" scheme="https://cosmosning.github.io/tags/%E5%90%88%E5%B9%B6/"/>
    
      <category term="有序表" scheme="https://cosmosning.github.io/tags/%E6%9C%89%E5%BA%8F%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-189-rotate-array</title>
    <link href="https://cosmosning.github.io/2020/02/17/leetcode-189-rotate-array/"/>
    <id>https://cosmosning.github.io/2020/02/17/leetcode-189-rotate-array/</id>
    <published>2020-02-17T06:01:58.000Z</published>
    <updated>2020-04-06T04:56:53.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul><li><input checked="" disabled="" type="checkbox"> 第一遍</li><li><input disabled="" type="checkbox"> 第二遍</li><li><input disabled="" type="checkbox"> 第三遍</li><li><input disabled="" type="checkbox"> 第四遍</li><li><input disabled="" type="checkbox"> 第五遍</li></ul><h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p><p>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]<br>说明:</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>编写 <code>public void rotate(int[] nums, int k)</code> </p></blockquote><h2 id="思路：暴力法"><a href="#思路：暴力法" class="headerlink" title="思路：暴力法"></a>思路：暴力法</h2><ul><li>两个循环<ul><li>内部循环只向右移动一格，用一个变量暂存溢出元素</li><li>外部循环 <strong>k</strong> 次，相当于向右移动 k 个位置</li></ul></li></ul><h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 暴力法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;          <span class="comment">//多次移动</span></span><br><span class="line">        <span class="keyword">int</span> tail = nums[nums.length - <span class="number">1</span>];  <span class="comment">// 用一个变量暂存移位溢出的数字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            nums[j] = nums[j - <span class="number">1</span>];         <span class="comment">// 内部循环只移动一格</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[<span class="number">0</span>] = tail;                    <span class="comment">// 将溢出的数组，放到数组首位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>为 $O(n*k)$</li><li><strong>空间复杂度</strong>为 $O(1)$</li></ul><h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><h2 id="思路：使用反转"><a href="#思路：使用反转" class="headerlink" title="思路：使用反转"></a>思路：使用反转</h2><p>这里记录一下 <strong>使用反转</strong> 这个思路</p><blockquote><p>这个方法基于这个事实：当我们旋转数组 k 次，$k%n$ 个尾部元素会被移动到头部，剩下的元素会被向后移动。</p><p>在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 $n−k$ 个元素，就能得到想要的结果。</p></blockquote><h2 id="Java-实现-1"><a href="#Java-实现-1" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>为 $O(n)$</li><li><strong>空间复杂度</strong>为 $O(1)$</li></ul><p>更多参见<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>循环移动数组元素可以利用<strong>反转</strong>高效解决，即<ul><li>反转数组所有元素</li><li>反转前 k 个 元素</li><li>反转后 n - k 个元素</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      本篇文章带来有关 &quot;LeetCode-189-rotate-array&quot; 我的求解过程
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://cosmosning.github.io/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="https://cosmosning.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-26-remove-duplicates-from-sorted-array</title>
    <link href="https://cosmosning.github.io/2020/02/17/leetcode-26-remove-duplicates-from-sorted-array/"/>
    <id>https://cosmosning.github.io/2020/02/17/leetcode-26-remove-duplicates-from-sorted-array/</id>
    <published>2020-02-17T03:36:38.000Z</published>
    <updated>2020-04-06T04:56:53.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul><li><input checked="" disabled="" type="checkbox"> 第一遍</li><li><input disabled="" type="checkbox"> 第二遍</li><li><input disabled="" type="checkbox"> 第三遍</li><li><input disabled="" type="checkbox"> 第四遍</li><li><input disabled="" type="checkbox"> 第五遍</li></ul><h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><p>给定数组 nums = [1,1,2], </p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。<br>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>int len = removeDuplicates(nums);</p><p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>   print(nums[i]);<br>}</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>编写 <code>public int removeDuplicates(int[] nums)</code> 函数</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于数组是有序的，所以重复的元素在数组中必定是连续出现。可以用双指针遍历比较数组元素，将非重复的元素依次放到数组前半部分即可。</p><p>双指针遍历问题中，关键是处理好各个指针移动的条件。对于本题，双指针的移动可由如下类 C 伪码描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;  <span class="comment">// 记录数组中非重复元素的最后一个元素的下标</span></span><br><span class="line">j = <span class="number">0</span>;  <span class="comment">// 用于遍历数组，与下标为 i 的元素比较</span></span><br><span class="line"><span class="keyword">if</span> (nums[i] == nums[j])&#123;     <span class="comment">// 遇到重复元素</span></span><br><span class="line">    j++;                     <span class="comment">// 那么移动 j 指针，继续寻找非重复元素的下标</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                     <span class="comment">// 遇到非重复元素</span></span><br><span class="line">    nums[++i] = nums[j++];   <span class="comment">// 将 j 下标的元素复制到 i 的下一个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><p>根据上述思路，很容易得到以下 Java 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 记录数组中非重复元素的最后一个元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// 用于遍历数组，与下标为 i 的元素比较</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用双指针遍历比较数组元素</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[j]) &#123;       <span class="comment">// 遇到重复元素</span></span><br><span class="line">            j++;                        <span class="comment">// 那么移动 j 指针，继续寻找非重复元素的下标</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                        <span class="comment">// 遇到非重复元素</span></span><br><span class="line">            nums[++i] = nums[j++];      <span class="comment">// 将 j 下标的元素复制到 i 的下一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;                       <span class="comment">// 返回元素个数，因而 i 要加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于只涉及到一个循环，其<strong>时间复杂度</strong>为 $O(n)$ ;</p><p>由于只涉及到常数级别的额外空间使用，故<strong>空间复杂度</strong>为 $O(1)$ </p><h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><p>参见<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/" target="_blank" rel="noopener">官方题解</a>，与我的思路类似。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><strong>双指针</strong>技巧，又称作<strong>快慢指针</strong>：通过两个遍历速度不同的指针，达到遍历过程中比较等操作。</li><li><strong>双指针</strong>的思路关键要处理好<strong>遍历指针移动的条件</strong>。这个问题解决好了，那么问题也就解决了。</li></ul>]]></content>
    
    <summary type="html">
    
      本篇文章带来有关 &quot;LeetCode-26-remove-duplicates-from-sorted-array&quot; 我的求解过程
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://cosmosning.github.io/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="https://cosmosning.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://cosmosning.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="快慢指针" scheme="https://cosmosning.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Queue及PriorityQueue源码浅析-Java</title>
    <link href="https://cosmosning.github.io/2020/02/14/queue-ji-priorityqueue-yuan-ma-qian-xi-java/"/>
    <id>https://cosmosning.github.io/2020/02/14/queue-ji-priorityqueue-yuan-ma-qian-xi-java/</id>
    <published>2020-02-14T14:28:16.000Z</published>
    <updated>2020-04-06T04:56:53.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="性质及继承、实现关系"><a href="#性质及继承、实现关系" class="headerlink" title="性质及继承、实现关系"></a>性质及继承、实现关系</h2><ul><li>性质<ul><li>抽象接口</li></ul></li><li>继承关系<ul><li>继承（扩展了）Collection</li></ul></li></ul><h2 id="主要方法及解释"><a href="#主要方法及解释" class="headerlink" title="主要方法及解释"></a>主要方法及解释</h2><p>待完成</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">boolean add(E e)</td><td align="center"></td></tr><tr><td align="center">boolean offer(E e);</td><td align="center"></td></tr><tr><td align="center">E remove();</td><td align="center"></td></tr><tr><td align="center">E poll();</td><td align="center"></td></tr><tr><td align="center">E element();</td><td align="center"></td></tr><tr><td align="center">E peek();</td><td align="center"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      本文简述阅读 Queue 和 PriorityQueue 源码的体会和感悟
    
    </summary>
    
    
      <category term="源码历险记" scheme="https://cosmosning.github.io/categories/%E6%BA%90%E7%A0%81%E5%8E%86%E9%99%A9%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://cosmosning.github.io/tags/Java/"/>
    
      <category term="源码" scheme="https://cosmosning.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Queue" scheme="https://cosmosning.github.io/tags/Queue/"/>
    
      <category term="PriorityQueue" scheme="https://cosmosning.github.io/tags/PriorityQueue/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-11-container-with-most-water</title>
    <link href="https://cosmosning.github.io/2020/02/13/leetcode-11-container-with-most-water/"/>
    <id>https://cosmosning.github.io/2020/02/13/leetcode-11-container-with-most-water/</id>
    <published>2020-02-13T14:03:05.000Z</published>
    <updated>2020-04-06T04:56:53.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul><li><input checked="" disabled="" type="checkbox"> 第一遍</li><li><input disabled="" type="checkbox"> 第二遍</li><li><input disabled="" type="checkbox"> 第三遍</li><li><input disabled="" type="checkbox"> 第四遍</li><li><input disabled="" type="checkbox"> 第五遍</li></ul><h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例:</p><p>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>编写 <code>public int maxArea(int[] height)</code> 函数</p></blockquote><h2 id="思路：暴力解法"><a href="#思路：暴力解法" class="headerlink" title="思路：暴力解法"></a>思路：暴力解法</h2><p>很自然的一种暴力思路就是枚举每一种可能，计算题意中的面积；并且，在枚举过程中，不断比较，得到最大值。</p><h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 思路：二重循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> minIndex = height[i] &gt; height[j] ? j : i;</span><br><span class="line">            <span class="keyword">int</span> area = height[minIndex] * (j - i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (area &gt; result) &#123;</span><br><span class="line">                result = area;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，程序包含二重循环，因而<strong>时间复杂度</strong>为 $O(n^2)$ </p><h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><p>上述方案比较费时，来看一看高手的解法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>利用<strong>双指针</strong>，分别初始在<strong>起始</strong>和<strong>末尾</strong>。</li><li>依题意，计算所围的面积</li><li>将<strong>高度较短</strong>的指针向中心移动，然后回到第 2 步 </li></ul><p>P.S. 为什么是移动高度较短的指针？因为移动较高的指针，只会使得面积变小；而移动较低指针，可能会遇到较高指针（基于此假设，面积可能会变大）。</p><h3 id="Java-实现-1"><a href="#Java-实现-1" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 作者：LeetCode</span></span><br><span class="line">    <span class="comment">// 链接：https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode/</span></span><br><span class="line">    <span class="keyword">int</span> maxarea = <span class="number">0</span>, l = <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));</span><br><span class="line">        <span class="keyword">if</span> (height[l] &lt; height[r])</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxarea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，<strong>时间复杂度</strong>为 $O(n)$ ，这是一个极大的优化</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>解题小套路<ul><li>遇到较难的题目<ul><li>先想<strong>能否暴力解决</strong>，在此之后再优化，或者看别人思路。</li><li>暴力无法解决，找找<strong>解的规律</strong>，即从基本情况开始，寻找其是否有<strong>重复子问题</strong></li></ul></li></ul></li><li><strong>双指针</strong>在数组遍历中是一个常见套路，需要多多注意。</li></ul>]]></content>
    
    <summary type="html">
    
      本篇文章带来有关 &quot;LeetCode-11-container-with-most-water&quot; 我的求解过程
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://cosmosning.github.io/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="https://cosmosning.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://cosmosning.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="左右夹逼" scheme="https://cosmosning.github.io/tags/%E5%B7%A6%E5%8F%B3%E5%A4%B9%E9%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-141-linked-list-cycle</title>
    <link href="https://cosmosning.github.io/2020/02/12/leetcode-141-linked-list-cycle/"/>
    <id>https://cosmosning.github.io/2020/02/12/leetcode-141-linked-list-cycle/</id>
    <published>2020-02-12T14:49:58.000Z</published>
    <updated>2020-04-06T04:56:53.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul><li><input checked="" disabled="" type="checkbox"> 第一遍</li><li><input disabled="" type="checkbox"> 第二遍</li><li><input disabled="" type="checkbox"> 第三遍</li><li><input disabled="" type="checkbox"> 第四遍</li><li><input disabled="" type="checkbox"> 第五遍</li></ul><h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：</p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p>示例 2：</p><p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p><p>示例 3：</p><p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>编写 <code>public boolean hasCycle(ListNode head)</code> 函数</p></blockquote><p>P.S.这道题，我审题出现了错误。原本以为要自己实现 <code>ListNode</code> 类，结果不需要。只要依据输入的链表编写 <code>hasCycle</code> 函数即可。</p><h2 id="暴力思路"><a href="#暴力思路" class="headerlink" title="暴力思路"></a>暴力思路</h2><p>有环的链表，从头节点依次向下一个结点遍历，一定会出现死循环；而无环链表，就会正常跳出循环。</p><p>一种直接的思路时，依次遍历链表的每个结点，并把它缓存起来。之后碰到与缓存中相同的结点，说明链表有环；正常的循环终止，说明无环。</p><h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 缓存结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list.contains(head))              <span class="comment">// 如果缓存中存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;                     <span class="comment">// 直接返回 true</span></span><br><span class="line"></span><br><span class="line">        list.add(head);                      <span class="comment">// 否则，将该结点加入缓存</span></span><br><span class="line">        head = head.next;                    <span class="comment">// 继续遍历</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;                            <span class="comment">// 循环正常退出，非死循环，返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述代码分析可得，该算法的<strong>时间复杂度</strong>为 O( n )，<strong>空间复杂度</strong>为 O( n )</p><p>根据题中描述，貌似存在只使用<strong>常量级别</strong>（ O(1) ）空间的算法，让我们来看看高手的方案。</p><h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高手利用了<strong>两个指针遍历</strong>链表，但是却以<strong>不同的速度</strong>在遍历。如果链表中有环，那么在有限的循环中它们一定会相碰（即访问到同一个结点）；否则，一定会有一个指针（这个指针是快指针）提前到达链表尾部，从而返回无环的判断结果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><strong>双指针</strong>但以<strong>不同速度</strong>遍历链表（类比田径比赛中的快慢运动员），可以判断链表是否有环，其空间复杂度为 O( 1 )</li></ul>]]></content>
    
    <summary type="html">
    
      本篇文章带来有关 &quot;LeetCode-141-linked-list-cycle&quot; 我的求解过程
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://cosmosning.github.io/categories/LeetCode/"/>
    
    
      <category term="双指针" scheme="https://cosmosning.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="遍历" scheme="https://cosmosning.github.io/tags/%E9%81%8D%E5%8E%86/"/>
    
      <category term="链表" scheme="https://cosmosning.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="快慢指针" scheme="https://cosmosning.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
