<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CosmosNing的个人博客</title>
  <link rel="alternate" type="text/html" href="https://cosmosning.github.io"/>
  <link rel="self" type="application/atom+xml" href="/atom.xml"/>
  
  <updated>2020-11-12T01:07:59.780Z</updated>
  <id>https://cosmosning.github.io/</id>
  <icon>https://gitee.com/CosmosNing/MyPicGo/raw/master/images/avatar-32.ico</icon>
  <subtitle>探索·好奇</subtitle>
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Keyword Search over Knowledge Graphs via Static and Dynamic Hub Labelings 阅读笔记</title>
    <link href="https://cosmosning.github.io/2020/10/08/notes-of-keyword-search-knowledge-2020/"/>
    <id>https://cosmosning.github.io/2020/10/08/notes-of-keyword-search-knowledge-2020/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-10-08T01:35:02.000Z</published>
    <updated>2020-11-12T01:07:59.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="highlights">Highlights</h1><ul><li><strong>Static Hub Labelings</strong></li><li><strong>Dynamic Hub Labelings</strong></li></ul><h1 id="what">What？</h1><h2 id="problem">Problem</h2><p>一种常见的图数据上的关键词查询的方法是，将每一个关键词与图上的一个顶点匹配，并且从中抽取出包含这些匹配顶点的最小权重的树（这种树被称为 <em>minimum-weight Steiner trees</em>）。更规范地说，给定一个有权边的数据图和一个关键词查询，首先对于每一个关键词，在图中找到与之匹配的所有顶点，形成一个匹配集；然后，在图中找到一个扩展匹配集的树，该树对于每一个匹配集，至少包含其中的一个顶点，并且总边权重最小。这个优化问题叫做 <em>group Steiner tree (GST) problem</em> 。</p><div class="note info"><p>数据图中的边也可以被关键词匹配。我们可以通过 <em>graph subdivision</em> 将边匹配转换为点匹配，之后使用点匹配的方式处理该匹配就行了。</p></div><h2 id="contributions">Contributions</h2><ul><li>设计了一个质量有保证的近似算法，能够在毫秒级内，从百万级大小的知识图谱中返回不错的结果。</li><li>设计了动态、静态 HL，提高了总体的效率。</li></ul><h1 id="why">Why？</h1><p>知识图谱越来越大，现存的算法太慢了。</p><h1 id="how">How？</h1><h2 id="problem-formulation">Problem Formulation</h2><ul><li><strong>知识图谱（<em>KG</em>）</strong>：规范的，知识图谱是一个简单的无向图 <span class="math inline">\(G=&lt;V,E&gt;\)</span> ，其中 <span class="math inline">\(V\)</span> 是包含 <span class="math inline">\(n\)</span> 个顶点的有限集合，用来指代实体（<em>entity</em>），而 <span class="math inline">\(E\subseteq V\times V\)</span> 是顶点无序对的有限集合，作为图的无向边，用来代表实体之间的关系（<em>relation</em>）。<ul><li><strong>边权重</strong>：定义一个权重函数 <span class="math inline">\(\textrm{wt}:E\mapsto \mathbb{R}^{0+}\)</span> （<strong>小权重表示重要性大</strong>）。</li></ul></li><li><strong>图中术语</strong><ul><li><span class="math inline">\(\textrm{len}(p)\)</span> ：对于一条路径 <span class="math inline">\(p\)</span> ，它的<strong>长度</strong>是路径中所有边的权重之和。</li><li><span class="math inline">\(\textrm{dist}(u,v)\)</span> ：在图 <span class="math inline">\(G\)</span> 中，连接 <span class="math inline">\(u\)</span> 、<span class="math inline">\(v\)</span> 的<strong>最短路径的长度</strong>。如果不存在，那么为 <span class="math inline">\(\infty\)</span> 。</li></ul></li><li><strong>关键词映射</strong>：定义一个获取函数 <span class="math inline">\(\textrm{hits}:\mathbb{K}\mapsto 2^V\)</span> ，它将关键词映射到顶点集 <span class="math inline">\(V\)</span> 的子集。</li><li><strong>关键词查询</strong>：一个<strong>关键词查询</strong> <span class="math inline">\(Q\subseteq \mathbb{K}\)</span> 是一个关键词的有限集合。<ul><li>给定一个含有 <span class="math inline">\(g\)</span> 个关键词的查询 <span class="math inline">\(Q=\{k_1,k_2,\dots,\ k_g\}\)</span> ，将 <span class="math inline">\(\textrm{hits}(k_i)\)</span> 简记为 <span class="math inline">\(K_i\)</span> （<span class="math inline">\(1\le i\le g\)</span>），并称之为<strong>关键词顶点</strong>。</li><li>给定一个图 <span class="math inline">\(G=&lt;V,E&gt;\)</span> ，在 <span class="math inline">\(G\)</span> 上关于 <span class="math inline">\(Q\)</span> 的结果是一个 <em>group Steiner tree (GST)</em> ，记作 <span class="math inline">\(T=&lt;V_T,E_T&gt;\)</span> ，满足以下条件<ul><li><span class="math inline">\(V_T\subseteq V,E_T\subseteq E\)</span> ，并且 <span class="math inline">\(T\)</span> 是一棵树；</li><li><span class="math inline">\(V_T\)</span> 包含来自每一个 <span class="math inline">\(K_i\)</span> （<span class="math inline">\(1\le i\le g\)</span>）中的至少一个顶点，也就是 <span class="math inline">\(V_T\cap K_i =\emptyset\)</span> ；</li><li>树的权重（定义为 <span class="math inline">\(\textrm{WT}(T)=\sum_{e\in E_T}\textrm{wt}(e)\)</span>）最小</li></ul></li></ul></li></ul><h2 id="overview-of-two-algorithm">Overview of Two Algorithm</h2><p>第一个算法 <em>KeyKG</em> 为每一个关键词选取匹配的顶点，并且找到对应的树。对于 <span class="math inline">\(g\)</span> 个关键词，<em>KeyKG</em> 是一个 <span class="math inline">\((g-1)\)</span> - 近似算法，也就是说，一个 GST 的边权值的总和至多是最小权重的 <span class="math inline">\((g-1)\)</span> 倍。获得这样的近似效果要归功于匹配顶点集的选择和利用最短路径树的构造。为了更高效的在线计算距离和最短路径，该文章设计了一个 HL ，这个 HL 使用了一种全新的基于 <em>betweenness centrality</em> 的启发式方法改善了现存的 <em>pruned landmark labeling</em> 。传统的，这种 HL 是静态的，因为它是离线生成的，并且对查询是不变的。在巨大的知识图谱中， 使用静态 HL 的 <em>KeyKG</em> 算法至少比目前先进的算法快一个数量级，并且所得结果的质量也较高。</p><p>第二个算法 <em>KeyKG+</em> 通过使用一种新颖的 HL 扩展了 <em>KeyKG</em> 算法。这里所提出的 HL 是动态的，因为它是在处理一个具体的查询时，通过倒排和聚集某些查询相关的静态标签，而动态生成的。它减少了 KeyKG 算法中的重复操作（这些重复操作是指使用传统静态 HL 计算顶点集的距离）。尽管在线生成会花费额外的时间，使用动态 HL 为总体效率带来了几个数量级的提高。</p><h2 id="keykg-with-static-hl">KeyKG With Static HL</h2><h3 id="algorithm-keykg">Algorithm KeyKG</h3><h4 id="algorithm-explained">Algorithm Explained</h4><p>如下图<strong>算法 1</strong> 所示，<em>KeyKG</em> 在知识图谱中找到一个 <em>GST</em> ，这个 <em>GST</em> 是由 <span class="math inline">\(g\)</span> 个关键词集合扩展而来。简而言之， <em>KeyKG</em> 首先贪婪地选择一组相互靠近的一组关键词顶点集合（记作 <span class="math inline">\(U_x\)</span>），这组关键词顶点集合包含了来自每一个 <span class="math inline">\(K_i\)</span> （<span class="math inline">\(1\le i\le g\)</span>）中的一个顶点（<strong>Line 1 - 8</strong>）。然后，<em>KeyKG</em> 贪婪地找到一个由 <span class="math inline">\(U_x\)</span> 扩展而来的 <em>GST</em> （记作 <span class="math inline">\(T_{u_{min}}\)</span>），这个过程是通过迭代地扩展最短路径而得到的（<strong>Line 9 - 18</strong>）。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/Algo1.PNG" alt="算法 1" /><figcaption>算法 1</figcaption></figure><p>具体的，对于每一个 <span class="math inline">\(v_1 \in K_1\)</span> （<strong>Line 1</strong>），<em>KeyKG</em> 从每一个 <span class="math inline">\(K_i\)</span> 找到一个顶点 <span class="math inline">\(v_i\)</span> ，它距离 <span class="math inline">\(v_1\)</span> 的距离最短（<strong>Line 2 - 4</strong>）。令 <span class="math inline">\(U_{v_1}\)</span> 为所有这样的顶点 <span class="math inline">\(v_i\)</span> （包括 <span class="math inline">\(v_1\)</span>）的的集合，并且令 <span class="math inline">\(W_{v_1}\)</span> 为它们到 <span class="math inline">\(v_1\)</span> 的距离之和（<strong>Line 5 - 6</strong>）。令 <span class="math inline">\(x\in K_1\)</span> 为 <span class="math inline">\(K_1\)</span> 中 <span class="math inline">\(W_{v_1}\)</span> 最小的顶点（<strong>Line 8</strong>）。</p><div class="note info"><p><strong>扩展 <span class="math inline">\(U_x\)</span> 所得到的 GST 可能有较小的权重</strong></p><ul><li>因为 <span class="math inline">\(U_x\)</span> 包含了来自每一个 <span class="math inline">\(K_i\)</span> （<span class="math inline">\(1\le i\le g\)</span>）中的一个顶点，并且这些顶点相对而言十分接近，所以扩展 <span class="math inline">\(U_x\)</span> 所得到的 GST 可能有较小的权重。</li></ul></div><p><strong>算法 1</strong> 剩下的部分以每一个 <span class="math inline">\(u\in U_x\)</span> 构造一个 <em>GST</em> <span class="math inline">\(T_u\)</span> ，并且从这 <span class="math inline">\(|U_x|\)</span> 棵 <em>GST</em> 中找出权重最小的那一个。具体的，每一棵 <span class="math inline">\(T_u\)</span> 被初始化为只含有一个单一的顶点 <span class="math inline">\(u\)</span> （<strong>Line 9 - 10</strong>）。然后，不断迭代直至 <span class="math inline">\(T_u\)</span> 扩展了 <span class="math inline">\(U_x\)</span> 中的所有顶点（<strong>Line 11</strong>）：从 <span class="math inline">\(T_u\)</span> 中选取一个点 <span class="math inline">\(s_{\textrm{min}}\)</span> ，从 <span class="math inline">\(U_x-T_u\)</span> 中选一个点 <span class="math inline">\(t_{\textrm{min}}\)</span> ，它们之间的距离最短（<strong>Line 12</strong>）。接着，找到 <span class="math inline">\(s_{\textrm{min}}\)</span> 和 <span class="math inline">\(t_{\textrm{min}}\)</span> 之间的最短路径，并将路径上的顶点和边加入 <span class="math inline">\(T_u\)</span> （<strong>Line 13 -14</strong>）。令 <span class="math inline">\(u_{\textrm{min}}\in U_x\)</span> 表示一个顶点，满足它所对应的 <span class="math inline">\(T_u\)</span> 的权重最小（<strong>Line 17</strong>）。最终 <em>KeyKG</em> 将 <span class="math inline">\(T_{u_\textrm{min}}\)</span> 作为结果返回。</p><div class="note default"><p><strong>算法 1 中的 <code>getD</code> 和 <code>getSP</code></strong></p><ul><li><code>getD</code> ：计算两个顶点之间的距离。</li><li><code>getSP</code>：计算两个顶点之间的最短路径。</li></ul></div><h4 id="running-example">Running Example</h4><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><p>举个例子，如上图，给定一个查询 <span class="math inline">\(Q=\{k_1,k_2,k_3\}\)</span> ，则 <span class="math inline">\(K_1=\{B,F\},\;K_2=\{E\},\;K_3=\{C,D\}\)</span> 。</p><ul><li>对于 <span class="math inline">\(B\in K_1\)</span> ，<span class="math inline">\(E\)</span> 必选；由于 <span class="math inline">\(\textrm{dist}(B,C) = 1 &lt; 1.6 = \textrm{dist}(B,D)\)</span> ，所以选择 <span class="math inline">\(C\)</span> 。故 <span class="math inline">\(U_B = \{B,E,C\}\)</span> 。</li><li>对于 <span class="math inline">\(B\in K_2\)</span> ，<span class="math inline">\(E\)</span> 必选；由于 <span class="math inline">\(\textrm{dist}(F,C) = 1.1 &lt; 1.7 = \textrm{dist}(F,D)\)</span> ，所以选择 <span class="math inline">\(C\)</span> 。故 <span class="math inline">\(U_B = \{F,E,C\}\)</span> 。</li></ul><p>下面计算各自的权重之和：</p><ul><li>对于 <span class="math inline">\(U_B\)</span> ，<span class="math inline">\(W_B=\textrm{dist}(B,E)+\textrm{dist}(B,C) = 0.8+1 = 1.8\)</span></li><li>对于 <span class="math inline">\(U_F\)</span> ，<span class="math inline">\(W_B=\textrm{dist}(F,E)+\textrm{dist}(F,C) = 0.9+1.1 = 2\)</span></li></ul><p>由于 <span class="math inline">\(W_B &lt; W_F\)</span> ，故 <span class="math inline">\(x = B\)</span> 。</p><p>接下来生成 <em>GST</em> ：</p><ul><li><span class="math inline">\(T_B\)</span><ul><li>初始化 <span class="math inline">\(T_B\)</span> 中仅有一个顶点 <span class="math inline">\(B\)</span></li><li>令 <span class="math inline">\(s_{\textrm{min}} = B\)</span> ，则 <span class="math inline">\(t_{\textrm{min}} = E\)</span> ，因为 <span class="math inline">\(\textrm{dist}(B,E) &lt; \textrm{dist}(B,C)\)</span></li><li>令 <span class="math inline">\(t_{\textrm{min}} = C\)</span> ，则 <span class="math inline">\(s_\textrm{min} = E\)</span> ，因为 <span class="math inline">\(dist(E,C) &lt; \textrm{dist}(B,C)\)</span></li><li>再求出相关最短距离的路径，将路径上的顶点和边加入 <span class="math inline">\(T_B\)</span> ，即可得到图 <strong>KeyKG 执行的例子</strong> 中的 <span class="math inline">\(T_B\)</span></li></ul></li><li><span class="math inline">\(T_E\)</span> ：类似 <span class="math inline">\(T_B\)</span> 分析可得</li><li><span class="math inline">\(T_C\)</span> ：类似 <span class="math inline">\(T_B\)</span> 分析可得</li></ul><h3 id="static-hl">Static HL</h3><h4 id="why-we-need-hub-labeling">Why we need Hub Labeling？</h4><p>由上述介绍可知，<em>KeyKG</em> 依赖于两个子函数 <code>getD</code> 和 <code>getSP</code> 。在巨大的知识图谱中，一种直观的在线的实现这些子函数的方法（例如 Dijkstra 算法）的执行时间太长了；另一方面，离线生成每对顶点之间的距离和最短路径的空间开销十分大。为了权衡时空开销，这篇文章使用了 Hub Labeling ，一种离线生成的索引结构。</p><h4 id="basic-concept">Basic Concept</h4><p>一个静态的 HL 是一个图上的离线生成的索引结构。规范的说，对于一个图 <span class="math inline">\(G=&lt;V,E&gt;\)</span> ，一个静态的 HL ，可以看作一个函数 <span class="math inline">\(L:V\mapsto 2^V\)</span> ，它将顶点映射到顶点的集合（称作 <em>hub</em>），并且满足下列条件：</p><ul><li><span class="math inline">\(\forall u,v\in V\)</span> ，并且 <span class="math inline">\(u，v\)</span> 在 <span class="math inline">\(G\)</span> 中是连通的，<span class="math inline">\(\exists h\in L(u)\cap L(v)\)</span> ，使得 <span class="math inline">\(h\)</span> 在 <span class="math inline">\(u,v\)</span> 之间的最短路径上</li></ul><div class="note info"><p>对于 <span class="math inline">\(\forall v\in V\)</span> ， <span class="math inline">\(L(v)\)</span> 称为顶点 <span class="math inline">\(v\)</span> 的<strong>标签</strong>。</p></div><h4 id="supporting-for-computing-getd-but-not-getsp">Supporting For Computing <code>getD</code> but not <code>getSP</code></h4><p>在标准的索引结构中，每一个 <span class="math inline">\(L(v)\)</span> 是一个列表，其中包含按标识符排序的 hubs 。对于每一个 <span class="math inline">\(h\in L(v)\)</span> ，<span class="math inline">\(\textrm{dist}(v,h)\)</span> 也会预先计算出来并保存。这样我们就可以通过如下公式计算 <code>getD</code> ： <span class="math display">\[\textrm{getD}(u,v)=\begin{cases}\underset{h\in L(u)\cap L(v)}{min} \textrm{dist}(u,h) + \textrm{dist}(v,h) &amp; L(u)\cap L(v) \ne \emptyset\\\infty &amp; L(u)\cap L(v) = \emptyset\\\end{cases}\]</span> 其中，<span class="math inline">\(\textrm{dist}(u,h)\)</span> 和 <span class="math inline">\(\textrm{dist}(v,h)\)</span> 分别存储在 <span class="math inline">\(L(u)\)</span> 和 <span class="math inline">\(L(v)\)</span> 中。</p><p>但是，无法计算 <code>getSP</code></p><h4 id="improvement-in-construction">Improvement in Construction</h4><p><strong>动机</strong></p><p>从 <span class="math inline">\(\textrm{getD}(u,v)\)</span> 计算公式来看，当索引标签较小时，<code>getD</code> 的在线计算会更快。但是，最小化索引标签的平均大小是一个 NP-Hard 问题，并且具有对数不可近似性（<em>logarithmic inapproximability</em>）。给定一个图，有很多不同的启发式的方法能够构建合理的较小的索引标签。在其他的方法中，<em>pruned landmark labeling</em> (PLL) 是一个非常热门的实现方法，它利用了 Dijkstra 算法，并且能够高效的剪枝达到缩小索引标签大小的目的。</p><p><strong>算法</strong></p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/Algo2.PNG" alt="Algorithm 2" /><figcaption>Algorithm 2</figcaption></figure><p>如<strong>算法 2</strong> 所示，标准的 PLL 基本流程是执行 Dijkstra 算法 <span class="math inline">\(n\)</span> 次，其中 <span class="math inline">\(n\)</span> 为顶点的个数（Line 3 - 24），并且在此过程中迭代地扩展顶点标签（Line 4，Line 12）。记 <span class="math inline">\(i\)</span> 次迭代后 <span class="math inline">\(v\)</span> 的标签为 <span class="math inline">\(L_i(v)\)</span> 。在第 <span class="math inline">\(i\)</span> 次迭代，Dijkstra 算法从一个不同的顶点 <span class="math inline">\(v_i\in V\)</span> 出发（Line 7），访问其他顶点并且计算它们与 <span class="math inline">\(v_i\)</span> 之间的距离，存储到 <span class="math inline">\(d\)</span> 中（Line 14 - 15），再将 <span class="math inline">\(v_i\)</span> 加入到它们的索引标签中。</p><div class="note info"><p><strong>关于剪枝</strong></p><ul><li>由于一些顶点 <span class="math inline">\(u\)</span> 没有被访问到，所以它们的标签可以剪掉。</li><li>当 <span class="math inline">\(u\)</span> 与 <span class="math inline">\(v_i\)</span> 的距离可由构造好的 <span class="math inline">\(L_{i-1}\)</span> 标签计算得到，也就是 Line 11 的条件为假，那么会发生剪枝。</li></ul></div><p><strong>改进：Betweenness Centrality</strong></p><p>我们的目标是能够做更多剪枝来提高整个系统的性能。具体的，我们想要迭代早期构造的索引标签能够支持计算更多对顶点之间的距离，这样在后期的迭代过程中，就可以更频繁地发生剪枝操作。直观地，这可以通过这种方式实现，即在 Dijkstra 算法迭代的早期，选择那些许多最短路径都经过的顶点作为起始顶点。为了实现这个想法，原始的 PLL 实现方式是利用一些启发式的方法，对这些起始顶点按照其度数降序排列，因为高度数的顶点更有可能出现在许多顶点对之间的最短路径上。与传统方法不同，我们基于 <em>betweenness centrality</em> 对它们降序排序。顶点 <span class="math inline">\(v\)</span> 的 <em>betweenness centrality</em> 定义如下： <span class="math display">\[\textrm{bc}(v)=\underset{s,\;t\in V\backslash\ \{v\}}{\sum}\frac{\sigma_{st}(v)}{\sigma_{st}}\]</span> 其中，<span class="math inline">\(\sigma_{st}\)</span> 表示顶点 <span class="math inline">\(s,\;t\)</span> 之间最短路径的个数，<span class="math inline">\(\sigma_{st}(v)\)</span> 表示上述路劲中经过顶点 <span class="math inline">\(v\)</span> 的。</p><div class="note info"><p><strong>图上任意两个顶点之间的最短路径不止一条</strong>，因为可能存在<strong>最小权值相等但是路径不同</strong>的情况。</p></div><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><div class="note default"><p>举个例子，如上图中的图。可以用 Floyd 算法计算出任意两顶点之间的最短距离和路径。之后依据这个信息和 <em>betweenness centrality</em> 的定义可得：</p><ul><li><span class="math inline">\(\textrm{bc}(A) = 7\)</span></li><li><span class="math inline">\(\textrm{bc}(B)=4\)</span></li><li><span class="math inline">\(\textrm{bc}(C)=\textrm{bc}(D)=\textrm{bc}(E)=\textrm{bc}(F)=0\)</span></li></ul><p>但是，论文中用了 [4] （<strong>TODO</strong>）中的近似算法来缩短计算时间。</p></div><p><strong>构造 Static HL 的例子</strong></p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><p>假设图的结构如上图所示。</p><p>首先初始化 <span class="math inline">\(L_0(v)\)</span> ：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_0(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_0(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_0(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_0(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_0(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_0(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>接着按照 <em>betweenness centrality</em> 对顶点降序排序，顺序为 <strong>A, B, C, D, E, F</strong>；</p><hr /><p>进入第一次循环：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(d[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>0</strong></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr></tbody></table><p>PQ 优先队列为：</p><table><thead><tr class="header"><th style="text-align: center;">A</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头（队尾）</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>进入内层 while 循环，</p><p>从 PQ 中弹出 <span class="math inline">\(A\)</span> 赋给 <span class="math inline">\(u\)</span> ，即 <span class="math inline">\(u=A\)</span> ；</p><p>将 <span class="math inline">\(visit[u]\)</span> 置 1，则：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><p>利用 <span class="math inline">\(L_0\)</span> 计算 <span class="math inline">\(\textrm{getD}(v_1,u)\)</span> ，即计算 <span class="math inline">\(\textrm{getD}(A,A)\)</span> 。由于 <span class="math inline">\(L_0(A)=\emptyset\)</span> ，故 <span class="math inline">\(L_0(A)\cap L_0(A) = \emptyset\)</span>，所以 <span class="math inline">\(\textrm{getD}(A,A) = \infty\)</span> （利用 <span class="math inline">\(\textrm{getD}\)</span> 的公式可得）。</p><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[A] = 0 &lt; \textrm{getD}(v_1,u)\)</span> ，故 Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrow L_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 42%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><hr /><p>在接下来的对 <span class="math inline">\(u=A\)</span> 未被访问的邻居顶点执行操作。</p><p>访问第一个邻居 <span class="math inline">\(B\)</span> 后，<span class="math inline">\(d\)</span> 变化如下：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(d[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;"><strong>0.6</strong></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr></tbody></table><p>则有属于 <span class="math inline">\(L_1(B)\)</span> 的 <span class="math inline">\(A(\textrm{dist} = 0.6, \textrm{pred}= A)\)</span> ，同时 B 插入到 PQ 中。</p><p>类似的，有</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(d[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0.6</td><td style="text-align: center;"><strong>0.4</strong></td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;"><strong>0.3</strong></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr></tbody></table><p>属于 <span class="math inline">\(L_1(C)\)</span> 的 <span class="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}= A)\)</span></p><p>属于 <span class="math inline">\(L_1(D)\)</span> 的 <span class="math inline">\(A(\textrm{dist} = 1, \textrm{pred}= A)\)</span></p><p>属于 <span class="math inline">\(L_1(E)\)</span> 的 <span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></p><p>在所有 A 的邻居访问完后，PQ 变为</p><table><thead><tr class="header"><th style="text-align: center;">E</th><th style="text-align: center;">C</th><th style="text-align: center;">B</th><th style="text-align: center;">D</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">队尾</td><td style="text-align: center;"></td></tr></tbody></table><p>然后，回到 <code>while</code> 循环。</p><hr /><p>PQ 弹出 E，置 <span class="math inline">\(visit\)</span> 为 1：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">0</td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[E] = 0.3 &lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,E) = \infty\)</span> ，故 Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrow L_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 31%" /><col style="width: 8%" /><col style="width: 8%" /><col style="width: 8%" /><col style="width: 33%" /><col style="width: 8%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>E 未访问的邻居为 B，但由于 <span class="math inline">\(d[u]+\text{wt}((u,w)) = d[E] + \text{wt}((E,B)) = 0.3 + 0.8 = 1.1 &gt; d[B] = 0.6\)</span>，所以不更新；又由于 B 在 PQ 中，所以不加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;">C</th><th style="text-align: center;">B</th><th style="text-align: center;">D</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头</td><td style="text-align: center;"></td><td style="text-align: center;">队尾</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>PQ 弹出 C，置 <span class="math inline">\(visit\)</span> 为 1：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[C] = 0.4 &lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,C) = \infty\)</span> ，故 Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrow L_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 25%" /><col style="width: 7%" /><col style="width: 26%" /><col style="width: 7%" /><col style="width: 26%" /><col style="width: 7%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>C 未访问的邻居为 F，但由于 <span class="math inline">\(d[u]+\text{wt}((u,w)) = d[C] + \text{wt}((C,F)) = 0.4 + 2 = 2.4 &lt; d[F] = \infty\)</span>，所以，更新 <span class="math inline">\(d[F]\)</span> ：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(d[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0.6</td><td style="text-align: center;">0.4</td><td style="text-align: center;">1</td><td style="text-align: center;">0.3</td><td style="text-align: center;"><strong>2.4</strong></td></tr></tbody></table><p>此时，属于 <span class="math inline">\(L_1(F)\)</span> 的 <span class="math inline">\(A(\textrm{dist} = 2.4, \textrm{pred}= C)\)</span></p><p>又由于 F 不在 PQ 中，所以加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;">B</th><th style="text-align: center;">D</th><th style="text-align: center;">F</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头</td><td style="text-align: center;"></td><td style="text-align: center;">队尾</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>PQ 弹出 B，置 <span class="math inline">\(visit\)</span> 为 1：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[B] = 0.6 &lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,B) = \infty\)</span> ，故 Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrow L_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table style="width:100%;"><colgroup><col style="width: 21%" /><col style="width: 23%" /><col style="width: 22%" /><col style="width: 5%" /><col style="width: 22%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math display">\[A(\textrm{dist} = 0.6, \textrm{pred}= A)\]</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>B 未访问的邻居为 F，但由于 <span class="math inline">\(d[u]+\text{wt}((u,w)) = d[B] + \text{wt}((B,F)) = 0.6 + 0.1 = 0.7 &lt; d[F] = 2.4\)</span>，所以，更新 <span class="math inline">\(d[F]\)</span> ：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(d[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0.6</td><td style="text-align: center;">0.4</td><td style="text-align: center;">1</td><td style="text-align: center;">0.3</td><td style="text-align: center;"><strong>0.7</strong></td></tr></tbody></table><p>此时，属于 <span class="math inline">\(L_1(F)\)</span> 的 <span class="math inline">\(A(\textrm{dist} = 0.7, \textrm{pred}= B)\)</span></p><p>又由于 F 在 PQ 中，所以不加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;">D</th><th style="text-align: center;">F</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头</td><td style="text-align: center;">队尾</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>PQ 弹出 D，置 <span class="math inline">\(visit\)</span> 为 1：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[D] = 1 &lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,D) = \infty\)</span> ，故 Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrow L_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 18%" /><col style="width: 20%" /><col style="width: 19%" /><col style="width: 18%" /><col style="width: 19%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math display">\[A(\textrm{dist} = 0.6, \textrm{pred}= A)\]</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 1, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>D 没有未访问的邻居，故不更新 <span class="math inline">\(d[F]\)</span> ，也就没有顶点加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;">F</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头（队尾）</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>PQ 弹出 F，置 <span class="math inline">\(visit\)</span> 为 1：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"><strong>1</strong></td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[F] = 0.7 &lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,F) = \infty\)</span> ，故 Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrow L_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 16%" /><col style="width: 17%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math display">\[A(\textrm{dist} = 0.6, \textrm{pred}= A)\]</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 1, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.7, \textrm{pred}= B)\)</span></td></tr></tbody></table><p>F 没有未访问的邻居，故不更新 <span class="math inline">\(d[F]\)</span> ，也就没有顶点加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td></tr></tbody></table><hr /><p>至此，第一次 for 迭代结束，索引结果为</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.6, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 1, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.7, \textrm{pred}= B)\)</span></td></tr></tbody></table><p>类似的处理，可得下图右下角的索引。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><h4 id="extension-of-index-structure">Extension of Index Structure</h4><p>为了支持计算 <code>getSP</code> ，我们需要扩展 <code>L</code> 的索引结构。在<strong>算法 2</strong> 中，对于每一个 hub <span class="math inline">\(v_i\in L(w)\)</span> ，我们不仅仅存储了 <span class="math inline">\(\textrm{dist}(w,v_i)\)</span> ，还存储了以 <span class="math inline">\(v_i\)</span> 为根节点搜索树中 <span class="math inline">\(w\)</span> 的前驱顶点，并将其记作 <span class="math inline">\(\textrm{pred}(w,v_i)\)</span> （Line 16）。</p><p>有了扩展后的索引结构，<code>getSP</code> 就可以通过<strong>算法 3</strong> 计算得到。为了得到顶点 <span class="math inline">\(u,\;v\)</span> 之间的一条最短路径 <span class="math inline">\(p\)</span> ，我们首先在 <span class="math inline">\(p\)</span> 上找到它们所共有的 hub <span class="math inline">\(h_{\textrm{min}}\)</span> （Line 1），然后重复地跟随前驱顶点，构造路径 <span class="math inline">\(p\)</span> 的从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(h_{\textrm{min}}\)</span> 的一段（Line 2-8），以及 <span class="math inline">\(v\)</span> 到 <span class="math inline">\(h_{\textrm{min}}\)</span> 的一段（Line 9-14）。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/Algo3.PNG" alt="Algorithm 3" /><figcaption>Algorithm 3</figcaption></figure><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><p>举个例子，比如计算 <code>getSP(D, F)</code> 。</p><p>首先，<code>L(D)</code> 和 <code>L(F)</code> 的公共 hub 只有一个，就是 <span class="math inline">\(A\)</span>，则 <span class="math inline">\(h_{\textrm{min}} = A\)</span> 。</p><p>然后，通过 <code>pred</code> 信息找到 D-A 的路径，为 D-A ，因为 <code>L(D)</code> 中 <span class="math inline">\(A\)</span> 的 <code>pred</code> 为 <span class="math inline">\(A\)</span>。</p><p>接着，同样的，找到 F-A 的路径，为 F-B-A，因为 <code>L(F)</code> 中的 A 的 <code>pred</code> 为 <span class="math inline">\(B\)</span>，L(B) 中的 <span class="math inline">\(A\)</span> 的 <code>pred</code> 为 <span class="math inline">\(A\)</span>。</p><p>最后，将上面两个子路径连起来，我们就找到了路径 <span class="math inline">\(p\)</span>，为 D-A-B-F。</p><h2 id="keykg-with-dynamic-hl">KeyKG+ With Dynamic HL</h2><h3 id="dynamic-hl">Dynamic HL</h3><h4 id="features">Features</h4><ul><li><strong>查询相关的</strong>（<em>query-relevant</em>）</li><li><strong>在线构造的</strong>（<em>online constructed</em>）</li></ul><h4 id="definition-and-structure">Definition and structure</h4><p>一个动态 HL 是一个 <span class="math inline">\((g-1)\times n\)</span> 的矩阵，记作 <span class="math inline">\(M\)</span> 。行对应于关键词顶点集 <span class="math inline">\(K_2,K_3,\dots,K_g\)</span> ，列对应于 hub 顶点。<span class="math inline">\(M\)</span> 的第 <span class="math inline">\((i-1)\)</span> 行（记作 <span class="math inline">\(M_{i-1}\)</span>）倒排并且聚集了 <span class="math inline">\(K_i\)</span> 中顶点的静态索引标签。<span class="math inline">\(M_{i-1}\)</span> 的第 j 个元素（记作 <span class="math inline">\(M_{i-1,j}\)</span>）是非空的，如果 <span class="math inline">\(h_j\in V\)</span> 是一个 hub，并且它在 <span class="math inline">\(K_i\)</span> 的至少一个顶点的静态索引标签中。在 <span class="math inline">\(K_i\)</span> 中的这些顶点中（这些顶点的静态索引标签包括 <span class="math inline">\(h_j\)</span>），<span class="math inline">\(M_{i-1, j}\)</span> 代表了最小化到达 <span class="math inline">\(h_j\)</span> 的距离的顶点。如果， <span class="math inline">\(h_j\)</span> 不是一个在 <span class="math inline">\(K_i\)</span> 中任意一个顶点的索引标签中的 hub，那么我们令 <span class="math inline">\(M_{i-1, j}\)</span> 为 null： <span class="math display">\[M_{i-1,j}=\begin{cases}&amp;\underset{u\in K_i\; s.t.\; h_j\in L(u)}{\textrm{argmin}}\textrm{dist}(u, h_j)&amp;h_j\in \bigcup_{u\in K_i}L(u),\\&amp;null&amp;h_j\not\in \bigcup_{u\in K_i}L(u),\end{cases}\]</span> 具体的，论文中使用<strong>二维数组</strong>存储矩阵 <span class="math inline">\(M\)</span> ，因此可以支持常数时间的随机访问。对于每一个不为 null 的 <span class="math inline">\(M_{i-1, j}\)</span> ，与 <span class="math inline">\(h_j\)</span> 的距离也是先计算出来，并保存到 <span class="math inline">\(M\)</span> 中。</p><h4 id="example">Example</h4><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><ul><li><span class="math inline">\(i = 2\)</span> 时，<span class="math inline">\(K_2=\{E\}\)</span> ，<span class="math inline">\(L(E) = \{A,B,E\}\)</span> ，因此矩阵 <span class="math inline">\(M\)</span> <span class="math inline">\(K_2\)</span> 行只有 <span class="math inline">\(A,B,E\)</span> 不为 null，其他都为 null；由于 <span class="math inline">\(K_2\)</span> 中只有一个元素 <span class="math inline">\(E\)</span> ，故 <span class="math inline">\(K_2\)</span> 行 <span class="math inline">\(A,B,E\)</span> 列中的元素都为 <span class="math inline">\(E\)</span> 和到它的距离（从 <span class="math inline">\(L(E)\)</span> 中直接取得）。</li><li><span class="math inline">\(i = 3\)</span> 时，<span class="math inline">\(K_3=\{C,D\}\)</span> ，<span class="math inline">\(L(C)\cup L(D) = \{A,C,D\}\)</span> ，因此矩阵 <span class="math inline">\(M\)</span> <span class="math inline">\(K_3\)</span> 行只有 <span class="math inline">\(A,C,D\)</span> 不为 null，其他都为 null；由于 <span class="math inline">\(K_3\)</span> 中有两个元素，故 <span class="math inline">\(K_3\)</span> 行 <span class="math inline">\(A,C,D\)</span> 列中的元素需要对比一下分别到 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span> 的距离，选择较小的存入矩阵 <span class="math inline">\(M\)</span> （比如 <span class="math inline">\(M_{K_3, A}\)</span> ，由于 <span class="math inline">\(\textrm{dist}(C,A) &lt; \textrm{dist}(D,A)\)</span>，所以将 <span class="math inline">\(C\)</span> 存入矩阵）。</li></ul><p>综上所示，矩阵 <span class="math inline">\(M\)</span> 如下图所示：</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/11/matrix-M.PNG" alt="Dynamic HL Example" /><figcaption>Dynamic HL Example</figcaption></figure><h3 id="algorithm-keykg-1">Algorithm KeyKG+</h3><h4 id="algorithm-explained-1">Algorithm Explained</h4><p>KeyKG+ 如<strong>算法 4</strong> 所示。这个算法主要构造了动态 HL，并将其使用在两个方面，提高执行的总体性能，并且对最终结果没有任何影响。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/11/Algo4.PNG" alt="Algorithm 4" /><figcaption>Algorithm 4</figcaption></figure><p>在第一部分，首先，为 <span class="math inline">\(K_2,\dots,K_g\)</span> 构造矩阵 <span class="math inline">\(M\)</span> （Line 1-3）。然后，按照如下流程利用 <span class="math inline">\(M_{i-1}\)</span> 找到 <span class="math inline">\(v_i\)</span> （Line 6）。对于每一个 hub <span class="math inline">\(h_j\in L(v_1)\)</span> ，我们从 <span class="math inline">\(L(v_1)\)</span> 中取得 <span class="math inline">\(\textrm{dist}(v_1,h_j)\)</span> ，并且从 <span class="math inline">\(M_{i-1}\)</span> 中取 <span class="math inline">\(M_{i-1, j}\)</span> 元素的 <span class="math inline">\(\textrm{dist}(M_{i-1,j},h_j)\)</span> 。如果 <span class="math inline">\(M_{i-1,j}\)</span> 非空，那么我们计算： <span class="math display">\[\textrm{dist}(v_1,h_j)+\textrm{dist}(M_{i-1,j},h_j)\]</span> 这个结果表示了 <span class="math inline">\(v_1\)</span> 到在 <span class="math inline">\(K_i\)</span> 中经过一个特定的 <span class="math inline">\(h_j\)</span> 所能到达的顶点之间的最短距离。最后， 通过如下方式，找到 <span class="math inline">\(v_i\)</span> ： <span class="math display">\[v_i=\underset{M_{i-1, j}\; s.t.\; h_j\in L(v_1)\; \textrm{and}\; M_{i-1, j}\ne \textrm{null}}{\textrm{argmin}} \textrm{dist}(v_1,h_j)+\textrm{dist}(M_{i-1,j},h_j)\]</span> KeyKG+ Line 6 计算得到的 <span class="math inline">\(v_i\)</span> 和 KeyKG Line 3 得到的 <span class="math inline">\(v_i\)</span> 等价，但是 KeyKG+ 的效率更高。</p><p>第二部分，我们像为 <span class="math inline">\(K_i\)</span> 创建 <span class="math inline">\(M_{i-1}\)</span> 一样，为 <span class="math inline">\(V_{T_u}\)</span> （Line 14）创建 <span class="math inline">\(M&#39;_{u}\)</span> 。随着 <span class="math inline">\(T_u\)</span> 在每次迭代中逐渐扩展（Line 21），<span class="math inline">\(M&#39;_{u}\)</span> 通过加入到 <span class="math inline">\(T_u\)</span> 的顶点的静态索引标签得到更新（Line 22）。对于每一个 <span class="math inline">\(t_i\in(U_x\backslash V_{T_u})\)</span> ，<span class="math inline">\(M&#39;_u\)</span> 被用来找到与 <span class="math inline">\(t_i\)</span> 距离最短的顶点 <span class="math inline">\(s_i\in V_{T_u}\)</span> （Line 16-18）。我们在所有的这样的 <span class="math inline">\(&lt;s_i,t_i&gt;\)</span> 中找到最小的 <span class="math inline">\(&lt;s_{\textrm{min}},t_{\textrm{min}}&gt;\)</span> （Line 19）</p><p>KeyKG+ Line 16-19 计算得到的 <span class="math inline">\(&lt;s_{\textrm{min}},t_{\textrm{min}}&gt;\)</span> 和 KeyKG Line 12 得到的 <span class="math inline">\(&lt;s_{\textrm{min}},t_{\textrm{min}}&gt;\)</span> 等价，但是 KeyKG+ 的效率更高。</p><h4 id="running-example-1">Running Example</h4><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><p>如上图，</p><ul><li>令 <span class="math inline">\(B\in K_1\)</span> 为 <span class="math inline">\(v_1\)</span> ，查询其 Static HL，得到 <span class="math inline">\(L(B) = \{A,B\}\)</span> ；<ul><li>因为 <span class="math inline">\(M_{1,A} = M_{1,B} = E\)</span> ，所以令 <span class="math inline">\(E\in K_2\)</span> 为 <span class="math inline">\(v_2\)</span> ；</li><li>因为 <span class="math inline">\(M_{2,A} = C, M_{2,B} = \textrm{null}\)</span> ，所以令 <span class="math inline">\(C\in K_3\)</span> 为 <span class="math inline">\(v_3\)</span> ；</li><li>这样就形成了 <span class="math inline">\(U_B=\{B,E,C\}\)</span> （这与算法 KeyKG 得到的结果是一致的）</li></ul></li><li>令 <span class="math inline">\(F\in K_1\)</span> 为 <span class="math inline">\(v_1\)</span> ，查询其 Static HL，得到 <span class="math inline">\(L(F) = \{A,B,F\}\)</span> ；<ul><li>因为 <span class="math inline">\(M_{1,A} = M_{1,B} = E, M_{1,F} = \textrm{null}\)</span> ，所以令 <span class="math inline">\(E\in K_2\)</span> 为 <span class="math inline">\(v_2\)</span> ；</li><li>因为 <span class="math inline">\(M_{2,A} = C, M_{2,B} = M_{2,F} = \textrm{null}\)</span> ，所以令 <span class="math inline">\(C\in K_3\)</span> 为 <span class="math inline">\(v_3\)</span> ；</li><li>这样就形成了 <span class="math inline">\(U_F=\{F,E,C\}\)</span> （这与算法 KeyKG 得到的结果是一致的）</li></ul></li></ul><div class="note default"><p><strong>TODO</strong>：另一半的例子怎么解释？？？</p></div><h1 id="how-much">How much？</h1><ul><li>基于 <em>betweenness centrality</em> 的启发式方法构建的 <em>Static Hub Labelings</em> 超越了现存的方案。</li><li><em>Dynamic Hub Labelings</em> 则通过倒排并聚集查询相关的静态标签，加速了总体的查询效率。</li></ul><h1 id="what-then">What Then？</h1><ul><li>寻找支持更高效地边删除（<em>edge deletion</em>）的解决方案</li><li>KeyKG+ 的近似比率可以进一步得到提高</li><li>现存 HL 方案无法处理巨大而稠密的图。</li></ul><h1 id="problems-to-solve">Problems to Solve</h1><ul><li><input type="checkbox" disabled="" />Hub Labeling<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></li><li><input type="checkbox" disabled="" />pruned landmark labeling <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></li><li><input type="checkbox" disabled="" />PLL<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></li><li><input type="checkbox" disabled="" />between centrality？？？【10】 <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> vs 【4】<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></li></ul><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>Ittai Abraham, Daniel Delling, Andrew V. Goldberg, and Renato Fonseca F. Werneck. 2011. A Hub-Based Labeling Algorithm for Shortest Paths in Road Networks. In SEA. 230–241.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩</a></p></li><li id="fn2" role="doc-endnote"><p>Takuya Akiba, Yoichi Iwata, and Yuichi Yoshida. 2013. Fast exact shortest-path distance queries on large networks by pruned landmark labeling. In SIGMOD. 349–360<a href="#fnref2" class="footnote-back" role="doc-backlink">↩</a></p></li><li id="fn3" role="doc-endnote"><p>Takuya Akiba, Yoichi Iwata, and Yuichi Yoshida. 2013. Fast exact shortest-path distance queries on large networks by pruned landmark labeling. In SIGMOD. 349–360<a href="#fnref3" class="footnote-back" role="doc-backlink">↩</a></p></li><li id="fn4" role="doc-endnote"><p>Ulrik Brandes. 2001. A faster algorithm for betweenness centrality. J. Math. Soc. 25, 2 (2001), 163–177.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩</a></p></li><li id="fn5" role="doc-endnote"><p>Ziyad AlGhamdi, Fuad Jamour, Spiros Skiadopoulos, and Panos Kalnis. 2017. A Benchmark for Betweenness Centrality Approximation Algorithms on Large Graphs. In SSDBM<a href="#fnref5" class="footnote-back" role="doc-backlink">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      这篇文章提出了一个实用的近似算法，能够在较短的时间内获得较好的结果。该算法基于 Hub Labeling（HL），一个用来计算距离和最短路径的数据结构，这个数据结构为图中的每一个点标明了能从这个点到达的点的集合。具体的，设计了两类 HL：一个是传统静态的 HL，它采用了一种全新的启发式方法来提高 pruned landmark labeling 的效率；另一个是新颖动态的 HL，它倒排并聚集查询相关的静态标签，使得在处理顶点集时更加高效。
    
    </summary>
    
    
      <category term="研究" scheme="https://cosmosning.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Knowledge graph" scheme="https://cosmosning.github.io/tags/Knowledge-graph/"/>
    
      <category term="Keyword search" scheme="https://cosmosning.github.io/tags/Keyword-search/"/>
    
      <category term="Group Steiner tree" scheme="https://cosmosning.github.io/tags/Group-Steiner-tree/"/>
    
      <category term="Hub labeling" scheme="https://cosmosning.github.io/tags/Hub-labeling/"/>
    
  </entry>
  
  <entry>
    <title>PAC 模型及其变体</title>
    <link href="https://cosmosning.github.io/2020/09/19/pac-learning-and-its-variants/"/>
    <id>https://cosmosning.github.io/2020/09/19/pac-learning-and-its-variants/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-09-19T01:30:55.000Z</published>
    <updated>2020-11-12T01:07:59.780Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文将介绍通用的学习模型 PAC 及其变体形式。</p><ul><li><p>最原始的 PAC 主要需要满足<strong>可实现假设</strong>，<strong>训练样本量要大于样本复杂度函数</strong>。</p></li><li><p>现实情况中，<strong>可实现假设难以满足</strong>（先验知识不一定猜得准），因此<strong>将目标标记函数改为数据-标签分布，并从中采样训练样本</strong>，就可以类似的得到 Agnostic PAC 。</p></li><li><p>原始的 PAC 中，标记函数将学习问题限制在二元分类任务中。为了获得更加通用的学习模型，我们定义更加一般的损失函数。通过损失函数，可计算真实误差和经验风险：</p></li></ul><blockquote><ul><li><p>在<strong>问题分布</strong>（<span class="math inline">\(\mathcal{D}\)</span>）上采样得到的误差函数的<strong>期望</strong>，作为<strong>真实误差</strong>；</p></li><li><p>在<strong>训练样本</strong>（<span class="math inline">\(S\)</span>）上采样得到的误差函数的<strong>平均值</strong>，作为<strong>经验风险</strong>；</p></li></ul></blockquote></blockquote><h1 id="pac-learning">PAC Learning</h1><p>在<a href="/2020/09/16/statistical-learning-framework-and-empirical-risk-minimization/">上一篇文章</a>中，我们证明了对于一个有限的假设集，<mark>如果拥有足量的训练样本（这些训练样本是从同一分布中独立采样，并被同一标记函数标记而生成的），ERM 会输出近似正确的假设</mark>。更一般的，我们定义 <em>Probably Approximately Correct Learning</em> （PAC）如下：</p><div class="note primary"><p><strong>Def. PAC Learnability</strong></p><p>如果</p><ul><li>存在一个函数 <span class="math inline">\(m_{\mathcal{H}}:(0,1)^2\rightarrow \mathbb{N}\)</span> ，</li><li>并且存在一个学习算法满足以下条件：<ul><li>对于任意的 <span class="math inline">\(\epsilon, \delta\in(0,1)\)</span> ，任意的 <span class="math inline">\(\mathcal{X}\)</span> 上的分布 <span class="math inline">\(\mathcal{D}\)</span> ，任意的标记函数 <span class="math inline">\(f: \mathcal{X}\rightarrow \lbrace 0,1\rbrace\)</span> ，如果对于 <span class="math inline">\(\mathcal{H,D},f\)</span> 可实现假设（<em>realizability assumption</em> ，即 <span class="math inline">\(\exists\ h^\star\in \mathcal{H}, L_{D,f}(h^\star) = 0\)</span>）成立，那么当学习算法的训练样本量 <span class="math inline">\(m \ge m_{\mathcal{H}}(\epsilon, \delta)\)</span> 时（这些训练样本是由从 <span class="math inline">\(\mathcal{D}\)</span> 中独立采样，并被 <span class="math inline">\(f\)</span> 标记而生成的），学习算法会以至少 <span class="math inline">\(1 - \delta\)</span> 的概率返回一个假设 <span class="math inline">\(h\)</span>，并且该假设满足 <span class="math inline">\(L_{(\mathcal{D},f)}(h) \le \epsilon\)</span></li></ul></li></ul><p>则一个假设类 <span class="math inline">\(\mathcal{H}\)</span> 是 PAC 可学习的</p></div><div class="note info"><p><strong>有关 PAC Learnability 的补充说明</strong></p><ul><li><span class="math inline">\(\epsilon\)</span> 称作<strong>精度参数</strong>（<em>accuracy parameter</em>），代表输出分类器与最优之间的误差大小（对应 PAC 中的 <strong><em>approximately correct</em></strong>）。这意味着，<span class="math inline">\(\epsilon\)</span> 允许学习算法犯一些小错误。</li><li><span class="math inline">\(\delta\)</span> 称作<strong>置信参数</strong>（<em>confidence parameter</em>），代表输出分类器满足上述精度要求的可能性（对应 PAC 中的 <strong><em>probably</em></strong>）</li><li><span class="math inline">\(m_{\mathcal{H}}:(0, 1) \rightarrow \mathbb{N}\)</span> 称作<strong>样本复杂度</strong>（<em>sample complexity</em>）函数，表示<strong>需要多少训练样本数据，才能够保证获得一个尽可能近似正确的答案</strong>。该函数依赖于 <span class="math inline">\(\epsilon, \delta,\mathcal{H}\)</span> 。依据 PAC Learnability 的定义，存在不止一个 <span class="math inline">\(m_{\mathcal{H}}\)</span> 满足条件。通常，我们定义 <span class="math inline">\(m_{\mathcal{H}}\)</span> 为满足条件的<strong>最小整数</strong>。</li></ul></div><p>对上一篇文章中获得的结论，我们换一种表达，则有下面的推论</p><div class="note default"><p><strong>PAC 可学习的样本复杂度条件</strong></p><p>每一个有限假设类都是 PAC 可学习的，只要它的样本复杂度满足： <span class="math display">\[m_{\mathcal{H}} \le \lceil \frac{log(\frac{\mathcal{H}}{\delta})}{\epsilon} \rceil\]</span></p></div><h1 id="a-more-general-learning-model">A More General Learning Model</h1><p>对于大多数任务，可实现假设很难得到满足，而且上述定义只适用于二元分类问题，因此通用性不佳。为了得到更加通用的学习模型，我们对上述模型从以下两个方面进行拓展：</p><ol type="1"><li>去除可实现假设。引入 <strong>Agnostic PAC</strong> 解决这个问题。</li><li>学习比二元分类问题更加广泛的任务。通过对<strong>损失函数的一般化</strong>来支持这种拓展。</li></ol><h2 id="releasing-the-realizablity-assumption-agnostic-pac-learning">Releasing the Realizablity Assumption —— Agnostic PAC Learning</h2><h3 id="a-more-realistic-model-for-the-data-generating-distribution">A More Realistic Model for the Data-Generating Distribution</h3><p>简单来说，我们可以将 “目标标记函数” 替换为<strong>数据-标签</strong>生成分布。</p><p>规范地，设 <span class="math inline">\(\mathcal{D}\)</span> 为 <span class="math inline">\(\mathcal{X} \times \mathcal{Y}\)</span> 上的概率分布，其中 <span class="math inline">\(\mathcal{X}\)</span> 为领域集，<span class="math inline">\(\mathcal{Y}\)</span> 为标签集。也就是说，<span class="math inline">\(\mathcal{D}\)</span> 为在领域点和标签上的联合分布。我们可以将 <span class="math inline">\(\mathcal{D}\)</span> 看作由两个部分组成：一个在未被标记的领域点上的分布 <span class="math inline">\(\mathcal{D}_x\)</span> （有时候，也称作<strong>边缘分布</strong>） ，另一个为每一个领域点的标签上的<strong>条件概率</strong> <span class="math inline">\(\mathcal{D}((x,y)|x)\)</span> 。</p><div class="note info"><p><strong>如何理解条件概率？</strong></p><ul><li>很多事情无法精确刻画，因此可用一个条件分布来描述。随着某一变量的变化，对应事件的概率也会发生变化。例如，<span class="math inline">\(\mathcal{D}(y|x)\)</span> 事件 <span class="math inline">\(y\)</span> 的概率会随着 <span class="math inline">\(x\)</span> 的变化而变化；此外，在 <span class="math inline">\(\mathcal{D}(y|x)\)</span> 中，<span class="math inline">\(\mathcal{D}(y|x)\)</span> 是关于 <span class="math inline">\(y\)</span> 的函数，而 <span class="math inline">\(x\)</span> 是作为函数的参数（如果要确定关于 <span class="math inline">\(y\)</span> 的函数关系，<span class="math inline">\(x\)</span> 要事先指定）。</li></ul></div><h3 id="the-empirical-and-true-error-revised">The Empirical and True Error Revised</h3><p>与分布的改变相对应，我们定义预测规则 <span class="math inline">\(h\)</span> <strong>真实误差</strong>（或者叫做<strong>风险</strong>）如下： <span class="math display">\[L_{\mathcal{D}}\overset{def}{=}\underset{(x,y)\sim \mathcal{D}}{\mathbb{P}}[h(x)\ne y] \overset{def}{=}\mathcal{D}(\lbrace (x,y): h(x) \ne y \rbrace) \tag{3.1}\]</span> 而经验风险并没有改变，依然是： <span class="math display">\[L_{S}(h)\overset{def}{=}\frac{|\lbrace i\in[m] : h(x_i) \ne y_i \rbrace|}{m}\]</span></p><h3 id="the-goal">The Goal</h3><p>学习算法的目标是寻找一些假设，<span class="math inline">\(h:\mathcal{X}\rightarrow \mathcal{Y}\)</span> ，尽可能近似最小化真实风险，<span class="math inline">\(L_{\mathcal{D}}(h)\)</span></p><h3 id="the-bayes-optimal-predictor">The Bayes Optimal Predictor</h3><p>给定任意的在 <span class="math inline">\(\mathcal{X} \times \lbrace 0,1\rbrace\)</span> 上的概率分布，从 <span class="math inline">\(\mathcal{X}\)</span> 到 <span class="math inline">\(\lbrace 0, 1 \rbrace\)</span> 的最佳标记函数为 <span class="math display">\[f_{\mathcal{D}}(x) = \begin{cases} 1 &amp;if\ \mathbb{P}[y=1|x]\ge \frac{1}{2}\\ 0 &amp; otherwise\end{cases}\]</span> 这也就是说，对于任意的二元分类器 <span class="math inline">\(g: \mathcal{X}\rightarrow \lbrace 0, 1\rbrace\)</span>，<span class="math inline">\(L_{\mathcal{D}}(f_{\mathcal{D}}) \le L_{\mathcal{D}}(g)\)</span></p><div class="note info"><p><strong>证明 The Bayes Optimal Predictor</strong>（TODO）</p></div><p>一旦我们对数据生成分布不做任何预先假设，那么将没有算法将保证找到一个预测器，媲美 Bayes Optimal Predictor 的效果。因此，我们需要学习算法找到一个预测器，在给定某些假设类的基准测试时，<strong>它的误差并不会比可能的最佳的预测器的误差大太多</strong>。因此，我们有如下的 <strong>Agnostic PAC Learnability</strong>：</p><div class="note primary"><p><strong>Def. Agnostic PAC Learnability</strong></p><p>如果</p><ul><li><p>存在一个函数 <span class="math inline">\(m_{\mathcal{H}}:(0,1)^2\rightarrow \mathbb{N}\)</span> ，</p></li><li><p>并且存在一个学习算法满足以下条件：</p><ul><li>对于任意的 <span class="math inline">\(\epsilon, \delta\in(0,1)\)</span> ，任意的 <span class="math inline">\(\mathcal{X} \times\mathcal{Y}\)</span> 上的分布 <span class="math inline">\(\mathcal{D}\)</span> ，当学习算法的训练样本量 <span class="math inline">\(m \ge m_{\mathcal{H}}(\epsilon, \delta)\)</span> 时（这些训练样本是由从 <span class="math inline">\(\mathcal{D}\)</span> 中独立采样而生成的），学习算法会以至少 <span class="math inline">\(1 - \delta\)</span> 的概率返回一个假设 <span class="math inline">\(h\)</span>，并且该假设满足： <span class="math display">\[L_{\mathcal{D}}(h) \le \underset{h&#39;\in\mathcal{H}}{min}L_D(h&#39;) + \epsilon\]</span></li></ul></li></ul><p>则一个假设类 <span class="math inline">\(\mathcal{H}\)</span> 是 Agnostic PAC 可学习的</p></div><h2 id="generalized-loss-function-agnostic-pac-learning-for-general-loss-function">Generalized Loss Function —— Agnostic PAC Learning for General Loss Function</h2><p>为了适应不同的任务，我们接下来定义通用的损失函数。</p><p>给定任意的集合 <span class="math inline">\(\mathcal{H}\)</span> 和领域集 <span class="math inline">\(Z\)</span> ，设 <span class="math inline">\(l\)</span> 为任意 <span class="math inline">\(\mathcal{H}\times Z\)</span> 到非负实数的函数， <span class="math inline">\(l: \mathcal{H} \times Z \rightarrow \mathbb{R}_+\)</span> ，我们称 <span class="math inline">\(l\)</span> 为<strong>损失函数</strong>。</p><p>下面用分类器误差的期望来定义<strong>风险函数</strong>。</p><p>给定一个 <span class="math inline">\(h\in \mathcal{H}\)</span> ，关于在 <span class="math inline">\(Z\)</span> 上的概率分布 <span class="math inline">\(\mathcal{D}\)</span> ，对应的风险函数为： <span class="math display">\[L_{\mathcal{D}}(h)\overset{def}{=}\underset{z\sim \mathcal{D}}{\mathbb{E}}[l(h,z)]\tag{3.3}\]</span> 相似的，经验风险函数为对采样样本 <span class="math inline">\(S=(z_1,\dots,z_m)\in Z^m\)</span> 上的损失的期望： <span class="math display">\[L_S(h)\overset{def}{=}\frac{1}{m}\sum_{i=1}^{m}l(h,z_i)\tag{3.4}\]</span> 综上所述，有如下更加通用的 Agnostic PAC 的定义：</p><div class="note primary"><p><strong>Def. Agnostic PAC Learning for General Loss Function</strong></p><p>如果</p><ul><li><p>存在一个函数 <span class="math inline">\(m_{\mathcal{H}}:(0,1)^2\rightarrow \mathbb{N}\)</span> ，</p></li><li><p>并且存在一个学习算法满足以下条件：</p><ul><li>对于任意的 <span class="math inline">\(\epsilon, \delta\in(0,1)\)</span> ，任意的 <span class="math inline">\(Z\)</span> 上的分布 <span class="math inline">\(\mathcal{D}\)</span> ，当学习算法的训练样本量 <span class="math inline">\(m \ge m_{\mathcal{H}}(\epsilon, \delta)\)</span> 时（这些训练样本是由从 <span class="math inline">\(\mathcal{D}\)</span> 中独立采样而生成的），学习算法会以至少 <span class="math inline">\(1 - \delta\)</span> 的概率返回一个假设 <span class="math inline">\(h\in \mathcal{H}\)</span>，并且该假设满足 <span class="math display">\[L_{\mathcal{D}}(h) \le \underset{h&#39;\in\mathcal{H}}{min}L_{\mathcal{D}}(h&#39;)+ \epsilon\]</span> 其中 <span class="math inline">\(L_{\mathcal{D}}(h) = \mathbb{E}_{z\sim D}[l(h, z)]\)</span></li></ul></li></ul><p>则一个假设类 <span class="math inline">\(\mathcal{H}\)</span> 关于一个集合 <span class="math inline">\(Z\)</span> 和 损失函数 <span class="math inline">\(l:\mathcal{H}\times Z\rightarrow \mathbb{R}_+\)</span> 是 Agnostic PAC 可学习的</p></div><h1 id="reference">Reference</h1><p>Shai Shalev-Shwartz, Shai Ben-David. <a href="https://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/index.html" target="_blank" rel="noopener">Understanding Machine Learning: From Theory to Algorithms</a></p>]]></content>
    
    <summary type="html">
    
      本文主要介绍机器学习中一种较通用的 PAC 学习模型及其拓展形式。
    
    </summary>
    
    
      <category term="从理论到算法理解机器学习" scheme="https://cosmosning.github.io/categories/%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="PAC" scheme="https://cosmosning.github.io/tags/PAC/"/>
    
      <category term="Agnostic PAC" scheme="https://cosmosning.github.io/tags/Agnostic-PAC/"/>
    
      <category term="Generalized loss function" scheme="https://cosmosning.github.io/tags/Generalized-loss-function/"/>
    
  </entry>
  
  <entry>
    <title>统计学习框架及经验风险最小化</title>
    <link href="https://cosmosning.github.io/2020/09/16/statistical-learning-framework-and-empirical-risk-minimization/"/>
    <id>https://cosmosning.github.io/2020/09/16/statistical-learning-framework-and-empirical-risk-minimization/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-09-16T01:02:33.000Z</published>
    <updated>2020-11-12T01:07:59.780Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍两个内容：</p><ol type="1"><li><strong>统计学习框架</strong>。这是一个十分通用的框架，指明了学习的<strong>输入</strong>、<strong>输出</strong>和<strong>学习目标</strong>。</li><li><strong>经验风险最小化</strong>（<strong>ERM</strong>）的学习方法。引入<strong>经验风险</strong>，从而可以<strong>从训练数据中管中窥豹</strong>，归纳出一般规律。但是 ERM <strong>会产生过拟合</strong>现象。一种常见的解决方案是<strong>引入归纳偏好</strong>（或者是先验知识）。具体来说，确定一个有<strong>限的假设类</strong>集合，供学习算法学习。这样是否是有效的？通过证明发现，<strong>只要有足够的训练样本，就可以达到比较好的效果</strong>。</li></ol></blockquote><h1 id="a-formal-model-the-statistical-learning-framework">A Formal Model —— The Statistical Learning Framework</h1><h2 id="the-learners-input">The Learner's Input</h2><ul><li><strong>领域集（<em>Domain set</em>）</strong>：这是我们<strong>希望标记的事物的集合</strong>，记作 <span class="math inline">\(\mathcal{X}\)</span> 。通常情况下，人们会用一个特性向量（vector of <em>features</em>）表示这些领域点（<em>domain points</em>）。</li></ul><div class="note info"><ul><li>领域集（<em>domain set</em>）又称作实例空间（<em>instance space</em>）</li><li>领域点（<em>domain points</em>）又称作实例（<em>instances</em>）</li></ul></div><ul><li><strong>标签集（<em>Label set</em>）</strong>：这是<strong>可能的标签的集合</strong>，记作 <span class="math inline">\(\mathcal{Y}\)</span> 。</li><li><strong>训练数据（<em>Training data</em>）</strong>：这是一系列已经被标记的领域点，常常表示为 <span class="math inline">\(S=((x_1,\ y_1)\dots(x_m,\ y_m))\)</span> （这是在 <span class="math inline">\(\mathcal{X}\times \mathcal{Y}\)</span> 中的<strong>有限</strong>的数对序列）</li></ul><div class="note info"><ul><li>训练数据（<em>training data</em>）又称作 <strong><em>training examples</em></strong>，或者 <strong><em>training set</em></strong></li></ul></div><h2 id="the-learners-output">The Learner's Output</h2><p>人们希望学习器输出一个<strong>预测规则</strong>（<em>prediction rule</em>）：<span class="math inline">\(h:\mathcal{X} \rightarrow \mathcal{Y}\)</span> 。这个函数又称作为<strong>预测器</strong>（<em>predictor</em>）、<strong>假设</strong>（<em>hypothesis</em>）或者是<strong>分类器</strong>（<em>classifier</em>）。此外，我们记一个学习算法 <span class="math inline">\(A\)</span> ，接受训练数据 <span class="math inline">\(S\)</span> 为输入，返回对应假设为 <span class="math inline">\(A(S)\)</span> 。</p><h2 id="a-simple-data-generation-model">A Simple Data-generation Model</h2><p>训练数据是如何生成的？这里给出两个假设。</p><ul><li>假设所有的实例都由一个概率分布生成，记这个在 <span class="math inline">\(\mathcal{X}\)</span> 上的概率分布为 <span class="math inline">\(\mathcal{D}\)</span> 。</li><li>假设存在一个“完全正确”的标记函数 <span class="math inline">\(f:\mathcal{X}\rightarrow \mathcal{Y}\)</span> ，显然，对于任意的 <span class="math inline">\(i\)</span> ，有 <span class="math inline">\(y_i=f(x_i)\)</span></li></ul><p>总的来说，在训练数据中的每一个数对，都由以下方式生成：</p><ol type="1"><li>先从概率分布 <span class="math inline">\(\mathcal{D}\)</span> 采样得到一个点 <span class="math inline">\(x_i\)</span> ；</li><li>再利用标记函数 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(x_i\)</span> 打上标签。</li></ol><h2 id="measures-of-success">Measures of Success</h2><p>如何衡量算法学习是否成功？这里可以定义一个<strong>分类器的误差</strong>（<em>error of a classifier</em>），即学习算法没有正确预测随机数据（这些随机数据，是由前面提到的对于学习算法隐含的概率分布所生成的）的标签的概率。也就是说，<span class="math inline">\(h\)</span> 的误差是<strong>从分布 <span class="math inline">\(\mathcal{D}\)</span> 随机中取出一个 <span class="math inline">\(x\)</span> ，而 <span class="math inline">\(h(x)\)</span> 不等于 <span class="math inline">\(f(x)\)</span> 的概率</strong>。</p><p>规范的来讲，给定一个领域子集（<em>domain subset</em>），<span class="math inline">\(A\subset \mathcal{X}\)</span> ，概率分布 <span class="math inline">\(\mathcal{D}\)</span> ，定义一个数 <span class="math inline">\(\mathcal{D}(A)\)</span> ，其中 <span class="math inline">\(\mathcal{D}(A)\)</span> 表示学习算法在 <span class="math inline">\(\mathcal{D}\)</span> 中观察到一个点 <span class="math inline">\(x\in A\)</span> 的可能性。我们定义预测规则（<em>prediction rule</em>）的误差如下： <span class="math display">\[L_{\mathcal{D},f}(h)\overset{def}{=}\underset{x\sim\mathcal{D}}{\mathbb{P}}[h(x)\ne f(x)]\overset{def}{=}\mathcal{D}(\lbrace x:h(x)\ne f(x)\rbrace)\tag{2.1}\]</span> <div class="note info"><p><strong>有关 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(\mathcal{D}(A)\)</span> 的补充说明</strong></p><ul><li>在许多情况下，我们将 <span class="math inline">\(A\)</span> 称作一个事件（<em>event</em>）</li><li>二元分类问题中，我们定义 <span class="math inline">\(A\)</span> 为 <span class="math inline">\(\pi :\mathcal{X}\rightarrow \lbrace0,1\rbrace\)</span> ，也就有 <span class="math inline">\(A = \lbrace x\in\mathcal{X}: \pi(x) = 1\rbrace\)</span> 。在这种情况下，我们也使用 <span class="math inline">\(\mathbb{P}_{x\sim \mathcal{D}}[\pi(x)]\)</span> 来表达 <span class="math inline">\(\mathcal{D}(A)\)</span> 。</li></ul></div></p><div class="note info"><p><strong><span class="math inline">\(L_{\mathcal{D},f}\)</span> 的别称</strong></p><p><span class="math inline">\(L_{\mathcal{D},f}\)</span> 又称作<strong>泛化误差</strong>（<strong><em>generalization error</em></strong>），<strong>风险</strong>（<strong><em>risk</em></strong>），<strong><span class="math inline">\(h\)</span> 的真正误差</strong>（<strong><em>true error</em> of h</strong>）</p></div><h2 id="a-note-about-the-information-available-to-the-learner">A Note about The Information Available to The Learner</h2><p>要注意的是，<strong>学习器本身并不知晓隐含的概率分布 <span class="math inline">\(\mathcal{D}\)</span> 和 “完全正确” 的标记函数 <span class="math inline">\(f\)</span></strong> 。因此，学习器只能通过观察训练数据集，和环境交互，才能发现规律。</p><div class="note info"><h2 id="summary">Summary</h2><ul><li><strong>学习算法的输入和输出</strong>：一个学习算法接受一个<strong>训练集</strong> <span class="math inline">\(S\)</span> 作为<strong>输入</strong>，并且<strong>输出</strong>一个<strong>预测器</strong>（<em>predictor</em>） <span class="math inline">\(h_S: \mathcal{X} \rightarrow \mathcal{Y}\)</span> 。其中，训练集 <span class="math inline">\(S\)</span> 通过以下过程生成：首先从一个未知分布 <span class="math inline">\(D\)</span> 中采样，然后使用目标函数（<em>target function</em>） <span class="math inline">\(f\)</span> 标记。此外，预测器 <span class="math inline">\(h_S\)</span> 的下标 <span class="math inline">\(S\)</span> 强调了输出的 <span class="math inline">\(h_S\)</span> 是依赖于 <span class="math inline">\(S\)</span> 的。</li><li><strong>学习算法的目标</strong>：学习算法的目标是找到一个 <span class="math inline">\(h_S\)</span> ，关于未知分布 <span class="math inline">\(\mathcal{D}\)</span> 和标记函数 <span class="math inline">\(f\)</span> ，它能最小化误差。</li></ul></div><h1 id="empirical-risk-minimization-erm">Empirical Risk Minimization （ERM）</h1><h2 id="empirical-error">Empirical Error</h2><p>由于学习器并不知道 <span class="math inline">\(\mathcal{D}\)</span> 和 <span class="math inline">\(f\)</span> ，因此，式（2.1）无法直接计算。学习器能够计算的是<strong>训练误差</strong>（<em>training error</em>），即分类器在训练数据上产生的误差，其定义如下： <span class="math display">\[L_S(h)\overset{def}{=}\frac{|\lbrace i\in[m]:h(x_i)\ne y_i \rbrace|}{m}\tag{2.2}\]</span></p><p>其中 <span class="math inline">\([m]=\lbrace 1,\dots ,m\rbrace\)</span> 。</p><div class="note info"><p><strong>训练误差</strong>（<em>training error</em>）有时又称作<strong>经验误差</strong>（<strong><em>empirical error</em></strong>）或者<strong>经验风险</strong>（<strong><em>empirical risk</em></strong>）</p></div><h2 id="erm">ERM</h2><p>既然学习算法能够从训练数据中获取关于这个世界的简要情况，所以寻找一个在训练数据上效果良好的答案是说得通的。<strong>寻找一个最小化 <span class="math inline">\(L_S(h)\)</span> 的 <span class="math inline">\(h\)</span></strong> 的学习范式称作经验风险最小化（<strong>Empirical Risk Minimization</strong>），简称 <strong>ERM</strong></p><h2 id="the-problem-of-erm-overfitting">The problem of ERM —— Overfitting</h2><p>然而，ERM 可能会产生一种错误——过拟合。下面用一个例子说明。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/09/example-of-overfitting.PNG" alt="过拟合的例子. Source:《Understanding Machine Learning: From Theory to Algorithms》" /><figcaption>过拟合的例子. Source:《Understanding Machine Learning: From Theory to Algorithms》</figcaption></figure><p>假设概率分布 <span class="math inline">\(\mathcal{D}\)</span> 是灰色正方形框中的均匀分布，如果实例落在蓝色实例所在的黑色正方形框中，标记函数 <span class="math inline">\(f\)</span> 将其标记为 1，否则标记为 0。考虑如下的预测器：</p><p><span class="math display">\[h_S(x)= \begin{cases}y_i\quad &amp;if\ \exists i\in[m]\ s.t. x_i=x;\\0\quad &amp;ohterwise. \end{cases}\]</span></p><p>因为 <span class="math inline">\(h_S\)</span> 在训练数据上，对实例标签的预测全部正确，所以 <span class="math inline">\(L_S(h_s) = 0\)</span> 。根据经验风险最小化的原则，式子 （2.3）会被 ERM 选中（因为没有比 0 更小的训练损失）。然而如果取训练数据以外的一个点 <span class="math inline">\(x&#39;\)</span>，并且这个点在黑色正方形框中，那么根据式（2.3），<span class="math inline">\(h_S(x&#39;) = 0\)</span> 。而实际上 <span class="math inline">\(f(x&#39;) = 1\)</span>，这就会产生错误。</p><p>这种现象称作<strong>“过拟合”</strong>（<em>overfitting</em>）。直观的来说，当学习算法找到的假设<strong>太符合</strong>训练数据时，就会发生过拟合。</p><h2 id="empirical-risk-minimization-with-inductive-bias">Empirical Risk Minimization with Inductive Bias</h2><h3 id="applying-erm-over-a-restricted-search-space">Applying ERM over a Restricted Search Space</h3><p>一种常见的解决 ERM 过拟合的方法是<strong>限制 ERM 的搜索空间</strong>。规范的讲，在见到数据之前，学习器应该事先挑选出一个预测器集合。这个预测器集合又称作<strong>“假设类”</strong>（<em>hypothesis class</em>），记作 <span class="math inline">\(\mathcal{H}\)</span> 。每一个 <span class="math inline">\(h\in \mathcal{H}\)</span> 是一个 <span class="math inline">\(\mathcal{X}\rightarrow \mathcal{Y}\)</span> 的函数。<strong>给定一个假设类 <span class="math inline">\(\mathcal{H}\)</span> ，一个训练集 <span class="math inline">\(\mathcal{S}\)</span> ，<span class="math inline">\(ERM_{\mathcal{H}}\)</span> 学习器使用 ERM 规则来选取一个在 <span class="math inline">\(\mathcal{S}\)</span> 上有最小可能误差的 <span class="math inline">\(h\)</span> ，其中 <span class="math inline">\(h\in \mathcal{H}\)</span></strong> 。规范地，我们有如下公式： <span class="math display">\[ERM_{\mathcal{H}}(S)\in \underset{h\in \mathcal{H}}{argmin}(L_S(h))\]</span> 其中，<span class="math inline">\(argmin\)</span> 表示在 <span class="math inline">\(\mathcal{H}\)</span> 中使得 <span class="math inline">\(L_S(h)\)</span> 最小的假设集合（<span class="math inline">\(h\in\mathcal{H}\)</span>）。通过限制学习器从 <span class="math inline">\(\mathcal{H}\)</span> 中选取预测器，学习器会偏向我们所特定的预测器集合。这种限制常常被称为<strong>归纳偏好</strong>（<em>inductive bias</em>）。由于这种限制的选择在学习器看到数据之前就确定了，因此在理想情况下，它应该基于一些有关所学问题的先验知识（<em>prior knowledge</em>）。</p><p>直观地，<strong>选择一个首先更多的假设类会更好地防止过拟合的发生，但是与此同时，这可能会导致一个更强的归纳偏好</strong>。</p><h3 id="finite-hypothesis-classes">Finite Hypothesis Classes</h3><p>对类的最简单的限制是设置一个其大小的上界（也就是，限制 <span class="math inline">\(\mathcal{H}\)</span> 中预测器 <span class="math inline">\(h\)</span> 的个数）。对应的，我们有如下结论：</p><ul><li><strong>只要有足够数量的训练样本，如果 <span class="math inline">\(\mathcal{H}\)</span> 是一个有限的类（<em>finite class</em>），那么 <span class="math inline">\(ERM_{\mathcal{H}}\)</span> 将不会产生过拟合。</strong></li></ul><p>那么至少需要多少训练样本呢？下面我们讨论这个问题</p><p>在此之前，我们先引入两个假设：</p><ol type="1"><li><strong>可实现假设</strong>（<strong><em>The Realizability Assumption</em></strong>）：<span class="math inline">\(\exists h^\star \in \mathcal{H},\ L_{(\mathcal{D},f)}(h^\star) = 0\)</span> 。</li><li><strong>独立同分布假设</strong>（<strong><em>The i.i.d. Assumption</em></strong>）：训练数据中每一个样本都关于分布 <span class="math inline">\(\mathcal{D}\)</span> <strong>独立同分布</strong>（<strong>independently and identically distributed</strong>，short for <strong>i.i.d.</strong>），记作 <span class="math inline">\(S\sim D^m\)</span> 。其中， <span class="math inline">\(m\)</span> 是 <span class="math inline">\(S\)</span> 的大小，<span class="math inline">\(D^m\)</span> 表示了根据 <span class="math inline">\(\mathcal{D}\)</span> 采样 <span class="math inline">\(m\)</span> 个元素，构成 <span class="math inline">\(m\)</span> 元组，且每一个元素都独立于 <span class="math inline">\(m\)</span> 元组其他元素</li></ol><div class="note info"><p><strong>有关 <code>可实现假设</code> 和 <code>独立同分布假设</code> 的补充说明</strong></p><ul><li><code>可实现假设</code> 暗示了在随机的训练样本 <span class="math inline">\(S\)</span> ，<span class="math inline">\(S\)</span> 由从 <span class="math inline">\(\mathcal{D}\)</span> 中采样，又被 <span class="math inline">\(f\)</span> 标记所得，<span class="math inline">\(L_S(h^\star) = 0\)</span> 的可能性为 1。</li><li><code>独立同分布假设</code> 表示每一个 <span class="math inline">\(S\)</span> 中 <span class="math inline">\(x_i\)</span> 都是全新地从 <span class="math inline">\(\mathcal{D}\)</span> 中采样，并被 <span class="math inline">\(f\)</span> 标记后生成的。</li></ul></div><p>此外，定义 <span class="math inline">\(\delta\)</span> 为取得一个不具代表性（<em>nonrepresentative</em>）的样本的<strong>概率</strong>，<span class="math inline">\(1-\delta\)</span> 为预测行为的<strong>置信参数</strong>（<em>confidence parameter</em>）。</p><div class="note info"><p><strong>什么叫不具代表性（<em>nonrepresentative</em>）的样本？</strong></p><ul><li>这个样本不能代表实例的潜在规律。如一个水果本身很好吃，但是碰巧训练样本都是不好吃的，导致学习器学到了错误的结论。其中的不好吃的训练样本即是不具代表性的样本。</li></ul></div><p>由于我们不能确保完美的标签预测，因此这里我们进一步引入另一个用来衡量预测效果的参数，即<strong>精度参数</strong>（<em>accuracy parameter</em>）。其通常记作 <span class="math inline">\(\epsilon\)</span> 。我们用如下公式描述学习器是否获得成功：</p><ul><li>事件 <span class="math inline">\(L_{(\mathcal{D},f)}(h_s)&gt;\epsilon\)</span> 表示学习器的<strong>失败</strong></li><li>事件 <span class="math inline">\(L_{(\mathcal{D},f)}(h_S)\le \epsilon\)</span> 表示学习器的<strong>近似成功</strong>。</li></ul><p>令我们感兴趣的是，在由 <span class="math inline">\(m\)</span> 个实例构成的 <span class="math inline">\(m\)</span> 元组采样，会导致学习器失败的概率的<strong>上界</strong>。</p><p>规范的，记 <span class="math inline">\(S|_{x} = \lbrace x_1,\ \dots,\ x_m\rbrace\)</span> 为训练数据的实例，我们希望找到下式的上界：</p><p><span class="math display">\[\mathcal{D}(\lbrace S|_{x} : L_{(\mathcal{D},f)}(h_{S}) &gt; \epsilon \rbrace)\]</span></p><p>记 <span class="math inline">\(\mathcal{H}_B\)</span> 为“坏的”假设，即</p><p><span class="math display">\[\mathcal{H}_B = \lbrace h\in\mathcal{H}: L_{(\mathcal{D},f)}(h) &gt; \epsilon\rbrace\]</span></p><p>再令</p><p><span class="math display">\[M = \lbrace S|_x : \exists h\in \mathcal{H}_B, L_S(h) = 0 \rbrace\]</span></p><p>显然，<span class="math inline">\(M\)</span> 表示了误导学习器的样本集合。换句话说，对于每一个 <span class="math inline">\(S|_x \in M\)</span> ，存在一个坏的假设，<span class="math inline">\(h\in \mathcal{H}_B\)</span> ，但是在 <span class="math inline">\(S|_x\)</span> 中它看上去是一个好的假设。</p><p>既然可实现假设表示存在 <span class="math inline">\(L_S(h_S) = 0\)</span> ，因此，事件 <span class="math inline">\(L_{(\mathcal{D},f)}(h_s)&gt;\epsilon\)</span> 只可能在这种情况下发生：<span class="math inline">\(h\in \mathcal{H}_B\)</span> ，但是 <span class="math inline">\(L_S(h) = 0\)</span> 。也就是说，<strong>如果我们的采样样本在误导集合中，这种事件才会发生</strong>。因此，我们有：</p><p><span class="math display">\[\lbrace S|_{x} : L_{(\mathcal{D},f)}(h_S) &gt; \epsilon\rbrace \subseteq M\]</span></p><p>进一步的，<span class="math inline">\(M\)</span> 可改写成：</p><p><span class="math display">\[M = \underset{h\in \mathcal{H}_B}{\bigcup} \lbrace S|_x : L_S(h) = 0\rbrace \tag{2.5}\]</span></p><p>因此，</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_{(\mathcal{D},f)}(h_S) &gt; \epsilon\rbrace) \le \mathcal{D}^m(M) = \mathcal{D}^m({\cup}_{h\in \mathcal{H}_B} \lbrace S|_x : L_S(h) = 0\rbrace) \tag{2.6}\]</span></p><p>利用 <code>Union Bound</code> 定理，可得：</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_{(\mathcal{D},f)}(h_S) &gt; \epsilon\rbrace) \le \underset{h\in \mathcal{H}_B}{\sum}\mathcal{D}^m(\lbrace S|_x : L_S(h) = 0\rbrace)\tag{2.7}\]</span></p><div class="note info"><p><strong>定理（Union Bound）</strong></p><ul><li>对于两个集合 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 和分布 <span class="math inline">\(\mathcal{D}\)</span> ，有 <span class="math display">\[\mathcal{D}(A\cup B) \le \mathcal{D}(A) + \mathcal{D}(B)\]</span></li></ul></div><p>由于事件 <span class="math inline">\(L_S(h) = 0\)</span> 等价于 <span class="math inline">\(\forall i, h(x_i) = f(x_i)\)</span> ，所以，</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_S(h) = 0\rbrace) = \mathcal{D}^m(\lbrace S|_x : \forall i, h(x_i) = f(x_i) \rbrace)\]</span></p><p>又因为采样训练样本相互独立，且服从同一个分布 <span class="math inline">\(\mathcal{D}\)</span> ，因此，</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : \forall i, h(x_i) = f(x_i) \rbrace) = \prod_{i=1}^{m}\mathcal{D}(\lbrace x_i : h(x_i) = f(x_i) \rbrace)\]</span></p><p>故有</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_S(h) = 0\rbrace) = \prod_{i=1}^{m}\mathcal{D}(\lbrace x_i : h(x_i) = f(x_i) \rbrace) \tag{2.8}\]</span></p><p>对于训练集中每一个独立的元素，有</p><p><span class="math display">\[{D}(\lbrace x_i : h(x_i) = y_i \rbrace) = 1 - L_{(\mathcal{D},f)}\]</span></p><p>由于 <span class="math inline">\(L_{(\mathcal{D},f)}(h_s)&gt;\epsilon\)</span> ，故</p><p><span class="math display">\[{D}(\lbrace x_i : h(x_i) = y_i \rbrace) = 1 - L_{(\mathcal{D},f)} \le 1 - \epsilon\]</span></p><p>利用 <span class="math inline">\(1-\epsilon \le e^{-\epsilon}\)</span> 不等式对上式放缩，有</p><p><span class="math display">\[{D}(\lbrace x_i : h(x_i) = y_i \rbrace) = 1 - L_{(\mathcal{D},f)} \le 1 - \epsilon \le e^{- \epsilon}\]</span></p><p>将上式带入式（2.8），有</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_S(h) = 0\rbrace)\le (1 - \epsilon)^m \le e^{- m\epsilon} \tag{2.9}\]</span></p><p>结合式（2.7），有</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_{(\mathcal{D},f)}(h_S) &gt; \epsilon\rbrace) \le |\mathcal{H}_B|e^{- m\epsilon} \le |\mathcal{H}|e^{- m\epsilon}\]</span></p><p>设 <span class="math inline">\(\mathcal{D}^m(\lbrace S|_x : L_{(\mathcal{D},f)}(h_S) &gt; \epsilon\rbrace) \le |\mathcal{H}|e^{- m\epsilon}&lt; \delta\)</span> ，则有</p><p><span class="math display">\[m &gt; \frac{log(\frac{|\mathcal{H}|}{\delta})}{\epsilon}\]</span></p><div class="note info"><p><strong>推导过程</strong></p><p><span class="math display">\[\delta &gt; |\mathcal{H}|e^{-m\epsilon}\]</span></p><p><span class="math display">\[log\delta &gt; log|\mathcal{H}|-m\epsilon\]</span></p><p><span class="math display">\[m\epsilon &gt; log|\mathcal{H}| - log\delta\]</span></p><p><span class="math display">\[m&gt; \frac{log(\frac{|\mathcal{H}|}{\delta})}{\epsilon}\]</span></p></div><p>综上所述，有如下重要结论：</p><div class="note info"><p>设 <span class="math inline">\(\mathcal{H}\)</span> 为一个有限的假设类，令 <span class="math inline">\(\delta \in (0,1)\)</span> ，<span class="math inline">\(\epsilon &gt; 0\)</span> ，<span class="math inline">\(m\)</span> 为一个满足以下条件的整数： <span class="math display">\[m&gt; \frac{log(\frac{|\mathcal{H}|}{\delta})}{\epsilon}\]</span> 那么，对于任意的标记函数 <span class="math inline">\(f\)</span> ，任意的分布 <span class="math inline">\(\mathcal{D}\)</span> ，如果满足可实现假设（即，存在 <span class="math inline">\(h\in \mathcal{H}\)</span> ，使得 <span class="math inline">\(L_{(\mathcal{D},f)}(h) = 0\)</span>），则至少有 <span class="math inline">\(1-\delta\)</span> 的可能性，在 <span class="math inline">\(S\)</span> 上独立采样 <span class="math inline">\(m\)</span> 个点，对于每一个 <span class="math inline">\(ERM\)</span> 假设，满足如下式子： <span class="math display">\[L_{(\mathcal{D},f)}(h_S) \le \epsilon\]</span></p></div><p>这个结论意味着，只要有足够的训练数据（<span class="math inline">\(m&gt; \frac{log(\frac{|\mathcal{H}|}{\delta})}{\epsilon}\)</span>），在有限假设类上的 <span class="math inline">\(ERM_{\mathcal{H}}\)</span> 会尽可能近似正确（其置信参数为 <span class="math inline">\(1-\delta\)</span> ，最大的误差为 <span class="math inline">\(\epsilon\)</span>）。</p><h1 id="reference">Reference</h1><p>Shai Shalev-Shwartz, Shai Ben-David. <a href="https://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/index.html" target="_blank" rel="noopener">Understanding Machine Learning: From Theory to Algorithms</a></p>]]></content>
    
    <summary type="html">
    
      机器学习中有一个形式化的模型——统计学习框架，它是如何定义的？经验风险最小化（ERM）是一个十分基础的学习范式，它的学习目标是什么？为什么它是有效的？
    
    </summary>
    
    
      <category term="从理论到算法理解机器学习" scheme="https://cosmosning.github.io/categories/%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Statistical learning framework" scheme="https://cosmosning.github.io/tags/Statistical-learning-framework/"/>
    
      <category term="Empirical risk minimization" scheme="https://cosmosning.github.io/tags/Empirical-risk-minimization/"/>
    
  </entry>
  
  <entry>
    <title>《从理论到算法理解机器学习》引言</title>
    <link href="https://cosmosning.github.io/2020/09/13/intro-to-ml/"/>
    <id>https://cosmosning.github.io/2020/09/13/intro-to-ml/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-09-13T06:51:46.000Z</published>
    <updated>2020-11-12T01:07:59.780Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近上了一门课，叫做“智能信息检索”。老师推荐了一本教材 《Understanding Machine Learning: From Theory to Algorithms》（文末提供官方下载链接），来解释<strong>智能</strong>的含义。本文基于我对教材的理解，对其引言部分做了一些要点概括，供读者参考。</p></blockquote><h1 id="what-is-learning">What Is Learning？</h1><p>粗略地讲，<strong>学习是一个将经历（<em>experience</em>）转换为技能（<em>expertise</em>）或知识（<em>knowledge</em>）的过程</strong>。一般地，一个学习算法的<strong>输入</strong>是<strong>训练数据</strong>（代表经历），<strong>输出</strong>是<strong>技能</strong>。</p><p>一种常见的学习方法是 “记忆学习”（<em>learning by memorization</em>）。类似人类学习的“死记硬背”，这种学习方法有时候十分有效，但是它却缺失了学习系统中一个十分重要的能力，即<strong>泛化能力</strong>（<em>generalization</em>）。换句话讲，一个成功的学习系统理应能够依据已知知识，正确处理未知的情况。</p><div class="note info"><p><strong>泛化能力</strong> （<em>generalization</em>） 有时也被称作<strong>归纳推理</strong> （<em>inductive reasoning / inductive inference</em>）</p></div><p>然而，<strong>归纳推理可能会导致错误结论</strong>。那么怎样才能减少犯错呢？</p><p>答案是：在学习系统中<strong>引入先验知识</strong>（<em>prior knowledge</em>）！</p><div class="note info"><p><strong>先验知识</strong>（<em>prior knowledge</em>） 有时也被称作<strong>归纳偏好</strong> （<em>inductive bias</em>）</p></div><p>从书中举得几个例子来看，<strong>引入先验知识，使整个学习过程带有偏好，是一个成功的学习算法必然发生的事情</strong>（这种现象是 <strong>No-Free-Lunch Theorem</strong> 的具体表现）。粗略来说，学习算法开始训练时所引入的先验知识越强，从训练样本中学习就越简单。但是，先验知识越强，学习的灵活性也就越低，因为整个学习过程被这些预定假设束缚住了。</p><h1 id="when-we-need-machine-learning">When We Need Machine Learning？</h1><p>那么，在哪些情况下，我们需要利用机器学习解决问题呢？主要有以下两个方面：</p><ul><li>问题的复杂性（<em>complexity</em>）</li><li>任务的适应性需求（<em>adaptivity</em>）</li></ul><h2 id="tasks-that-are-to-complex-to-program">Tasks That Are to Complex to Program</h2><ul><li><em>Tasks Performed by Animals / Humans</em>：我们暂时无法理解一些我们能够处理的日常任务，例如驾驶汽车、语音识别、图像理解。以现有的知识，难以抽象出一个良好的程序去执行这些任务。然而，先进的机器学习程序，只要接受足够的训练样本训练，就可以从中学习经验，并在这些任务中达到不错的效果。</li><li><em>Tasks beyond Human Capabilities</em>：另一类适合用机器学习解决的问题是对巨大的且复杂的数据（例如宇宙空间数据、医疗数据、天气数据等）进行分析。这些数据的处理和分析通常超越了我们自身的分析能力。使用机器学习，可以充分利用计算机的能力，找到数据中有价值的信息。</li></ul><h2 id="adaptivity">Adaptivity</h2><ul><li>预先编程的程序有一个缺陷，即死板性（<em>rigidity</em>）。也就是说，一旦程序写好了，安装到系统中后，程序就不会变化了。然而，现实中许多任务都是在不断变化的。</li><li>而机器学习（其天生可以适应不同的输入数据）提供了一种解决此类任务的方案。</li></ul><h1 id="types-of-learning">Types of Learning</h1><h2 id="supervised-versus-unsupervised">Supervised versus Unsupervised</h2><p>如果将学习看作是一个“利用经历来获取技能”的过程，那么监督学习和非监督学习可以描述如下：</p><ul><li><strong>监督（<em>Supervised</em>）学习</strong>：在该场景中，“经历”（亦可称作训练样本）包含了十分重要的信息；而这些信息却在测试样本中丢失了。从监督学习中学习到的技能的目标是，预测测试数据中的确实信息。这就好像环境作为一名老师通过提供额外的信息（通常称作<strong>“标签”</strong> <em>label</em>）"监督"学生（学习算法）的学习。</li><li><strong>非监督（<em>Unsupervised</em>）学习</strong>：对于非监督学习来说，训练数据和测试数据几乎没什么区别。通常，这种学习方法通过处理输入数据，来达到<strong>总结数据</strong>、<strong>压缩数据</strong>的目标。<strong>聚类</strong>——将一个数据集分成几个子集，同一子集具有相似性——是非监督学习中一个典型的例子。</li><li>在监督与非监督之间，还存在一种不同的方法——<strong>强化学习</strong>。</li></ul><h2 id="active-versus-passive">Active versus Passive</h2><ul><li><strong>主动（<em>Active</em>）学习</strong>：主动学习在在训练过程中将会与环境交互。</li><li><strong>被动（<em>Passive</em>）学习</strong>：被动学习只会观测环境所提供的信息，而不会影响（influence）或指导（direct）它。</li></ul><div class="note info"><p><strong>例子</strong></p><ul><li>垃圾邮件识别通常是被动学习，因为它等着用户为它标记收到的邮件是否是垃圾邮件。</li><li>在主动学习的场景下，学习算法会在训练过程中要求用户标记它指定的邮件，或者甚至是由学习算法生成的邮件，来增强它对什么是垃圾邮件的理解。</li></ul></div><h2 id="helpful-of-the-teacher">Helpful of the Teacher</h2><ul><li>主动提供信息<ul><li>训练信息<strong>正相关</strong>——普通学习：例如，教师会不断尝试为学生提供最有用的信息，来达到某种学习目标。</li><li>训练信息<strong>负相关</strong>——<strong>对抗（<em>Adversarial</em>）学习</strong>：例如垃圾邮件生成器将会努力误导垃圾邮件识别器。</li></ul></li><li>被动提供信息<ul><li><strong>统计学习（<em>Statistical Learning</em>）</strong>：有时候，信息并不是他人主动提供的。例如科学家在认识自然时，环境，作为一位老师，并不会根据学生的需求主动的提供信息，因此是被动的提供信息。这种情况下，输入数据常常被认为是由某种随机过程（<em>random process</em>）产生。这样，就可以使用统计学习解决问题</li></ul></li></ul><h2 id="online-versus-batch-learning-protocol">Online versus Batch Learning Protocol</h2><ul><li><strong>在线学习（<em>Online Learning</em>）</strong>：学习算法必须在训练过程中，在线反馈。例如，股票交易员需要基于目前位置积累的经验，做出每日决策。虽说随着时间推移，他会称为一名专家，但是也可能在此过程中犯下代价高昂的错误。</li><li><strong>批处理学习（<em>Batch Learning</em>）</strong>：只有在处理大量的数据后，该算法才能获得所需的技能。在数据挖掘场景下，数据挖掘算法会处理大量的数据之后，才会得出相关的结论。</li></ul><h1 id="relations-to-other-fields">Relations to Other Fields</h1><h2 id="with-ai">With AI</h2><ul><li>机器学习是 AI 的一个分支。</li><li>机器学习更关注<strong>利用计算机的优势和独特的能力</strong>来<strong>补充</strong>人类的智能，因此常常处理一些远超人类能力的任务。</li><li>AI 更关注创造一个能够自动<strong>模仿</strong>智能行为的机器。</li></ul><h2 id="with-statistics">With Statistics</h2><ul><li>统计学：提出假设（专业人员） <span class="math inline">\(\rightarrow\)</span> <strong>验证假设</strong>（统计学）</li><li>机器学习：利用数据，<strong>挖掘规律</strong>，解释原因。</li><li>机器学习对<strong>算法</strong>层面的考虑更多</li><li>统计学常常关注数据的<strong>渐进性</strong>（<strong>无穷</strong>情况下的特性），机器学习则关注<strong>有限</strong>的样本空间</li><li>统计学通常<strong>预先假设数据分布</strong>，而机器学习是<strong>分布无关</strong>的（<em>distribution-free</em>）</li></ul><h1 id="reference">Reference</h1><p>Shai Shalev-Shwartz, Shai Ben-David. <a href="https://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/index.html" target="_blank" rel="noopener">Understanding Machine Learning: From Theory to Algorithms</a></p>]]></content>
    
    <summary type="html">
    
      学习是什么？什么情况下我们需要机器学习？学习分为哪几种？机器学习和其他领域有什么样的关系？
    
    </summary>
    
    
      <category term="从理论到算法理解机器学习" scheme="https://cosmosning.github.io/categories/%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Learning" scheme="https://cosmosning.github.io/tags/Learning/"/>
    
      <category term="Generalization" scheme="https://cosmosning.github.io/tags/Generalization/"/>
    
      <category term="Inductive reasoning" scheme="https://cosmosning.github.io/tags/Inductive-reasoning/"/>
    
      <category term="Inductive inference" scheme="https://cosmosning.github.io/tags/Inductive-inference/"/>
    
      <category term="Prior knowledge" scheme="https://cosmosning.github.io/tags/Prior-knowledge/"/>
    
      <category term="Inductive bias" scheme="https://cosmosning.github.io/tags/Inductive-bias/"/>
    
      <category term="No-Free-Lunch Theorem" scheme="https://cosmosning.github.io/tags/No-Free-Lunch-Theorem/"/>
    
  </entry>
  
  <entry>
    <title>KAT: Keywords-to-SPARQL Translation Over RDF Graphs 阅读笔记</title>
    <link href="https://cosmosning.github.io/2020/09/12/notes-of-kat-keywords-to-sparql-translation-2018/"/>
    <id>https://cosmosning.github.io/2020/09/12/notes-of-kat-keywords-to-sparql-translation-2018/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-09-12T00:04:23.000Z</published>
    <updated>2020-11-12T01:07:59.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="highlights">Highlights</h1><ul><li><strong>Two-Facet Indexing</strong>：这篇文章的关键词索引和图索引看上去比较简单，而且十分高效。</li><li><strong>Context Aware Ranking</strong>：充分利用关键词的上下文信息和 RDF 模式的信息，构建了一种十分有效的排序方法。</li></ul><h1 id="what">What？</h1><h2 id="problem">Problem</h2><p>将关键词查询高效的转换为 SPARQL 查询（<em>keyword-to-SPARQL</em>）</p><h2 id="contributions">Contributions</h2><p>本文主要构建了一个关键词查询系统 <code>KAT</code> ，它能够将<strong>关键词查询转换为 SPARQL 查询</strong>。与现存方法不同的是，它考虑了上下文（<em>context</em>）信息和模式（<em>schema</em>）信息。主要的贡献如下：</p><ol type="1"><li>提出了一种新颖的关键词到 SPARQL 转换（<em>keywords-to-SPARQL</em>）方法（叫做 <code>KAT</code>）。</li><li>构建了两个索引。一个为关键词索引（<strong>keyword index</strong>），另一个为图索引（<strong>graph index</strong>）。</li><li>实验表明了 <code>KAT</code> 的<strong>有效性</strong>和<strong>高效性</strong>。</li></ol><h1 id="why">Why？</h1><h2 id="necessity-for-a-keyword-query-system-in-rdf-data">Necessity for a Keyword Query System in RDF Data</h2><ul><li>RDF 提供了一种灵活的方式表示知识</li><li>SPARQL 是 RDF 的结构化查询语言。但是对于普通用户，尤其是不了解 RDF 内在模式（<em>schema</em>）或者是 SPARQL 语法的用户，使用 SPARQL 查询 RDF 数据将会极度困难。</li><li>Keyword-to-SPARQL 通过自动地将关键词转换为 SPARQL 查询语句，使得用户可以更加简单地探索 RDF 数据。</li></ul><h2 id="disadvantages-of-existing-approaches">Disadvantages of Existing Approaches</h2><p>现存的解决方案无法有效并且高效地返回关键词查询的结果，主要原因如下：</p><ul><li>没有考虑输入关键词的上下文信息</li><li>没有利用 RDF 图的模式信息（例如与某个关键词相关的 RDF 类）</li></ul><h2 id="advantages-of-proposed-method">Advantages of Proposed Method</h2><ul><li><code>KAT</code> 利用了关键字之间的上下文关系，提高了查询结果的相关性。</li><li>含有 RDF 类（<em>class</em>）信息的关键词索引（<strong>keyword index</strong>）将会解决关键词语义的模糊性问题（<em>disambiguation</em>），而图索引（<strong>graph index</strong>）将会加速图的探索过程（<em>graph exploration</em>）。</li><li>实验表明 <code>KAT</code> 处理更快，并且结果质量更好</li></ul><h1 id="how">How？</h1><p>Keyword-to-SPARQL 方法的<strong>关键</strong>是在 RDF 数据中找到一个<strong>子图</strong>，这个子图<strong>包含输入的关键词</strong>并且<strong>满足用户的需求</strong>。</p><h2 id="overview">Overview</h2><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/09/overview-of-kat.PNG" alt="Overview of KAT. Source: &quot;KAT: Keywords-to-SPARQL Translation Over RDF Graphs&quot;" /><figcaption>Overview of KAT. Source: "KAT: Keywords-to-SPARQL Translation Over RDF Graphs"</figcaption></figure><ul><li><strong>离线创建索引</strong>（<em>Offline Two-Facet Indexing</em>）：在离线处理流程中，系统将会创建两个索引，包括<strong>关键词索引</strong>和<strong>图索引</strong>。</li><li><strong>创建关键词-元素映射</strong>（<em>Keyword-to-Element Mapping</em>）：当用户提交了一个关键词查询任务后，KAT 通过离线生成的关键词索引，将关键词映射到与之相关的顶点和边（这些顶点和边被称为 <em>keyword elements</em>）。</li><li><strong>图探索</strong>（<em>Graph Exploration</em>）：然后，基于图索引进行图探索阶段，以找到含有关键词的子图。</li><li><strong>排序</strong>（<em>Ranking</em>）：使用考虑上下文关系的评价方法，将子图从大到小排序。</li><li><strong>翻译</strong>（<em>Translation</em>）：将排序前几名的子图翻译成 SPARQL 查询语句。</li></ul><h2 id="two-facet-indexing">Two-Facet Indexing</h2><h3 id="keyword-indexing">Keyword Indexing</h3><p><strong>功能</strong></p><p>将关键词映射到与之相关的元素。</p><p><strong>现存方案的不足</strong></p><p>现有方案中，关键词索引仅仅是一个简单的倒排索引（<em>inverted index</em>）。因此，在构建映射关系时，<strong>所有包含关键词的元素都被当作候选结果，这其中包括大量的无用元素</strong>。为什么会这样呢？这是由于自然语言关键词的<strong>二义性</strong>（<em>ambiguity</em>）导致的。例如，用户输入这样一个查询，<code>{person, movie, lila}</code> 。其查询意图为，找到在 “Lila Says” 中演出的演员。但是 “lila” 却是一个模棱两可的关键词，她可能是一个人名，也可能是一张专辑名，甚至是一个地铁名。</p><p><strong>解决方案</strong></p><p>为了减少关键词的二义性，这篇文章提出了一种混合索引，作为关键词索引。这个索引<strong>包含了</strong> RDF 数据中各个术语（<em>terms</em>）的<strong>类别信息</strong>。其具体结构如下图所示：</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/09/hybird-index.PNG" alt="Hybird Index. Source: &quot;KAT: Keywords-to-SPARQL Translation Over RDF Graphs&quot;" /><figcaption>Hybird Index. Source: "KAT: Keywords-to-SPARQL Translation Over RDF Graphs"</figcaption></figure><ul><li>每一个术语（<em>term</em>）都指向一个由与之相关的所有可能的 RDF 类构成的 B 树。</li><li>包含术语的元素用 <span class="math inline">\((v_C,\ l_A,\ v_L)\)</span> 表示，并且赋给 B 树上的对应结点，其中 <span class="math inline">\(v_C\in V_C,\ l_A\in L_A,\ v_L\in V_L\)</span> 。<ul><li><span class="math inline">\(V_C\)</span> 表示 RDF 图中的<strong>类顶点</strong>（<em>class vertices</em>）<strong>集合</strong>。</li><li><span class="math inline">\(L_A\)</span> 表示 RDF 图中的<strong>实体-字面量边标签</strong>（<em>entity-literal edge labels</em>）<strong>集合</strong>。</li><li><span class="math inline">\(V_L\)</span> 表示 RDF 图中的<strong>字面量顶点</strong>（<em>literal vertices</em>）<strong>集合</strong>。</li></ul></li></ul><p>此外，设关键词 <span class="math inline">\(w\)</span> 的关键词映射为 <span class="math inline">\(f:(w,C)\rightarrow K\)</span> ，其中 <span class="math inline">\(C\)</span> 为关键词 <span class="math inline">\(w\)</span> 可能对应的 RDF 类别（<em>class</em>）集合，<span class="math inline">\(K\)</span> 是关键词元素集合。特别的，集合 <span class="math inline">\(C\)</span> 由以下类（<em>class</em>）组成：</p><ul><li><strong>无二义性</strong>关键词中提及的类（<em>class</em>）（例如 <code>person</code> 、<code>movie</code>）。</li><li>在 <strong>summary graph</strong> 中能在 n 跳之内到达上述类的类。</li></ul><p><strong>预期效果</strong></p><p>这样，关键词就被映射到一个<strong>较小</strong>的并且<strong>高质量</strong>的关键词元素的集合上了。</p><h3 id="graph-indexing">Graph Indexing</h3><p><strong>功能</strong></p><p>为了更加高效地在图上探索。</p><p><strong>方案</strong></p><p>捕捉<strong>实体类别中的关系</strong>形成一个较小的 summary graph，并将其当作图索引。一个例子如下图所示：</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/09/summary-graph.PNG" alt="Summary graph. Source: &quot;KAT: Keywords-to-SPARQL Translation Over RDF Graphs&quot;" /><figcaption>Summary graph. Source: "KAT: Keywords-to-SPARQL Translation Over RDF Graphs"</figcaption></figure><p><strong>图探索基本过程</strong></p><p>进行图探索常用的方法是后向搜索算法（<em>backward search algorithm</em>）。它在图索引上搜索符合条件的子图。该算法从关键词元素开始，然后沿着边进行迭代遍历，直到找到所有的连接点（<em>connecting vertices</em>）。一个例子如下图所示：</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/09/subgraph.PNG" alt="Subgraphs. Source: &quot;KAT: Keywords-to-SPARQL Translation Over RDF Graphs&quot;" /><figcaption>Subgraphs. Source: "KAT: Keywords-to-SPARQL Translation Over RDF Graphs"</figcaption></figure><h2 id="context-aware-ranking">Context Aware Ranking</h2><p><strong>现有标准方法及其不足</strong></p><p>现有方法基于子图的结构。具体来说，较小的子图往往是正确的答案。但是最小的子图并不一定满足用户的查询需求。</p><p><strong>Context Aware 方案</strong></p><p>为了克服这个缺陷，这篇文章提出了一种利用上下文信息的排名方法。通过这种方法可以<strong>计算子图和用户查找意图的相关性</strong>。具体的，该方法考虑了三种上下文信息：</p><ul><li>the relevance of a keyword element <span class="math inline">\((v_C,\ l_A,\ v_L)\)</span> referring to a <strong>literal vertex</strong> increases if there is a keyword referring to a <code>class</code> <strong>semantically similar</strong> to <span class="math inline">\(v_C\)</span> .</li><li>the relevance of a keyword element <span class="math inline">\((v_C,\ l_A,\ null)\)</span> referring to an <strong>entity-literal edge</strong> increases if there is a keyword referring to a <code>class</code> <strong>semantically similar</strong> to <span class="math inline">\(v_C\)</span> .</li><li>the relevance of a keyword element <span class="math inline">\((v_C,\ l_A,\ v_L)\)</span> referring to a <strong>literal vertex</strong> increases if there is a keyword referring to an <code>entity-literal edge</code> <span class="math inline">\(l_A\)</span> whose related class is <strong>semantically similar</strong> to <span class="math inline">\(v_C\)</span> .</li></ul><p><strong>关键词元素打分算法</strong></p><p>下图算法 1 描述了关键词元素打分的流程：</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/09/algorithm-1.PNG" alt="Algorithm 1. Source: &quot;KAT: Keywords-to-SPARQL Translation Over RDF Graphs&quot;" /><figcaption>Algorithm 1. Source: "KAT: Keywords-to-SPARQL Translation Over RDF Graphs"</figcaption></figure><p>每个元素的分数都初始化为 <strong>0</strong> ，并且基于上述三条规则递增。第 3 - 7 行遵循了第 1、2 条规则，第 8 - 12 行遵循了第 3 条规则。下式给出了计算 <span class="math inline">\(c_1\)</span> 类和 <span class="math inline">\(c_2\)</span> 类的 semantic similarity 的方法： <span class="math display">\[sim(c_1,\ c_2)=\frac{|S(c_1,\ O)\ \cap S(c_2,\ O)|}{|S(c_1,\ O)\ \cup S(c_2,\ O)|}\tag{1}\]</span> 其中，<span class="math inline">\(S(c,\ O)\)</span> 是指在 ontology <span class="math inline">\(O\)</span> 中 <span class="math inline">\(c\)</span> 的父类集合。</p><div class="note info"><p><strong>为什么这样计算类之间的 semantic similarity？</strong></p><ul><li><p>这是因为，<code>如果两个类拥有更多相同的父类，那么这两个类往往是相似的</code>。</p></li><li><p>式（1）中<strong>分子</strong>表示两个类的父类的交集的元素个数（也就是<strong>两者共有的父类个数</strong>），<strong>分母</strong>表示两个类的父类的并集的元素个数（也就是<strong>两者一共有多少不重复的父类</strong>）。</p></li><li><p>当分子越大，分母越小时，两者的 semantic similarity 就越大，这与上述原因是一致的。</p></li></ul></div><p>给出两个关键词元素 <span class="math inline">\(k_1\)</span> 和 <span class="math inline">\(k_2\)</span> ，依据 <span class="math inline">\(k_1\)</span> ，<span class="math inline">\(k_2\)</span> 的相关度增量（<em>relevance increment</em>）可由下式得到： <span class="math display">\[rel(k_1,\ k_2) = \frac{sim(k_1.v_C,\ k_2.v_C)}{|pos(k_1) - pos(k_2)|}\tag{2}\]</span> 其中 <span class="math inline">\(pos(k)\)</span> 表示与 <span class="math inline">\(k\)</span> 对应的关键词在关键词查询序列中的位置。</p><div class="note info"><p><span class="math inline">\(rel(k_1, k_2)\)</span> <strong>的简要分析</strong></p><ul><li><p>式（2）<strong>分子</strong>表示关键词元素的<strong>类别之间的相似度</strong>，<strong>分母</strong>表示两个关键词元素所对应的<strong>关键词在关键词查询序列中的距离</strong>。</p></li><li><p>相似度越高，关键词距离越短，相应的 <span class="math inline">\(rel\)</span> 就越大。这个公式就巧妙地利用了 <code>graph schema</code> 和 <code>关键词 的 context</code>。</p></li></ul></div><p><strong>后续计算流程</strong></p><ul><li><p><strong>子图分数的计算</strong>：将与子图相关的关键词元素的分数相加，并且除以子图中边的个数。即 <span class="math display">\[Score_{subgraph} = \frac{\sum{Score_{relvant-keyword-elements}}}{|E_{relevant-in-subgraph}|}\]</span></p></li><li><p><strong>排序</strong></p></li><li><p><strong>翻译</strong></p></li></ul><h1 id="how-much">How much？</h1><ul><li><p>由于 KAT <strong>减少了关键词的模糊性</strong>，并且能够找到<strong>高度相关</strong>的子图，所以 KAT 的效果相较于传统方法更好。</p></li><li><p>虽然混合索引的空间占用更大，生成索引时间更长，但是却能够<strong>更快、更好</strong>地返回关键词查询结果。</p></li></ul><h1 id="what-then">What Then？</h1><ul><li>挖掘更多关键词中的<strong>模式信息</strong>（<em>semantical information</em>），来改进此方法。</li><li>可能存在某些方缩短<strong>图探索</strong>阶段的时间。</li></ul><h1 id="problems-to-solve">Problems to Solve</h1><p>阅读这篇文章产生了以下问题，需要未来花时间解决：</p><ul><li><input type="checkbox" disabled="" />倒排索引是什么？？</li><li><input type="checkbox" disabled="" />B 树是什么，怎么创建？</li><li><input type="checkbox" disabled="" />怎样构建 Summary Graph ？？算法流程？？</li><li><input type="checkbox" disabled="" />top graph -&gt; SPARQL Query ？？ 具体怎么处理？</li><li><input type="checkbox" disabled="" />理解 backward search algorithm ：阅读更多文献 [1] <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>， [2] <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>， [3] <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></li><li><input type="checkbox" disabled="" />怎么理解文中提出了三种上下文信息规则？</li></ul><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>He, H., Wang, H., Yang, J., Yu, P.S.: BLINKS: ranked keyword searches on graphs. In: Proceedings of the 2007 ACM SIGMOD International Conference on Management of Data, pp. 305–316. ACM (2007)<a href="#fnref1" class="footnote-back" role="doc-backlink">↩</a></p></li><li id="fn2" role="doc-endnote"><p>Le, W., Li, F., Kementsietsidis, A., Duan, S.: Scalable keyword search on large RDF data. IEEE Trans. Knowl. Data Eng. 26(11), 2774–2788 (2014)<a href="#fnref2" class="footnote-back" role="doc-backlink">↩</a></p></li><li id="fn3" role="doc-endnote"><p>Tran, T., Wang, H., Rudolph, S., Cimiano, P.: Top-k exploration of query candidates for efficient keyword search on graph-shaped (RDF) data. In: 2009 IEEE 25th International Conference on Data Engineering, ICDE 2009, pp. 405–416. IEEE (2009)<a href="#fnref3" class="footnote-back" role="doc-backlink">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      这篇文章解决了一个关键字到 SPARQL 查询（keyword-to-SPARQL）的问题，提出了一个叫做 “KAT” 的解决方案。KAT 考虑了输入关键字的上下文关系，并且通过在 RDF 数据上构建含有关键字类别（class）信息的关键字索引（keyword index），减少了输入关键字的模糊性。为了高效地探索 RDF 数据图，KAT 也构建了一个图索引（graph index）。此外，这篇文章也提出了一种具有上下文意识（context aware）的排序方法，从而可以找到与输入关键字最相关的 SPARQL 查询语句。
    
    </summary>
    
    
      <category term="研究" scheme="https://cosmosning.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Keywords-to-SPARQL" scheme="https://cosmosning.github.io/tags/Keywords-to-SPARQL/"/>
    
      <category term="Two-facet index" scheme="https://cosmosning.github.io/tags/Two-facet-index/"/>
    
      <category term="Context aware" scheme="https://cosmosning.github.io/tags/Context-aware/"/>
    
  </entry>
  
  <entry>
    <title>Sci-Owl Weekly #3：如何阅读更多的书籍</title>
    <link href="https://cosmosning.github.io/2020/08/07/sci-owl-weekly-3/"/>
    <id>https://cosmosning.github.io/2020/08/07/sci-owl-weekly-3/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-08-07T11:01:46.000Z</published>
    <updated>2020-11-12T01:07:59.780Z</updated>
    
    <content type="html"><![CDATA[<p>Sci-Owl Weekly，每周日更新。</p><p>本周刊欢迎读者的建议与投稿，请发送相关信息至 <a href="mailto:cosmosning@gmail.com">cosmosning@gmail.com</a> 。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/joel-muniz-XqXJJhK-c08-unsplash.jpg" alt="封面图" /><figcaption>封面图</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@jmuniz?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Joel Muniz</a>. <a href="https://unsplash.com/s/photos/reading?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><h1 id="如何阅读更多的书籍">如何阅读更多的书籍</h1><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/christin-hume-k2Kcwkandwg-unsplash.jpg" alt="读书" /><figcaption>读书</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@christinhumephoto?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Christin Hume</a>. <a href="https://unsplash.com/s/photos/reading?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>人们买书，屯书，却由于其他更加吸引人的消遣品而没有时间在书籍中放飞自己的灵魂。如何在这个特殊的时代中挤出时间阅读更多的书籍？这篇<a href="https://psyche.co/guides/how-to-make-a-daily-habit-of-reading-more-books" target="_blank" rel="noopener">文章</a>在习惯的角度给了我们一些建议：</p><p>一、<strong>你得要思考你为什么想要多读书，你的目的是什么</strong>。有相关理论表明，足够的自我驱动力是习惯养成所需要的基石。比如，找个安静的地方停下来，想一想你为什么要这样做呢？这样做有什么价值呢？思考并回答这些问题，会给你足够的动力去阅读。</p><p>二、<strong>准备好舒适的阅读环境</strong>。无论是阅读纸质书，还是电子书，尽可能让书籍在你阅读环境周围唾手可得。如果你想让某事成为你生活中的一大部分，你可以让它首先成为你周围环境的一大部分。外在环境的暗示，会潜移默化地提醒你，别忘了多读书。</p><p>三、<strong>从你喜欢的书籍开始阅读</strong>。不要不经思考，就拿来别人或者是大 V 的书单。这些书籍很可能和你的兴趣并不相符，也就会逐渐浇灭你持续阅读的热情。去广泛的尝试，丢弃大部分不喜欢的，留下那些与你灵魂共鸣的少数反复阅读。</p><p>四、<strong>think big，start small</strong>。你并不需要立下多大的 flag ，这在很大程度上是虚假勤奋的表现。试试这个“两分钟法则”，每天翻看书籍 120 秒，并坚持下去，这很有可能会使阅读成为你生活中不可不做的一件事。</p><p>五、<strong>创造一种“行为联系”</strong>。具体的，在同样的时间、同样的地点，拿出书籍阅读。经过足够的时间磨合，那样的情景和阅读就产生了一种 “行为联系” 。这将会成为你阅读习惯养成的基础。</p><p>六、<strong>在你的日常活动中加入阅读</strong>。很有可能你的一天被各种日常充斥，无法留下空闲的时间阅读。那么，你可以在将阅读活动附加到某一项日常中，并坚持下去。</p><p>七、<strong>接受在培养阅读习惯中的各种挑战，别为所遇到的挫折太过烦恼</strong>。想要开始做一件事势必会遇到困难，但是这会逐渐变得简单的。只要你持续坚持下去，你会强化阅读的“行为联系”。而当“行为联系”得到强化后，对行为的控制逐渐会从一种花费精力的反射处理系统转交给自动行为系统。你会逐渐进入到一种状态，这种状态会自动触发阅读活动：你甚至不会思考你会去做什么，你就开始阅读了。</p><p>八、<strong>追踪你每天的阅读进度</strong>。这样做，会给你的大脑一个逐渐迈向目标的信号，激励你继续坚持。</p><p>九、<strong>加入有关阅读的社交团体、圈子</strong>。阅读也是一种与他人连接、交流的方式。</p><p>十、<strong>培养你对读者身份的认同</strong>。花些时间思考你想成为什么人，阅读更多书会怎样帮助你实现那样的目标。你阅读的目的可能并不是要读多少本书，而是成为一个读者。</p><hr /><h1 id="聚焦">聚焦</h1><ul><li><a href="https://www.zdnet.com/article/donald-trump-signs-executive-orders-banning-tiktok-and-wechat/" target="_blank" rel="noopener">特朗普签署总统令禁用 TikTok（抖音海外版） 和 WeChat（微信）</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/macau-photo-agency-BkBPx42-y24-unsplash.jpg" alt="wechat" /><figcaption>wechat</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@macauphotoagency?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Macau Photo Agency</a>. <a href="https://unsplash.com/s/photos/wechat?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>据报道，特朗普于本周签署了两条总统令：在 45 天之后，将会制裁任何与 TikTok 母公司字节跳动、腾讯旗下的微信开展业务往来的公司。</p><p>事件追踪：<a href="https://www.pingwest.com/w/215776" target="_blank" rel="noopener">白宫：总统令仅限于微信相关公司，不影响腾讯游戏运营</a></p><hr /><ul><li><a href="https://36kr.com/p/824370599451778" target="_blank" rel="noopener">本土 RISC-V 企业芯来科技获小米投资，加速产业生态布局</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/harrison-broadbent-nePxBIvqUlU-unsplash.jpg" alt="芯片" /><figcaption>芯片</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@harrisonbroadbent?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Harrison Broadbent</a>. <a href="https://unsplash.com/s/photos/computer-chip?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>芯来科技，一家 RISC-V 处理器内核IP和生态平台公司企业，获得了新一轮融资，由小米长江产业基金领投。据悉，芯来科技本轮融资资金将用于加速技术研发和商业落地，促进 RISC-V 处理器、专用算法、操作系统等核心技术的深度融合，同时在 AIoT 领域提供软硬一体化优质解决方案。</p><hr /><ul><li><a href="https://www.engadget.com/sony-financial-earnings-ps4-game-sales-pandemic-074353666.html" target="_blank" rel="noopener">PS4 疫情期间游戏销量几乎翻倍</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/fabian-albert-ePJUCF48vgo-unsplash.jpg" alt="PS4" /><figcaption>PS4</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@fabiraw?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Fabian Albert</a>. <a href="https://unsplash.com/s/photos/playstation?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>据索尼 20 年 Q1 财报显示，截止到 6 月 30 日，PS4 游戏销售额达到了 9,100 万，同比去年的 4,980 万上涨了 83 %。其中 74 % 的销售额由数字版游戏贡献。</p><hr /><h1 id="好奇">好奇</h1><ul><li><a href="https://www.csail.mit.edu/news/potential-covid-19-vaccines-get-boost-machine-learning" target="_blank" rel="noopener">机器学习助力 COVID-19 疫苗的研发</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/shutterstock_1703465413.jpg" alt="COVID-19 疫苗概念图" /><figcaption>COVID-19 疫苗概念图</figcaption></figure><p class="img-credit">Source：<span>MIT CAAIL Blog</span></p><p>最近，来自 MIT CAAIL（Computer Science and Artificial Intelligence Laboratory）的一个团队采用了一种全新的方法，让我们更加接近疫苗研制的解决方案：一个融合了机器学习的系统，它能够选取疫苗所需的多肽，这些多肽据系统预测将会令大多数人产生免疫作用。</p><p><strong>原理</strong></p><p>被称作 "OptiVax" 疫苗设计系统，向我们展示了设计新疫苗、评估现有疫苗、增强现有疫苗设计的许多方法。在这个系统中，机器学习算法为不同多肽所显示的免疫效果分别打分，并且在不断迭代中寻找能够最大化疫苗有效覆盖人口范围的多肽。</p><p><strong>未来工作</strong></p><p>一旦疫苗的动物试验证实有效，团队声称他们会在临床许可的条件下，在人体上做实验。目前，研究者们正在与国家健康所（National Institute of Health，NIH）合作，试图观察他们的方法通过使用 COVID-19 的病人数据，是否能用在其风险预测上。此外，该团队提及道，他们所提出解决方案的框架也能被用于更广泛的传染病疫苗研究，并且他们希望未来能够将其应用到其他病毒感染的研究上。</p><p><strong>更多</strong></p><p>你可以在<a href="https://www.cell.com/cell-systems/fulltext/S2405-4712(20)30238-6" target="_blank" rel="noopener">这里</a>找到论文的全文</p><hr /><ul><li><a href="https://spectrum.ieee.org/automaton/robotics/robotics-hardware/robotic-third-arm-can-smash-through-walls" target="_blank" rel="noopener">强大的腰间机械臂</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/robo-third-arm.jpeg" alt="腰间机械臂" /><figcaption>腰间机械臂</figcaption></figure><p class="img-credit">Credit：<span>Université de Sherbrooke</span></p><p>在过去，当我们希望实际在人身体上增加一些机器部分时，这些机器通常受限于缓慢的运动和轻量级的任务。这些累赘也许并不是我们真正想要的。在 2020 年 的 ICRA （IEEE International Conference on Robotics and Automation）中，来自加拿大舍布鲁克大学（Université de Sherbrooke）的研究者给我们带来了一款强大的腰间机械臂。</p><p><strong>参数</strong></p><p>这款机械臂总重仅 4 公斤多一些，几乎和人类的手臂重量相同。它能够举起至多 5 公斤的物体，并且最大能以 3.4 m/s 的速度挥动。</p><p><strong>功能</strong></p><p>你可以将它想象成一个你的同事。无论是与你一起同时做相同的工作，以提高自己的生产力；还是去做其他繁杂重复的工作，从而可以解放自己的时间，并投入到需要创造力和判断力的工作中去。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/robo-third-arm-applications.jpeg" alt="机械臂的应用场景" /><figcaption>机械臂的应用场景</figcaption></figure><p class="img-credit">Credit：<span>Université de Sherbrooke</span></p><hr /><ul><li><a href="https://www.wired.com/story/what-can-ants-and-bees-teach-us-about-containing-disease/" target="_blank" rel="noopener">从蚂蚁和蜜蜂身上我们能学到什么应对传染病的知识</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/salmen-bejaoui-pTWNamiyDkQ-unsplash.jpg" alt="蚂蚁" /><figcaption>蚂蚁</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@slmnbj?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Salmen Bejaoui</a>. <a href="https://unsplash.com/s/photos/ants?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>许多具有“社会性”的昆虫（例如蚂蚁、蜜蜂等）通常生活在一个封闭的环境中。这些环境中包含了许多种微生物，其中就有很多能引发瘟疫的病原体。然而，在实际情况下，类似的病毒大流行却很少在昆虫中发生。似乎这些生物能够以某种方式限制病毒的传染。</p><p><strong>以往的理论观点</strong></p><p>这些昆虫通常保持他们自己和居住地的干净。工蚁会把废物和尸体从巢穴中搬走。此外，它们经常互相清洗，保持自己的整洁。</p><p>一些蚂蚁会从树上采集具有抗生素作用的树脂，并且将它们传播到巢穴的周围。某些昆虫也会分泌一些用于杀死微生物的物质。这些物质包裹在它们的身体上，也留在了地面上。</p><p>当蚂蚁巢穴遭遇到某种病毒的侵袭时，它们会改变它们的接触策略，从而使得病毒难以传播——这种现象通常被称作组织性免疫（organizational immunity）。许多“社会性”昆虫拥有分配任务的复杂的社会系统。一些工蚁倾尽一生只会照顾蚁后，或是喂养幼虫，或是保卫巢穴。有数学模型表明，这样的社会分化可能也会延缓感染的发生。例如，只是和很少所指派的工蚁接触，蚁后可能更不容易生病。</p><p><strong>验证理论的方法</strong></p><p>以往的条件下，要实验验证这些理论十分困难。然而，自动化的昆虫追踪系统的出现，使得研究者可以为昆虫应对疫情的策略做更加细致的刻画。</p><p>为了制作一个蚂蚁社会网络，研究者们为蚂蚁贴上了十分小的二维码标记。一旦整个蚂蚁群落被标记完成，就将它们放在一个观察箱中。箱子上的高速摄像机，将会读取相应的二维码，并每秒两次，记录下每一个蚂蚁的位置。之后，通过高性能计算机处理这些数据，就可以刻画出一个蚂蚁群落的社交网络图。</p><p><strong>实验发现</strong></p><p>在一项实验中，研究者们发现，在引入病原体后，蚂蚁之间的接触更加分化。一些蚂蚁之间的接触比它和另一些蚂蚁的接触要更多。至少在理论上，这种模块化的网络能够减缓感染的蔓延。毕竟，相比于将其分为 20 组（每组 5 人）相互隔离的情况，人类病毒会在 100 个相互接触的人中更快的传播。</p><p>在另一项实验中，研究者放入了蚂蚁十分容易感染的真菌。结果表明，一旦蚂蚁侦测到病原体，这些网络也发生了变化：它们的模块度（modularity）增加了，并且群落中不同的任务组之间相互接触的更少。接触过病毒的采集者开始更少的和其他蚂蚁接触。甚至未接触的蚂蚁也产生了不同的行为，这使得大部分的接触行为限制在较小的蚂蚁圈子中。</p><hr /><h1 id="百味">百味</h1><ul><li><a href="https://www.boredpanda.com/tattoo-artist-turns-scars-art-ngocliketattoo/" target="_blank" rel="noopener">化腐朽为神奇：伤疤纹身艺术</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/Tattoo-artist-makes-real-works-of-art-covering-sad-scars-5f227e9182f98__700.jpg" alt="伤疤纹身" /><figcaption>伤疤纹身</figcaption></figure><p class="img-credit">Credit：<span>ngocliketattoo</span> from <a href="https://www.boredpanda.com/" target="_blank" rel="noopener">Boredpanda</a></p><p>伤疤是人们希望隐藏起来的东西。然而一个纹身艺术家另辟蹊径，以伤疤为基础，设计出惊艳的纹身艺术。</p><hr /><ul><li><a href="https://www.ted.com/talks/lucy_hone_3_secrets_of_resilient_people" target="_blank" rel="noopener">成为坚韧的人的三个秘诀</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/LucyHone_2019X-embed.jpg" alt="Lucy Hone" /><figcaption>Lucy Hone</figcaption></figure><p class="img-credit">演讲者：<a href="https://www.ted.com/speakers/lucy_hone" target="_blank" rel="noopener">Lucy Hone</a>. <a href="www.ted.com">TED</a></p><p>要想内心强大其实十分简单。Lucy Hone，一位 Resilience expert 、 researcher，向我们介绍了三个实用的技巧。</p><hr /><ul><li><a href="https://mp.weixin.qq.com/s/wRcq37sXnNT_JJ0PvFvNoQ" target="_blank" rel="noopener">今天你内卷了吗</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/alexandru-goman-CM-qccHaQ04-unsplash.jpg" alt="思考" /><figcaption>思考</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@alexgoman?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Alexandru Goman</a>. <a href="https://unsplash.com/s/photos/thought?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>内卷，作为一个人类文化学家很早提出的概念，在近期又得到人们的广泛关注。那么什么是内卷呢？怎样应对内卷呢？这篇文章也许能解答你的困惑。</p><hr /><h1 id="器术">器术</h1><ul><li><a href="https://dev.to/devmount/10-awesome-pythonic-one-liners-explained-3doc" target="_blank" rel="noopener">英文 · 一行代码实现一个功能！10 个 Python 风格的代码解释</a></li></ul><p>这篇文章介绍了 10 行代码，每行代码实现一个简单的功能，并附有解释，任何基础的人都可以阅读。</p><hr /><ul><li><a href="https://github.com/elyase/awesome-gpt3" target="_blank" rel="noopener">资源 · Awesome GPT-3</a></li></ul><p>近期，OpenAI 商业化了其设计的 <a href="https://arxiv.org/abs/2005.14165" target="_blank" rel="noopener">GPT-3</a> 模型，并开放了申请测试。一些开发者拿到了 OpenAI 提供的测试接口，并惊叹于 GPT-3 的强大。有网友将这些应用场景和相关资料做了一个整理放在了 GitHub 上。感兴趣的读者可以访问上面所示的链接。</p><hr /><ul><li><a href="https://github.com/Delta2Force/MCVmComputers" target="_blank" rel="noopener">工具 · Minecraft 虚拟电脑 Mod</a></li></ul><p>Minecraft 作为自由度最高的游戏，为玩家提供了一个发挥创意的平台。近期，有 Mod 制作者开源了一个虚拟电脑 Mod。这使得你甚至可以在 Minecraft 中启动 Windows 95 虚拟机<a href="https://www.theverge.com/2020/7/25/21338092/minecraft-windows-95-pc-doom-vm-computers-mod" target="_blank" rel="noopener">玩 DOOM</a></p><hr /><ul><li><a href="https://mp.weixin.qq.com/s/jhgH-tY7wIkcaA7s7WpOCA" target="_blank" rel="noopener">中文 · 谈谈职场中的决策与试错</a></li></ul><p>这篇有关职场思维的文章写的十分好，建议反复阅读。</p><hr /><ul><li><a href="https://xie.infoq.cn/article/495e11547cc63794f693c1e73" target="_blank" rel="noopener">中文 · 两万字长文 50+ 张趣图带你领悟网络编程的内功心法</a></li></ul><p>有关计算机网络的常见知识的整理和讲解，建议收藏。</p><hr /><h1 id="拾贝">拾贝</h1><ul><li><a href="https://www.technologyreview.com/2020/08/06/1006079/instagram-reels-byte-triller-clash-tiktok-ban/" target="_blank" rel="noopener">对标 TikTok 的竞品有哪些</a></li></ul><p>自上周特朗普对 TikTok 发出禁令和强制收购言论后，许多以往不被人注意的短视频应用重新获得了关注。这里简单的介绍 4 个可能影响 TikTok 统治地位的 App。</p><p><strong>Byte</strong></p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/ByteApp.jpg" alt="Byte App" /><figcaption>Byte App</figcaption></figure><p class="img-credit">Credit：<span>Byte</span></p><p>在 Vine 类应用的复兴的形势下，Byte 于今年早些时间发布了。Vine ，由 Twitter 联合拥有，是一个 6 秒短视频平台，几乎是最早的短视频应用，并且启发了包括 TikTok 等 App 的流行。然而不幸的是，Vine 在 2016 年被 Twitter 关闭了。作为 Vine 的创建者之一，Dom Hofmann 制作了 Byte，并且戏称这款应用是人们所钟爱的应用的精神续作。</p><p>当 TikTok 遭受美国政府仔细检查之前，Byte 十分死寂。“那里没有那么多的人。最受欢迎的视频不过收到了 300 个点赞”。然而，现在情况有些变化。在大量 TikTok 用户蜂拥而至后，仅仅几天时间内，人们在平台上有了更多的互动，并且受欢迎的视频内容也发生了明显的变化。</p><p><strong>Reels</strong></p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/Instagram-Reels_-Facebook-launches-a-new-TikTok-clone-lailasnews.jpg" alt="Reels" /><figcaption>Reels</figcaption></figure><p class="img-credit">Source：<a href="https://lailasnews.com/instagram-reels-facebook-launches-a-new-tiktok-clone/" target="_blank" rel="noopener">LailasNews</a></p><p>Facebook，Instagram 的拥有者，在抄袭其他社交媒体平台成功特性并将其融入自己的产品中有一段悠久的历史。Reels 则是其最新的尝试。Reels 内嵌于 Instagram ，允许用户发布 15 秒可循环的视频。</p><p>Reels 上的视频内容直接对标 TikTok，你甚至会觉得这是 TikTok 的一部分，你会看到许多 20 多岁年轻人跳舞的视频。然而，对于其推荐算法你却不能抱有太多期待。</p><p>由于 Reels 是 Instagram 的一部分，所以它拥有一个强大的潜在用户基础。“我觉得它十分像 TikTok。”尽管它缺失了部分特性，但是那些东西很容易复制。有分析人士认为，如果 Reels 能够试图将 Z 世代拉回 Instagram，而不是宣传之前为了吸引视频观众而制作的 IGTV，Reels 有望成为一个可与 TikTok 匹敌的对手。</p><p>Instagram 也有一些与 TikTok 不同的巨大的文化差异。“TikTok 更加激进，并且存在多种不同的声音。”而 Instagram 上的作者更加专业，他们在自我展示上更加谨慎。</p><p>对于中老年用户来说，在 Instagram 上尝试短视频可能会有更舒适的体验。而 TikTok ，对于 25 岁以上的人也许就会是一个怪异的地方。</p><p><strong>Triller</strong></p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/triller-app-store-ranking.jpeg" alt="Triller App" /><figcaption>Triller App</figcaption></figure><p class="img-credit">Credit：<span>Solen Feyissa</span></p><p>自从 2015 年开始，就有了 Triller 的身影。作为一款音视频简易剪辑的工具，你不需要许多专业知识，就能够通过这个应用创建你自己的音乐视频。在近几周 TikTok 风波的传播下，Triller 冲上了 App Store 榜首，成为了可能是最具攻击性的 TikTok 统治地位的挑战者。它从 TikTok 挖走了很多大咖，他们目前在 Triller 发布他们的跳舞视频。近期，它甚至控告 TikTok 侵犯了它的专利。</p><p>Triller 更像是一个改进版的 TikTok 。部分原因是其对 TikTok 名人的引流宣传。这还因为，Triller 更加关注于其 AI 剪辑特性，而不是造就 TikTok 的推荐算法。此外，受其起源的影响，Triller 中的视频更加聚焦于音乐领域。</p><p>Triller 更加适合乐队作者的创作，因为 Triller 本身和许多大型唱片公司已经有了许多业务往来。除此以外，Triller 也可能会成为 TikTok 大 V 转移平台的一个选择。</p><p>TikTok 面对这个挑战者，并没有坐以待毙。上周，TikTok 宣称它将会在未来三年内投入 10 亿美元支持美国创作者。</p><p><strong>Clash</strong></p><p>和 Byte 一样， Clash 拥有 Vine 的内核文化，因为它由前 Vine 超级管理员联合制作。然而，Clash 似乎更加关注于创作者的内容变现。</p><p>因此，Clash 十分适合于那些想要将自己的内容变现的名人和那些喜欢支持他们的粉丝。</p><p>“Clash 并不是为了成为 TikTok 的竞争者而成立的，而是为了迎合一种未被满足的需求，即内容创作者如何从他们所做的东西中赚到钱，并能够维持生活”。</p><p>目前 Clash 仅在 IOS 系统上提供测试，暂时没有 Android 端。</p><hr /><ul><li><a href="https://arstechnica.com/science/2020/08/what-we-know-about-the-massive-chemical-explosion-in-beirut/" target="_blank" rel="noopener">从黎巴嫩爆炸事件我们能了解到什么</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/stephen-radford-hLUTRzcVkqg-unsplash.jpg" alt="爆炸" /><figcaption>爆炸</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@steve228uk?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Stephen Radford</a>. <a href="https://unsplash.com/s/photos/explosion?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>于 8 月 4 日下午 6 时许（当地时间）黎巴嫩的一个港口发生了重大的化学爆炸事件。这场爆炸至少导致 135 人死亡，数千人受伤，并且 30 万当地居民将因此无家可归。先前报道将其归咎于不合理的烟火存放，但是真相很快浮出水面：2750 吨硝酸铵（<span class="math inline">\(NH_4NO_3\)</span>）在 2013 年被当地官员从货船上扣押，并且之后就一直存放在该港口的一个仓库中。</p><p><strong>硝酸铵是一个十分危险的物质</strong></p><p>当这种化学原料受到足够的热量时，它会分解为其他物质：一氧化二氮（<span class="math inline">\(N_2O\)</span>）和水；或者，氮气、氧气和水（在更高的温度下）。这两种情况下，化学反应都会释放大量热量和能量。此外，该反应还会产生一种深橘红色的剧毒烟雾。</p><p><strong>比核爆炸小得多</strong></p><p>在理想情况下，一吨硝酸铵的爆炸力相当于 0.45 吨 TNT。然而，对于本次爆炸的评估，许多学者给出了不同的估算。依据地图数据和产生这种破坏所需的超压力，一个研究认为这场爆炸相当于 240 吨 TNT。另一个分析测量了爆炸所产生的火球，并以此为证据提出一个不同的估计——这相当于 300 吨 TNT。其中最高的估计为 3, 000 吨 TNT，他们将爆炸的大小和气体浓度作为参数分析得出了这个结论。</p><p>要知道，75 年前广岛核爆炸相当于 15, 000 吨 TNT。与核爆炸相比，此次爆炸要小得多。</p><hr /><h1 id="火花">火花</h1><blockquote class="blockquote-center"><p>知识的敌人不是无知，而是已经掌握知识的幻觉。</p><p>—— 斯蒂芬·威廉·霍金</p></blockquote><hr /><blockquote class="blockquote-center"><p>Every action you take，is a vote for the type of person you want to become.</p><p>—— James Clear，《Atomic Habits》</p></blockquote><hr />]]></content>
    
    <summary type="html">
    
      Sci-Owl Weekly 第 3 期
    
    </summary>
    
    
      <category term="周刊" scheme="https://cosmosning.github.io/categories/%E5%91%A8%E5%88%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>Sci-Owl Weekly #2：别让骗子利用你的声音</title>
    <link href="https://cosmosning.github.io/2020/08/02/sci-owl-weekly-2/"/>
    <id>https://cosmosning.github.io/2020/08/02/sci-owl-weekly-2/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-08-02T01:04:25.000Z</published>
    <updated>2020-11-12T01:07:59.780Z</updated>
    
    <content type="html"><![CDATA[<p>Sci-Owl Weekly，每周日更新。</p><p>本周刊欢迎读者的建议与投稿，请发送相关信息至 <a href="mailto:cosmosning@gmail.com">cosmosning@gmail.com</a> 。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/james-toose-zWA7Obpb4R4-unsplash.jpg" alt="封面图" /><figcaption>封面图</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@portablepeopleproductions?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">James Toose</a>. <a href="https://unsplash.com/s/photos/owl?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><h1 id="别让骗子利用你的声音">别让骗子利用你的声音</h1><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/bermix-studio-F7DAQIDSk98-unsplash.jpg" alt="骗子" /><figcaption>骗子</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@bermixstudio?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Bermix Studio</a>. <a href="https://unsplash.com/s/photos/fraud?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>据<a href="https://www.vice.com/en_us/article/pkyqvb/deepfake-audio-impersonating-ceo-fraud-attempt" target="_blank" rel="noopener">报道</a>，6 月，一位科技公司的雇员收到一封语音邮件。该邮件声称，自己是这家公司的 CEO ，发这封邮件的目的是要求他“立刻提供帮助”，以完成一项紧急的公司交易。之后，一家安全公司调查此事发现，虽然语音邮件中的声音与 CEO 十分相似，但这是由电脑软件生成的。这也就是近几年来常常提到的假冒音频（deepfake audio）。</p><p>Deepfake audio 在近几年随着 AI 技术的发展，只需要你声音的几个样本，便可克隆你声音，并令普通人难辨真假。虽说技术无罪，但是仍有骗子企图利用这项技术，去欺骗他人，谋求金钱或其他东西。所谓“防人之心不可无”，我们能做的便是凡事留一个心眼，保护好自己。比如说，我接到陌生电话时，通常打开免提和录音，不先出声，等对方先说。大部分情况下，来电都是推销产品；当然，也会遇到一些互相沉默的情况（可能骗子此时就在录音采样你的声音。这种情况下，不要犹豫，直接挂掉）。也许有人会认为这太神经质了，万一是重要电话怎么办？我认为，重要电话的话，对方一定会千方百计地试图联系到你，无论是通过先说话还是多次呼叫等方式。这样，你就有了多种证据证明对方并无行骗之意，从而可以放心大胆地对话。</p><p>希望各位读者，保护好自己的声音，别让骗子利用了！</p><h1 id="聚焦">聚焦</h1><ul><li><a href="https://www.donews.com/news/detail/2/3105457.html" target="_blank" rel="noopener">Canalys：二季度华为全球智能手机市场首超三星夺冠</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/Canalys_Report.jpg" alt="Canalys 报告" /><figcaption>Canalys 报告</figcaption></figure><p class="img-credit">Source：<span>Canalys 报告</span></p><p>据 Canalys 近期的一份报告指出，2020 年第二季度华为首次在全球智能手机市场上超越了三星，成为全球智能手机出货量第一的公司。</p><hr /><ul><li><a href="https://tech.163.com/20/0729/19/FINQ7D4M00097U7R.html" target="_blank" rel="noopener">字节跳动部分投资者对 TikTok 收购估值约 500 亿美元</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/kon-karampelas-12TzzNLc2QM-unsplash.jpg" alt="TikTok" /><figcaption>TikTok</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@konkarampelas?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Kon Karampelas</a>. <a href="https://unsplash.com/s/photos/tiktok?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>路透社消息，在美国要求字节跳动放弃对 TikTok 控制权的压力下，该公司正在考虑处理TikTok 的一系列选择。其中一些投资者寻求收购 TikTok，并对其估值约 500 亿美元。</p><p>事件发展：<a href="https://readhub.cn/topic/7YzhOh8jzHc" target="_blank" rel="noopener">美国政府强迫 TikTok 出售，微软接洽字节跳动有意收购</a></p><hr /><ul><li><a href="https://www.technologyreview.com/2020/07/29/1005770/nasas-new-mars-rover-perseverance-bristling-tech-find-signs-alien-life/" target="_blank" rel="noopener">NASA 的火星外星生命探索</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/brian-mcgowan-5_Z3YVosrCw-unsplash.jpg" alt="探测器" /><figcaption>探测器</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@sushioutlaw?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Brian McGowan</a>. <a href="https://unsplash.com/s/photos/mars-planet?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>在上周中国天问一号发生成功之后，美国 NASA 于当地时间 7 月 30 日向火星发射了“毅力”号探测器。该探测器试图找到外星生命迹象，并采集相关样本，返回地球。</p><h1 id="好奇">好奇</h1><ul><li><a href="https://www.theverge.com/21317052/mobile-autonomous-robot-lab-assistant-research-speed" target="_blank" rel="noopener">化学实验助理机器人</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/robo-lab-assistant.png" alt="化学实验助理机器人" /><figcaption>化学实验助理机器人</figcaption></figure><p class="img-credit">Credit：University of Liverpool</p><p>在普通人，做化学实验看来是专属于学生和研究员的工作。因为繁杂的反应原料，多样的仪器设备，需要人手精密地控制。</p><p>然而，由英国利物浦大学设计开发的机器人也能胜任做化学实验的工作了！</p><p><strong>亮点</strong></p><p>每周七天，每天 22 小时（2小时用来充电），这位机器人助理能够持续地进行化学实验。该<a href="https://www.nature.com/articles/s41586-020-2442-2" target="_blank" rel="noopener">论文</a>指出，由于不间断地运作，该助理进行实验的速度比人类助理快 1000 倍。这使得研究人员从以往的耗时实验解放出来，能够留下更多的时间设计方案等。</p><p><strong>工作原理</strong></p><p>该机器人并不是完全自动的，它需要人工编程控制，其中包括许多化学实验的基本变量，并且控制算法会根据实验结果改变 10 多个变量，以达到最佳的实验效果。</p><p><strong>价值</strong></p><p>解放研究员的时间，帮助他们提高科研效率。</p><p>雷达赋予的夜间移动性，机械臂赋予的灵活性是一项巨大的进步。</p><p><strong>劣势</strong></p><p>贵！机器人的基本硬件花费在 125,000 美元 ～150,000 美元之间，之后又花了三年时间开发控制软件。</p><p><strong>评论</strong></p><p>设计者对该技术的未来持乐观态度，因此他们创办了一家公司，试图商业化这项技术，做出更商品化的产品，预计18个月能够完成。</p><p>起初十分怀疑，当人们看到它的工作状态时，他们震惊了，并开始相信如果没有这个助理，他们会有多低效。</p><hr /><ul><li><a href="https://www.janklingler.com/" target="_blank" rel="noopener">美的令人窒息！色彩绚丽的细菌灯</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/bacteria-lamp.jpg" alt="细菌灯" /><figcaption>细菌灯</figcaption></figure><p class="img-credit">Credit：trendnomad.com</p><p><strong>亮点</strong></p><p>居住在瑞典的德国工业设计艺术家 <strong>Jan Klingler</strong> 融合了生物学、艺术和工业设计，推出了一款细菌灯产品。该产品可以为用户提供高质量的定制服务：从细菌的来源到灯的颜色，都可以满足客户个性化的需求。</p><p><strong>制作流程</strong></p><p>首先，依据用户需求，采取所需的细菌，并放入容器中培养；经过 24～48 小时的培养阶段之后，用树脂将其封存，凝固这一刻的美好；将 LED 灯插入容器，一个细菌灯就制作好了。</p><hr /><ul><li><a href="https://aeon.co/essays/if-language-began-in-the-hands-why-did-it-ever-leave" target="_blank" rel="noopener">从手到口：如果语言起源于手势，为什么口语成为目前语言的主要交流方式</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/kristina-flour-BcjdbyKWquw-unsplash.jpg" alt="从手语到口语" /><figcaption>从手语到口语</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@tinaflour?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Kristina Flour</a>. <a href="https://unsplash.com/s/photos/mouth?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>有很多语言学习研究者支持语言起源于手势。例如在孩子发育成长时，他将首先学会手势，再学会说话。也有相关实验证明，对于猿类来说，口语是难以触及的，但是手语却相对轻松习得。那么，是什么原因导致语言从手势转移到口语呢？</p><p><strong>关键要点</strong></p><p>对于这个原因的解释，很多学者从口语的优势角度给出了答案：</p><p>第一，口语是抽象的，而手势难以表达任意东西。如果不转移，那么这将严重阻碍抽象思维的诞生和发展。</p><p>第二，口语在黑暗中的表达效果更好。相对的，手语每天平均 12 小时能达到相同的效果，但是剩下的 12 小时，将会略显逊色。</p><p>第三，口语相对于手语，更加节省能量，这符合进化的规律。</p><h1 id="百味">百味</h1><ul><li><a href="http://music.163.com/program/2068129904/56704863/" target="_blank" rel="noopener">播客 ·《高考前后的日子【VG聊天室347】》</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/ivan-aleksic-PDRFeeDniCk-unsplash.jpg" alt="考场" /><figcaption>考场</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@ivalex?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Ivan Aleksic</a>. <a href="https://unsplash.com/s/photos/classroom?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>近几天，2020 年高考进入了志愿填报的阶段。高考前后你是怎么度过的呢？听一听来自游戏时光 VGtime 的编辑们对高考的回忆，以及他们学习和游戏之间的故事。</p><hr /><ul><li><a href="https://www.ted.com/talks/dean_furness_to_overcome_challenges_stop_comparing_yourself_to_others" target="_blank" rel="noopener">TED · 要克服挑战，请先停下与他人的比较</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/DeanFurness_2020S-embed.jpg" alt="Dean Furness" /><figcaption>Dean Furness</figcaption></figure><p class="img-credit">演讲人：<a href="https://www.ted.com/speakers/dean_furness" target="_blank" rel="noopener">Dean Furness</a>. TED</p><p>Dean Furness 曾经是一位数据分析员。 2011 年的一次事故使他下身瘫痪，无法行走。但经过数年的康复，辛勤工作和物理治疗师的鼓励，他开始作为轮椅运动员参加了芝加哥和波士顿马拉松比赛。 现在，他谈论自己的经历以及面对困难挑战所需要采取的措施。</p><hr /><ul><li><a href="https://www.boredpanda.com/i-spend-days-on-bridges-to-take-images-of-roaming-vendors/" target="_blank" rel="noopener">图片 · 我在桥上花了几天时间拍摄小贩的图片</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/LoesHeerinkHanoi.png" alt="小商贩" /><figcaption>小商贩</figcaption></figure><p class="img-credit">Credit：<a href="https://loesheerink.com/" target="_blank" rel="noopener">Loes Heerink</a>. <a href="https://www.boredpanda.com/i-spend-days-on-bridges-to-take-images-of-roaming-vendors/" target="_blank" rel="noopener"> Bored Panda</a></p><p>Loes Heerink 从独特的视角捕捉了小商贩们的剪影。也许你从未关注她们：生活原来是如此多彩，却又饱含艰辛。</p><h1 id="器术">器术</h1><ul><li><a href="https://laconicml.com/free-artificial-intelligence-courses/" target="_blank" rel="noopener">英文 · 10 个最佳的人工智能公开课，来自哈佛、麻省和斯坦福</a></li></ul><p>该文章整理了 10 个最佳的来自世界名校的人工智能公开课。建议收藏起来学（吃）习（灰）。</p><hr /><ul><li><a href="https://www.ted.com/talks/yann_lecun_deep_learning_neural_networks_and_the_future_of_ai" target="_blank" rel="noopener">视频 · 对话 Yann LeCun：深度学习、神经网络和 AI 的未来</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/YannLeCun_2020S-embed.jpg" alt="Yann LeCun" /><figcaption>Yann LeCun</figcaption></figure><p class="img-credit">Yann LeCun. TED</p><p>2020 年 6 月，TED 的策展人 Chris Anderson 与深度学习大师 Yann LeCun 进行了一次视频连线。Yann LeCun 在连线中聊了聊他目前正在从事的自监督机器学习研究，他是如何尝试构建像人类一样具有常识的机器，以及他对下一个在 AI 领域概念性突破的展望。</p><p>如果原站访问速度太慢，欢迎到 B 站观看<a href="https://www.bilibili.com/video/BV1TZ4y1M7nw/" target="_blank" rel="noopener">我的搬运</a></p><hr /><ul><li><a href="https://realpython.com/generative-adversarial-networks/" target="_blank" rel="noopener">英文 · 手把手教你实现你的第一个生成对抗网络</a></li></ul><p>生成对抗网络在图片生成、高清化中有非常丰富应用。如何实现一个生成对抗网络？这篇文章会手把手的教你。</p><hr /><ul><li><a href="https://mp.weixin.qq.com/s/UOt7ijpDGrguxP8dpmua-w" target="_blank" rel="noopener">中文 · 工程师如何如何培养数据思维</a></li></ul><blockquote><p>“If you can’t measure it, you can’t improve it.”</p></blockquote><p>数据思维在研究和工业生产中是非常基础的一种思维。从数据中，我们能发现目前的优势和劣势。与此同时，定义关键的监控指标，会让我们的研究和工作获得更大的提升。</p><p>该文章的作者是硅谷的工程师，带领过许多团队。从这篇文章中，你认识到数据思维的价值和工程实践。</p><hr /><ul><li><a href="https://xie.infoq.cn/article/8e66fa7ebe4d310db95b39c31" target="_blank" rel="noopener">中文 · 图解进程、线程</a></li></ul><p>通过多图、类比的手法解释进程、线程的概念，建议反复阅读。</p><h1 id="拾贝">拾贝</h1><ul><li><a href="https://www.wired.com/story/looking-for-gravitons-check-for-the-buzz/" target="_blank" rel="noopener">探测引力子</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/aron-visuals-R49cUgaQ0mk-unsplash.jpg" alt="粒子" /><figcaption>粒子</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@aronvisuals?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Aron Visuals</a>. <a href="https://unsplash.com/s/photos/particle?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>很多物理学家认为引力子是存在的，但是他们中很少人认为我们能够探测到它们。引力子的世界只有当以尽可能小的比例放大时空结构时才会显现。这需要一种能够真正利用极端能量的设备。很不幸，任何能够直接探测到这种粒子的测量设备的 “普朗克长度” 必然太大，以至于会塌陷成一个黑洞。然而，近期发表的一篇<a href="https://arxiv.org/abs/2005.07211" target="_blank" rel="noopener">论文</a>通过理论计算，改变了这个观点：引力子可能会在引力波探测器中制造出可观测的“噪音”。</p><p>引力波探测器，简单的可以看作两个间隔一定距离的物体。当有引力波通过时，它们之间的距离会随着引力波拉伸、压缩两者之间的空间而增加和减少。此时，如果将引力子混入其中，就会在时空的常见波动之上添加了新的运动。当探测器吸收和释放引力子时，两个物体就会随机抖动。这就是引力子的 “噪音” 。</p><p>Parikh（论文一作）表示：“我们总是有这样的预感，引力子会以某种方式轰击探测器，并且因此存在一些抖动现象。” “但是，” Zahariade （论文三作）补充道，“当我们从数学角度理解引力子产生噪音的原理时，那真是一个美妙的时刻。”</p><p>尽管将会面对很多挑战， Wilczek（论文二作）“谨慎乐观”地认为他们的工作提出了一个可通过实验探测验证的预测。无论如何，他都希望该论文能够激励其他理论物理研究者去研究引力子噪声。</p><p>“基础物理学的研究是一项十分困难的工作。试想一下，你在一件 T 恤衫上写满了东西，之后你就很难再向衣服上增加或修改东西了。” Wilczek 说道，“我无法预料到这项贡献会引导研究者走向哪里，但我知道它为这个世界打开了一扇新的窗户。”</p><hr /><ul><li><a href="https://www.npr.org/sections/health-shots/2020/07/27/893289171/a-boy-with-muscular-dystrophy-was-headed-for-a-wheelchair-then-gene-therapy-arri" target="_blank" rel="noopener">一个男孩、一位科学家和一个从未失去希望的家庭</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/08/marianne-bos-eDOYvF6pM1I-unsplash.jpg" alt="残疾人" /><figcaption>残疾人</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@mariannebos?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">marianne bos</a>. <a href="https://unsplash.com/s/photos/wheelchair?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>在 Conner Curran 4 岁的时候，他被诊断出患有 Duchenne型肌营养不良症。这是一个由基因缺陷引起的疾病，并且会逐渐导致患者肌肉萎缩，最终难以靠自己行走。据当时的医嘱，这个疾病难以治愈。然而，5 年后，Conner 不仅仅能够走路，并且还能够跑的更快。这要归功于一项研究发展了近 30 年的实验性的基因疗法。</p><p>据 Samulski （开创这项基因治疗的科学家）介绍，该病是由于缺少某些基因所致，因此只需将缺失的基因放回去，就能治愈。然而，这个十分简单的概念，却花了 Samulski 长达 30 多年的时间。面对技术上的挑战、研究资金的停供等阻碍，Samulski 以一个医者的坚持，最终开发出在动物身上试验成功的基因疗法。</p><p>在听到医生对于 Conner 的建议后，Conner 的父母 Jessica 和 Christopher Curran 不相信医生的预测。但是，在他们的儿子上一年级时，Conner 远远地落后于他的兄弟 Kyle，并且连在家的周围走动都十分吃力。</p><p>Curran 一家了解到，科学家们正在研究攻关，试图找到治愈的办法。在诊断后的一年，他们了解到了“基因疗法”。</p><p>“他和他的父母自愿成为第一个使用这项基因疗法的人。” Samulski 说道。</p><p>随后，有更多的志愿者接受的同样的治疗。</p><p>然而，他们中的很多人，包括 Conner ，会产生例如发烧、恶心和肝、肾脏问题。并且有两个在医院走完了他们人生中的最后一刻。</p><p>Samulski 解释道，这样基因疗法试验由于技术方面的原因存在副作用，通常会影响肝脏。他坚信，自己能够解决这个问题。像往常一样，他产生了一个想法：“我们得在这里建立一个停止标记”。他告诉团队制作一个类似的样本。</p><p>在随后的采访中，他告诉我他的团队已经在原有基础上像他所要求的那样加上了停止标记。并且，实验室正在动物身上做试验，观察这种改进是否有效。</p><h1 id="火花">火花</h1><blockquote class="blockquote-center"><p>人生・事业的结果=思维方式×热情×能力</p><p>—— <a href="https://www.kyocera.com.cn/inamori/philosophy/words43.html" target="_blank" rel="noopener">稻盛和夫</a></p></blockquote><hr /><blockquote class="blockquote-center"><p>Context, not Control</p><p>—— <a href="https://www.sanjieke.cn/youzhao/article/24025165" target="_blank" rel="noopener">字节跳动管理理念</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Sci-Owl Weekly 第 2 期
    
    </summary>
    
    
      <category term="周刊" scheme="https://cosmosning.github.io/categories/%E5%91%A8%E5%88%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>Sci-Owl Weekly #1：科技探索者周刊创刊词</title>
    <link href="https://cosmosning.github.io/2020/07/25/sci-owl-weekly-1/"/>
    <id>https://cosmosning.github.io/2020/07/25/sci-owl-weekly-1/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-07-25T16:09:19.000Z</published>
    <updated>2020-11-12T01:07:59.780Z</updated>
    
    <content type="html"><![CDATA[<figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/true-agency-Q8otix2SVko-unsplash.jpg" alt="封面图" /><figcaption>封面图</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@trueagency?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">True Agency</a>. <a href="https://unsplash.com/s/photos/magazine?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><h1 id="创刊词">创刊词</h1><p>Sci-Owl Weekly —— 科技探索者周刊就这么开始了。本周刊刊名 <code>Sci</code> 取自 <code>Science</code> 缩写，意味着本周刊主要关注科学、科技领域；<code>Owl</code> 意为猫头鹰，在西方的理解是智慧的象征。我希望我能够有猫头鹰的鹰一般的洞察力，并且以本周刊抛砖引玉，给读者带来探索智慧的享受。</p><p>目前预计每周日（我也不知道我能坚持多久，先看着吧），我会为你精选几篇文章或者视频，包括但不限于新鲜的科技资讯、有趣的科学现象。希望这些能够激起你的<strong>好奇心</strong>，并开启你的知识<strong>探索</strong>之旅。</p><p>本周刊主要有以下几个栏目：</p><ul><li>聚焦：每天都有新鲜事发生！本栏目将选取本周值得关注的科技新闻，供你了解科技行业动向。</li><li>好奇：世界很奇妙，总有些东西会激发你的好奇心！在这部分内容中，你会了解到一些有趣的原理、科技故事和更多。</li><li>百味：不妨给生活加点料！这部分的内容会关注人与生活，在理性之中点缀一些感性。</li><li>器术：别忘了学习！教程、书籍、工具都会在这部分推荐给你。</li><li>拾贝：留下文章的精华！我会摘录一些文章中的观点、现象，直接供你参考。</li><li>火花：总有那么几句话，令你醍醐灌顶！无论是思维碰撞，还是灵感迸发，这些火花也许能帮到你。</li></ul><p>那么，开始吧！</p><h1 id="聚焦">聚焦</h1><ul><li><a href="https://www.zdnet.com/article/alibabas-ant-financial-plans-shanghai-hong-kong-ipos/" target="_blank" rel="noopener">蚂蚁金服拟计划在上海和香港上市</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/markus-winkler-A-F_TIyWClU-unsplash.jpg" alt="AliPay" /><figcaption>AliPay</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@markuswinkler?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Markus Winkler</a>. <a href="https://unsplash.com/s/photos/ant-financial?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>近期，阿里巴巴蚂蚁金服开启了其在上海和香港上市的上市程序。据报道，此次上市估值约 2000 亿美金，将会推动其对中国服务业的数字化升级，并加大技术研发的投入力度。</p><ul><li><a href="http://www.xinhuanet.com/tech/2020-07/23/c_1126275764.htm" target="_blank" rel="noopener">天问一号，目标火星！</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/1126275764_15954824662821n.jpg" alt="天问一号发射升空" /><figcaption>天问一号发射升空</figcaption></figure><p class="img-credit">Credit：才扬. <a href="http://www.xinhuanet.com/tech/2020-07/23/c_1126275764.htm" target="_blank" rel="noopener">新华网</a></p><p>7 月 23 日，中国文昌航天发射场发射了中国第一颗火星探测器 "天问一号"。这一刻，我们又见证了历史！</p><ul><li><a href="https://www.pingwest.com/w/214565" target="_blank" rel="noopener">苹果承诺 2030 年实现 100% 碳中和</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/appleEnv.PNG" alt="苹果碳中和宣言" /><figcaption>苹果碳中和宣言</figcaption></figure><p class="img-credit">Source：<a href="https://www.apple.com.cn/environment/" target="_blank" rel="noopener">苹果环境保护宣传网站</a></p><p>苹果在其<a href="https://www.apple.com.cn/environment/" target="_blank" rel="noopener">网站</a>上公布了 2030 年实现 100% 碳中和的计划。该<a href="https://www.apple.com.cn/environment/pdf/Apple_Environmental_Progress_Report_2020.pdf" target="_blank" rel="noopener">报告</a>指出，苹果将在运营 100 % 使用可再生电力，在设计中 100 % 使用再生稀土，使用更高明的化学工艺减少产品对人的伤害。</p><h1 id="好奇">好奇</h1><ul><li><a href="https://www.wired.com/story/will-the-hydrogen-revolution-start-in-a-garbage-dump/" target="_blank" rel="noopener">氢气革命会从垃圾开始吗</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/hermes-rivera-R1_ibA4oXiI-unsplash.jpg" alt="垃圾填埋场" /><figcaption>垃圾填埋场</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@hermez777?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Hermes Rivera</a>. <a href="https://unsplash.com/s/photos/garbage?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>氢气在燃烧时，并不会产生有害气体，因此被人们认为是未来能源。</p><p>目前，许多美国企业正竞相将垃圾转换为氢气燃料技术商业化。那么，氢气革命会从垃圾开始吗？</p><ul><li><a href="https://www.knowablemagazine.org/article/health-disease/2020/how-viruses-evolve" target="_blank" rel="noopener">病毒是如何进化的</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/virus-evolution-1600x600_0.png" alt="病毒是如何进化的" /><figcaption>病毒是如何进化的</figcaption></figure><p class="img-credit">Credit：<a href="https://www.knowablemagazine.org/article/health-disease/2020/how-viruses-evolve" target="_blank" rel="noopener">KNOWABLE MAGAZINE</a></p><p>新冠病毒疫情在全球范围内已经持续了半年之久。据目前的全球数据来看，疫情并没有在全球范围内得到控制。</p><p>病原体在感染新宿主时，需要适应新环境。这种特性是如何影响疫情的传播？接下来会怎么样？也许通过了解病毒是如何进化的，可以帮助我们更好的采取正确的措施。</p><ul><li><a href="https://primer.ai/blog/maverick-goose-begin-romantic-relationship/" target="_blank" rel="noopener">AI 如何生成新闻标题</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/kedar-dhond-4Jr97hj-fn8-unsplash.jpg" alt="新闻标题" /><figcaption>新闻标题</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@kedard?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Kedar Dhond 📷</a>. <a href="https://unsplash.com/s/photos/headlines?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>如何为新闻起一个合适的标题？现在 AI 也能胜任这份工作了，并且可能会比人类表现的更为出色！如果你对此有兴趣，可以参看这篇<a href="https://arxiv.org/abs/1904.08455" target="_blank" rel="noopener">论文</a> 。</p><p>拓展阅读：<a href="https://www.technologyreview.com/2020/07/20/1005454/openai-machine-learning-language-generator-gpt-3-nlp/" target="_blank" rel="noopener">太强大了！OpenAI 的 GPT-3 语言生成器</a></p><h1 id="百味">百味</h1><ul><li><a href="https://mp.weixin.qq.com/s/4noztbORY8YGRBrN4E0obw" target="_blank" rel="noopener">挣扎</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/christopher-lemercier-12yvdCiLaVE-unsplash.jpg" alt="挣扎" /><figcaption>挣扎</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@elevantarts?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">christopher lemercier</a>. <a href="https://unsplash.com/s/photos/struggle?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>Redis 的作者 Antirez 是一位光鲜亮丽的艺术家，但他也免不了承受来自现实的压力：他既希望通过代码表达自我，但又受困于 Redis 维护过程中永无止尽的 PR 评审 、用户吐槽。在这样一个状态下，他选择近期辞去 Redis 项目维护者职务，将 Redis 交给 Redis 社区。</p><ul><li><a href="https://mp.weixin.qq.com/s/81ONcA1ViqpnfqB7-jfwAQ" target="_blank" rel="noopener">王信文 | 情绪作为一种操作系统</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/tengyart-auEPahZjT40-unsplash.jpg" alt="情绪" /><figcaption>情绪</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@tengyart?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Tengyart</a>. <a href="https://unsplash.com/s/photos/emotion?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>情绪作为我们与生俱来的能力，并不能够应付越来越复杂的现实社会，我们要做的便是以升级的视角看待情绪，让它像操作系统一样更新换代。</p><ul><li><a href="https://www.douban.com/gallery/topic/152992/" target="_blank" rel="noopener">你童年时代的夏天</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/edceee-G35D9jK1Bf0-unsplash.jpg" alt="夏天" /><figcaption>夏天</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@edceee?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">煜翔 肖</a>. <a href="https://unsplash.com/s/photos/summer?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>夏天，总会留下美好的回忆。你记忆中的夏天是什么样的？我想从陌生人的动态能窥见端倪。</p><h1 id="器术">器术</h1><ul><li><a href="https://poloclub.github.io/cnn-explainer/" target="_blank" rel="noopener">英文 · CNN 交互式教程</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/CNN-Explainer.PNG" alt="CNN-Explainer" /><figcaption>CNN-Explainer</figcaption></figure><p>一个可交互的 CNN 入门教程，可以自己上传图片，观察处理过程。</p><ul><li><a href="https://pytorch.org/assets/deep-learning/Deep-Learning-with-PyTorch.pdf" target="_blank" rel="noopener">英文 · PyTorch 深度学习.pdf</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/DL-with-PyTorch.PNG" alt="DL-with-PyTorch" /><figcaption>DL-with-PyTorch</figcaption></figure><p>PyTorch 最好入门教程《Deep Learning with PyTorch》限时免费下载。</p><ul><li><a href="https://realpython.com/python3-object-oriented-programming/" target="_blank" rel="noopener">英文 · Python 3 面向对象编程教程</a></li></ul><p>介绍 Python3 如何定义类、实例化对象、继承等基本语法。</p><ul><li><a href="https://coolshell.cn/articles/20793.html" target="_blank" rel="noopener">中文 · 与程序员相关的CPU缓存知识</a></li></ul><p>缓存思想在工程应用中经常用到，是时候去操作系统 CPU 那里取取经了！</p><ul><li><a href="https://www.bilibili.com/video/BV12t411u726" target="_blank" rel="noopener">视频 · jvm内存模型全面解析</a></li></ul><p>有关 jvm 内存模型，一个视频就理解了！</p><h1 id="拾贝">拾贝</h1><ul><li><a href="http://www.ruanyifeng.com/blog/2020/07/apple-abandon-Intel-chips-hit-the-us-computer-industry.html" target="_blank" rel="noopener">苹果放弃英特尔芯片，为什么会打击美国计算机产业？</a></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/bg2020071804.jpg" alt="Apple Silicon" /><figcaption>Apple Silicon</figcaption></figure><p>关于中国的电子制造业，普遍的观念是那里劳动力成本低，所以才选择在那里建立外包工厂。我不确定他们去的是中国哪个地区，但事实是，中国早在多年前就不再是劳动力成本低的国家。从供应链的角度来看，劳动力成本并不是选择中国的原因，主要原因是中国能够提供的技能。</p><p>我们的产品需要非常先进的工具，这意味着整个配套技术都必须是最先进的。这需要很深的工具技能。在美国，你召开一次工具方面的工程师会议，我不知道能不能坐满一个会议室，但在中国，可以坐满多个足球场。</p><ul><li><a href="https://type.cyhsu.xyz/2020/03/on-the-popularity-of-newsletters/" target="_blank" rel="noopener">从邮件通讯的流行谈起</a></li></ul><p><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/nyt_nl.png" /></p><p>放眼科技行业，近年无数新技术和平台都以「赋能」（empower）为使命，声称自己为用户和创作者提供了亟需的获取和传播信息的能力。然而，支撑着这种赋能叙事的，是一种「无能」的假定：用户没有能力自主找到需要的信息，而是需要算法来推荐和投喂；创作者没有能力自主和受众建立关系，而是需要平台和竞价「优化」来牵线搭桥。</p><p>邮件通讯和 RSS 等古旧技术的复苏有力地证伪了这种假定。它们表明，只要保障信息的自由流动、组合、处理——各种早期技术的普遍特征——用户就有能力搭配出符合兴趣且优质的信息「食谱」，创作者也有能力和用户建立直接、亲密的联系。相比于「赋能」，用户和创作者更需要的或许是「还能」，夺回他们被复杂技术以「赋能」名义攫取的独立获取或传播信息的能力。</p><p>但也正因如此，在使用和推广邮件通讯这样的「复古」技术时，应当避免对于其外在形式、渠道的过度强调。邮件通讯没有什么特殊的形式，而是抛开了各种不必要的形式，把信息不加包装、直截了当地送达读者；不是什么特殊的渠道，而是开辟了一个替代渠道，让用户在信息轰炸中获得自主掌控的空间。把握了这一点，不用拘泥于电子邮件的形式，也可以实现对信息区隔和分流的效果。反之，邮件通讯也可能被异化和商品化，为用户本就饱和的信息摄入徒增另一重负担。</p><h1 id="火花">火花</h1><ul><li><a href="https://www.v2ex.com/t/692079" target="_blank" rel="noopener">你要悄悄学 Python ，然后惊艳所有人</a></li></ul><blockquote class="blockquote-center"><p>如果不打算投入程序员这个职业，建议学习掌握好 Office 三件套，受益终身 尤其是 Excel 。</p><p>—— V2EX 网友</p></blockquote><ul><li><a href="https://www.v2ex.com/t/692187" target="_blank" rel="noopener">搞软件架构，是不是绕不开 Java ？</a></li></ul><blockquote class="blockquote-center"><p>架构和语言有什么关系？架构是方法论，语言只是工具。</p><p>楼主你需要跳出编程的层面去看问题，这样才能找到问题的核心。</p><p>—— V2EX 网友</p></blockquote>]]></content>
    
    <summary type="html">
    
      Sci-Owl Weekly 第 1 期
    
    </summary>
    
    
      <category term="周刊" scheme="https://cosmosning.github.io/categories/%E5%91%A8%E5%88%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>SPARQL简易入门</title>
    <link href="https://cosmosning.github.io/2020/07/22/sparql-grammar-tutorial/"/>
    <id>https://cosmosning.github.io/2020/07/22/sparql-grammar-tutorial/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-07-22T13:27:40.000Z</published>
    <updated>2020-11-12T01:07:59.780Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习图数据库的基础知识。本文将参考 《<a href="http://learningsparql.com/" target="_blank" rel="noopener">Learning SPARQL: querying and updating with SPARQL 1.1</a>》这本书，简单介绍 RDF 数据查询语言 SPARQL。主要内容如下：</p><ol type="1"><li>SPARQL简介</li><li>SPARQL 基本语法</li><li>SPARQL 常见关键字</li><li>SPARQL 常见函数</li></ol></blockquote><h1 id="sparql-简介">SPARQL 简介</h1><p>SPARQL（SPARQL Protocol and RDF Query Language）是一种数据查询语言。它不仅仅支持查询 RDF 数据，也可以在部分关系型数据库中对数据库进行数据操作。</p><h1 id="基本语法">基本语法</h1><p>SPARQL 的语法与 SQL 很类似，也有许多不同之处。下面将简要介绍 SPARQL 的基本语法。</p><h2 id="符号">符号</h2><h3 id="变量和常量字符串数字及uri">变量和常量（字符串、数字及URI）</h3><p>在 SPARQL 语句中，通常以 <code>？变量名</code> 表示变量；而常量一般为字符串、数字及 URI，其中 URI 由尖括号（&lt; &gt;）包裹。</p><h3 id="标点符号">标点符号</h3><ul><li>逗号（,）与分号（;）</li></ul><p>与 RDF Turtle 序列化格式类似，<code>;</code> 代表下一个三元组与当前三元组拥有<strong>相同的主语</strong>，<code>,</code> 代表下一个三元组与当前三元组拥有<strong>相同的主语和谓语</strong>。</p><ul><li>井号（#）</li></ul><p>在 SPARQL 脚本文件中（文件后缀名为 <code>.rq</code>），<strong><code>#</code> 为注释标记</strong>。</p><ul><li>尖括号（&lt; &gt;）</li></ul><p>尖括号常用来<strong>包裹 URI</strong>。</p><ul><li>星号（*）与加号（+）</li></ul><p>星号和加号常用于<strong>查询的正则匹配</strong>。在正则匹配中，<strong>星号</strong>代表<strong>零个或多个</strong>，<strong>加号</strong>代表<strong>一个或多个</strong>。例如，假设有一个论文相互引用的关系图，那么 <code>?s c:cites :paperA</code> 中的 <code>？s</code> 则代表所有一次直接引用 <code>:paperA</code> 的论文；而 <code>?s c:cites+ :paperA</code> 中的 <code>?s</code>则在前者的基础之上，进一步包含了间接引用 <code>:paperA</code> 的论文。</p><p>此外，与 SQL 相同，查询子句 <code>SELECT *</code> 中的星号代表所有数据。</p><ul><li>叹号（!）</li></ul><p>叹号用于布尔条件判断中的<strong>否定词</strong>。</p><ul><li>脱字符（^）</li></ul><p>脱字符在 SPARQL 中可用来修饰谓语，用来反转主语与宾语之间的关系。例如，假设有一个三元组 <code>s p o;</code> ，那么 <code>o ^p s;</code> 将与之等价（<strong>主宾颠倒</strong>）。</p><ul><li>斜杠（/）</li></ul><p>斜杠用来分隔几个连续的谓语，例如，<code>?s c:cites/c:cites/c:cites :paperA</code> 中 <code>?s</code> 代表与 <code>:paperA</code> 引用属性距离为 3 的所有论文。</p><h2 id="语句">语句</h2><h3 id="查询">查询</h3><p>SPARQL 支持多种关键词查询数据。这些关键词包括 <code>SELECT</code> 、<code>CONSTRUCT</code> 、<code>DESCRIBE</code> 、 <code>ASK</code> 。</p><ul><li><code>SELECT</code> 查询结果返回一个二维表（与 SQL 中 <code>SELECT</code> 类似），其语句一般格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT [DISTINCT] &lt;variable1&gt; [&lt;variable2&gt; ...]</span><br><span class="line">[FROM ...]</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">    triple pattern 1.</span><br><span class="line">    [triple pattern 2.]</span><br><span class="line">    ...</span><br><span class="line">    [附加条件...]</span><br><span class="line">&#125;</span><br><span class="line">[OFFSET 数字]</span><br><span class="line">[LIMIT 数字]</span><br><span class="line">[ORDER BY | GROUP BY ...]</span><br></pre></td></tr></table></figure><ul><li><code>CONSTRUCT</code> 查询结果返回一个 RDF 图（三元组集合），其语句一般格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CONSTRUCT </span><br><span class="line">&#123; </span><br><span class="line">    triple pattern .</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line">WHERE </span><br><span class="line">&#123; </span><br><span class="line">    triple pattern . </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>关于 <code>CONSTRUCT</code> 更多用法请参看 <a href="https://www.w3.org/TR/sparql11-query/#construct" target="_blank" rel="noopener">W3C Recommendation</a></p></div><ul><li><code>ASK</code> 查询结果返回真或者假，表示 RDF 数据中是否存在指定模式的三元组，其语句一般格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ASK  </span><br><span class="line">&#123; </span><br><span class="line">    triple pattern .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>DESCRIBE</code> 查询结果返回对指定数据的资源描述（以 RDF 图的形式存储），该图的结果由 SPARQL 处理器决定（也就是说，不同 SPARQL 处理器运行同一条 <code>DESCRIBE</code> 查询语句，可能会有不同的结果），其语句一般格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DESCRIBE &lt;variable1&gt;|&lt;IRI1&gt; [&lt;variable2&gt;|&lt;IRI2&gt; ...]</span><br><span class="line">WHERE </span><br><span class="line">&#123;</span><br><span class="line">    triple pattern .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>关于 <code>DESCRIBE</code> 更多用法请参看 <a href="https://www.w3.org/TR/sparql11-query/#describe" target="_blank" rel="noopener">W3C Recommendation</a></p></div><div class="note info"><p class="note-title">URLs, URN，URIs，IRIs</p><ul><li>URL（Uniform Resource Locator）：用于指明网络资源的位置。</li><li>URN（Universal Resource Name）：用于指明网络资源的名称。</li><li>URI（Universal Resource Identifier）：用于唯一指定资源，包含 URL 和 URN（很少在用）。</li><li>IRI（Internationalized Resource Identifier）：IRI 是 URI，但是可包含更广泛的字符（如中文等）</li></ul></div><h3 id="增加tbd">增加（TBD）</h3><h3 id="更新tbd">更新（TBD）</h3><h3 id="删除tbd">删除（TBD）</h3><h1 id="常见关键字">常见关键字</h1><h2 id="where">WHERE</h2><p><code>WHERE</code> 用于指明查询条件，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex003.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?craigEmail</span><br><span class="line">WHERE</span><br><span class="line">&#123; ab:craig ab:email ?craigEmail . &#125;</span><br></pre></td></tr></table></figure><h2 id="distinct">DISTINCT</h2><p>和 SQL 一样，<code>DISTINCT</code> 用于消去查询结果中重复的数据项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex092.rq</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT ?p </span><br><span class="line">WHERE</span><br><span class="line">&#123; ?s ?p ?o . &#125;</span><br></pre></td></tr></table></figure><p>上述查询将会返回<strong>数据集中所有不重复的属性名称</strong>。当遇到一个新的数据集时，建议执行该脚本，从而初步认识该数据集。</p><h2 id="from">FROM</h2><p><code>FROM</code> 关键字常用于指明数据集所在位置，有以下两种形式：</p><ul><li><code>FROM &lt;URI&gt;</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex123.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?email </span><br><span class="line">FROM &lt;ex069.ttl&gt;</span><br><span class="line">FROM &lt;ex122.ttl&gt;</span><br><span class="line">WHERE</span><br><span class="line">&#123; ?s ab:email ?email . &#125;</span><br></pre></td></tr></table></figure><p>例如，上述 SPARQL 脚本文件从 <code>&lt;ex069.ttl&gt;</code> 和 <code>&lt;ex122.ttl&gt;</code> 文件中查询数据</p><ul><li><code>FROM NAMED</code></li></ul><p><code>FROM NAMED</code> 为提供了在 Named Graph 中查询数据的功能。下面是一个具体的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex126.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?lname ?courseName </span><br><span class="line">FROM &lt;ex069.ttl&gt; </span><br><span class="line">FROM NAMED &lt;ex125.ttl&gt;</span><br><span class="line">FROM NAMED &lt;ex122.ttl&gt;   # unnecessary</span><br><span class="line"></span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  &#123; ?student ab:lastName ?lname &#125;</span><br><span class="line">  UNION</span><br><span class="line">  &#123; GRAPH &lt;ex125.ttl&gt; &#123; ?course ab:courseTitle ?courseName &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该查询包含三个数据集，一个是通过 <code>FROM &lt;URI&gt;</code> 指定，另外两个以 <code>FORM NAMED</code> 指定。在 <code>WHERE</code> 查询条件中，<code>GRAPH &lt;ex125.ttl&gt;</code> 说明下面一条三元组模式将仅在 <code>&lt;ex125.ttl&gt;</code> 中查找；如不指定 <code>GRAPH &lt;URI&gt;</code> ，则从 <code>FROM &lt;URI&gt;</code> 中查找。</p><div class="note info"><p class="note-title"><code>FROM &lt;URI&gt;</code> V.S. <code>FROM NAMED</code></p><ul><li><p>在使用 <code>FROM &lt;URI&gt;</code> 的方式指明数据集时，这些数据都会添加到一个默认的 RDF 图（default graph）中以供查询；</p></li><li><p>而 <code>FROM NAMED</code> 则不会将数据集加入到默认的 RDF 图中，需要在 <code>WHERE</code> 额外声明 <code>GRAPH &lt;URI&gt;</code> 才能仅在该 Named Graph 中查询数据。</p></li></ul></div><h2 id="graph">GRAPH</h2><p><code>GRAPH</code> 常与 <code>FROM NAMED</code> 配合使用，用于指明下一个模式只在 <code>GRAPH</code> 指定的数据集中查询（例子见本文 <code>FROM NAMED</code> 部分）。</p><h2 id="optional">OPTIONAL</h2><p>关键词 <code>OPTIONAL</code> 的含义是，<strong>如果存在的话，请返回该值，否则返回为空</strong>。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex057.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?first ?last ?workTel</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?s ab:firstName ?first ;</span><br><span class="line">     ab:lastName ?last .</span><br><span class="line">  OPTIONAL </span><br><span class="line">  &#123; ?s ab:workTel ?workTel . &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述脚本查询了一个通讯录，无论其是否有工作电话这个属性（如果没有，将该值置空即可），都返回其名、姓和工作电话的值。</p><p><strong>一个查询脚本可有多个 <code>OPTIONAL</code> 子句，并且一个 <code>OPTIONAL</code> 子句可有多个匹配模式</strong>。值得注意的是，查询处理将<strong>先后</strong>处理 <code>OPTIONAL</code> 子句中的条件。利用这个特性，我们可以完成下列查询：优先返回每个人的昵称，如果没有则返回其名。查询脚本示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex063.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?first ?last</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?s ab:lastName ?last . </span><br><span class="line">  OPTIONAL &#123; ?s ab:nick ?first . &#125;</span><br><span class="line">  OPTIONAL &#123; ?s ab:firstName ?first . &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="filter-filter-not-exists-及-minus">FILTER 、 FILTER NOT EXISTS 及 MINUS</h2><ul><li><code>FILTER</code></li></ul><p><code>FILTER</code> 意为筛选，顾名思义，其功能就是筛选出满足某种条件的数据。<code>FILTER</code> 接受一个结果为布尔量的输入：如果该布尔量为真，则选出；否则，不选。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex105.rq</span><br><span class="line"></span><br><span class="line">PREFIX dm: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;demo#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?s ?cost</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?s dm:cost ?cost .</span><br><span class="line">  FILTER (?cost &lt; 10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述查询就筛选出花费小于 10 的项目和具体花费。</p><ul><li><code>FILTER NOT EXISTS</code></li></ul><p><code>FILTER NOT EXISTS</code> 是 <code>FILTER</code> 的一种否定表达。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex067.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?first ?last </span><br><span class="line"></span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?s ab:firstName ?first ;</span><br><span class="line">     ab:lastName ?last .</span><br><span class="line">  FILTER NOT EXISTS &#123; ?s ab:workTel ?workNum &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述查询就筛选出没有工作电话的人的名和姓。</p><ul><li><code>MINUS</code></li></ul><p><code>MINUS</code> 表示在查询结果中减去满足某种模式的数据。那么，筛选出没有工作电话的人的名和姓也可以通过 <code>MINUS</code> 实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex068.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?first ?last </span><br><span class="line"></span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?s ab:firstName ?first ;</span><br><span class="line">     ab:lastName ?last .</span><br><span class="line">  MINUS &#123; ?s ab:workTel ?workNum &#125;</span><br></pre></td></tr></table></figure><h2 id="union">UNION</h2><p>通过 <code>UNION</code> 关键字，我们可以合并不同模式匹配到的结果。例如下列查询使用了 <code>UNION</code> 得到了会演奏萨克斯或者小号的人的名、姓和能够演奏的乐器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex103.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?first ?last ?instrument </span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">    ?person ab:firstName ?first ;</span><br><span class="line">            ab:lastName ?last ;</span><br><span class="line">            ab:instrument ?instrument . </span><br><span class="line"></span><br><span class="line">    &#123; ?person ab:instrument &quot;sax&quot; . &#125;</span><br><span class="line"></span><br><span class="line">    UNION</span><br><span class="line"></span><br><span class="line">    &#123; ?person ab:instrument &quot;trumpet&quot; . &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="notin">（NOT）IN</h2><p><code>IN</code> 关键字用来判断指定变量是否在指定枚举集合中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex109.rq</span><br><span class="line"></span><br><span class="line">PREFIX dm:  &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;demo#&gt;</span><br><span class="line">PREFIX db: &lt;http:&#x2F;&#x2F;dbpedia.org&#x2F;resource&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?s ?cost ?location</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?s dm:location ?location ;</span><br><span class="line">     dm:cost ?cost . </span><br><span class="line">  FILTER (?location IN (db:Montreal, db:Lisbon)) . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 <code>FILTER</code> 过滤条件为：地点是否在蒙特利尔或者里斯本。如果在，则选出，否则不选。</p><p><code>NOT IN</code> 为 <code>IN</code> 的否定形式。</p><h2 id="limit-及-offset">LIMIT 及 OFFSET</h2><ul><li><code>LIMIT</code></li></ul><p><code>LIMIT</code> 用于限定返回数据显示的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex116.rq</span><br><span class="line"></span><br><span class="line">PREFIX rdfs: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;01&#x2F;rdf-schema#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?label </span><br><span class="line">WHERE</span><br><span class="line">&#123; ?s rdfs:label ?label . &#125;</span><br><span class="line">LIMIT 2</span><br></pre></td></tr></table></figure><ul><li><code>OFFSET</code></li></ul><p><code>OFFSET</code> 用于指定数据在返回数据的偏移量（即<strong>显示第几个数据</strong>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex118.rq</span><br><span class="line"></span><br><span class="line">PREFIX rdfs: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;01&#x2F;rdf-schema#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?label </span><br><span class="line">WHERE</span><br><span class="line">&#123; ?s rdfs:label ?label . &#125;</span><br><span class="line">OFFSET 3</span><br></pre></td></tr></table></figure><h2 id="order-by-和-group-by-having">ORDER BY 和 GROUP BY [HAVING <条件>]</h2><ul><li><code>ORDER BY</code></li></ul><p>关键词 <code>ORDER BY</code> 告诉查询处理器，按照指定变量对返回结果进行排序（默认升序，降序需指明 <code>DESC(?变量名)</code>）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex146.rq</span><br><span class="line"></span><br><span class="line">PREFIX e: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;expenses#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?description ?date ?amount</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?meal e:description ?description ;</span><br><span class="line">        e:date ?date ;</span><br><span class="line">        e:amount ?amount . </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ORDER BY ?amount</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex148.rq</span><br><span class="line"></span><br><span class="line">PREFIX e: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;expenses#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?description ?date ?amount</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?meal e:description ?description ;</span><br><span class="line">        e:date ?date ;</span><br><span class="line">        e:amount ?amount . </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ORDER BY DESC(?amount)</span><br></pre></td></tr></table></figure><ul><li><code>GROUP BY</code></li></ul><p><code>GROUP BY</code> 会将返回结果按照指定规则分组，可用 <code>HAVING &lt;条件&gt;</code> 做进一步条件限定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex164.rq</span><br><span class="line"></span><br><span class="line">PREFIX e: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;expenses#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?description (SUM(?amount) AS ?mealTotal)</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?meal e:description ?description ;</span><br><span class="line">        e:amount ?amount . </span><br><span class="line">&#125;</span><br><span class="line">GROUP BY ?description</span><br><span class="line">HAVING (SUM(?amount) &gt; 20)</span><br></pre></td></tr></table></figure><h2 id="as">AS</h2><p><code>AS</code> 用于给数据起名字，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex139.rq</span><br><span class="line"></span><br><span class="line">PREFIX e: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;expenses#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?description ?amount ((?amount * .2) AS ?tip) </span><br><span class="line">       ((?amount + ?tip) AS ?total)</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?meal e:description ?description ;</span><br><span class="line">        e:amount ?amount . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bind">BIND</h2><p><code>BIND</code> 用于给变量赋值。常见用法为 <code>BIND (数字计算 AS ?变量名)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 来源：https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;sparql11-query&#x2F;#bind</span><br><span class="line"></span><br><span class="line">PREFIX  dc:  &lt;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;elements&#x2F;1.1&#x2F;&gt;</span><br><span class="line">PREFIX  ns:  &lt;http:&#x2F;&#x2F;example.org&#x2F;ns#&gt;</span><br><span class="line"></span><br><span class="line">SELECT  ?title ?price</span><br><span class="line">&#123;  &#123; ?x ns:price ?p .</span><br><span class="line">     ?x ns:discount ?discount</span><br><span class="line">     BIND (?p*(1-?discount) AS ?price)</span><br><span class="line">   &#125;</span><br><span class="line">   &#123;?x dc:title ?title . &#125;</span><br><span class="line">   FILTER(?price &lt; 20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="values">VALUES</h2><p><code>VALUES</code> 提供了更方便的过滤数据的方式。其一般格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VALUES(?变量名1 [?变量名2 ...])</span><br><span class="line">&#123;</span><br><span class="line">    （变量名1应取值 [?变量名2应取值 ...]）</span><br><span class="line">    （变量名1应取值 [?变量名2应取值 ...]）</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"># 当条件仅有一个变量时，小括号可以省略</span><br></pre></td></tr></table></figure><p>将 <code>VALUES</code> 子句放在 <code>WHERE</code> 条件中，就可以筛选出变量名满足指定取值的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex498.rq</span><br><span class="line"></span><br><span class="line">PREFIX e: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;expenses#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?description ?date ?amount</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?meal e:description ?description ;</span><br><span class="line">        e:date ?date ;</span><br><span class="line">        e:amount ?amount . </span><br><span class="line"></span><br><span class="line">  VALUES (?date ?description) &#123;</span><br><span class="line">         (&quot;2011-10-15&quot; &quot;lunch&quot;) </span><br><span class="line">         (&quot;2011-10-16&quot; &quot;dinner&quot;)</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述查询则会从返回结果中过滤出 <strong>2011-10-15 的午饭</strong>和 <strong>2011-10-16 的晚饭</strong>的相关数据。</p><h2 id="undef">UNDEF</h2><p><code>UNDEF</code> 关键词代表任意值。下面一个例子返回结果满足这样的条件：任意时间下满足 <code>?description</code> 为 <code>"lunch"</code>的数据，以及任意 <code>?description</code> 下时间为 <code>"2011-10-16"</code> 的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex500.rq</span><br><span class="line"></span><br><span class="line">PREFIX e: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;expenses#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?description ?date ?amount</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?meal e:description ?description ;</span><br><span class="line">        e:date ?date ;</span><br><span class="line">        e:amount ?amount . </span><br><span class="line"></span><br><span class="line">  VALUES (?date ?description) &#123;</span><br><span class="line">         (UNDEF &quot;lunch&quot;) </span><br><span class="line">         (&quot;2011-10-16&quot; UNDEF) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="service">SERVICE</h2><p>要查询远端的数据，一种方式是直接在 <code>FROM</code> 关键字之后指明 RDF 文件 URI：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex166.rq</span><br><span class="line"></span><br><span class="line">PREFIX dc: &lt;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;elements&#x2F;1.1&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?title</span><br><span class="line">FROM &lt;http:&#x2F;&#x2F;dig.csail.mit.edu&#x2F;2008&#x2F;webdav&#x2F;timbl&#x2F;foaf.rdf&gt;</span><br><span class="line">WHERE &#123; ?s dc:title ?title .&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>FROM &lt;URI&gt;</code> 查询远端的 RDF 序列化文件，我们还可以用 <code>SERVICE</code> 关键字访问远端的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex167.rq</span><br><span class="line"></span><br><span class="line">PREFIX cat:     &lt;http:&#x2F;&#x2F;dbpedia.org&#x2F;resource&#x2F;Category:&gt;</span><br><span class="line">PREFIX skos:    &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2004&#x2F;02&#x2F;skos&#x2F;core#&gt;</span><br><span class="line">PREFIX rdfs:    &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;01&#x2F;rdf-schema#&gt;</span><br><span class="line">PREFIX owl:     &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2002&#x2F;07&#x2F;owl#&gt;</span><br><span class="line">PREFIX foaf:    &lt;http:&#x2F;&#x2F;xmlns.com&#x2F;foaf&#x2F;0.1&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?p ?o </span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  SERVICE &lt;http:&#x2F;&#x2F;DBpedia.org&#x2F;sparql&gt;</span><br><span class="line">  &#123; SELECT ?p ?o </span><br><span class="line">    WHERE &#123; &lt;http:&#x2F;&#x2F;dbpedia.org&#x2F;resource&#x2F;Joseph_Hocking&gt; ?p ?o . &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex170.rq</span><br><span class="line"></span><br><span class="line">PREFIX rdf:  &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns#&gt;</span><br><span class="line">PREFIX rdfs: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;01&#x2F;rdf-schema#&gt;</span><br><span class="line">PREFIX gp:   &lt;http:&#x2F;&#x2F;wifo5-04.informatik.uni-mannheim.de&#x2F;gutendata&#x2F;resource&#x2F;people&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?p ?o </span><br><span class="line">WHERE</span><br><span class="line">&#123; </span><br><span class="line">  SERVICE &lt;http:&#x2F;&#x2F;wifo5-04.informatik.uni-mannheim.de&#x2F;gutendata&#x2F;sparql&gt;</span><br><span class="line">  &#123; gp:Hocking_Joseph ?p ?o . &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>亦可从多个远端数据源联合查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex172.rq</span><br><span class="line"></span><br><span class="line">PREFIX cat:  &lt;http:&#x2F;&#x2F;dbpedia.org&#x2F;resource&#x2F;Category:&gt;</span><br><span class="line">PREFIX foaf: &lt;http:&#x2F;&#x2F;xmlns.com&#x2F;foaf&#x2F;0.1&#x2F;&gt;</span><br><span class="line">PREFIX gp:   &lt;http:&#x2F;&#x2F;wifo5-04.informatik.uni-mannheim.de&#x2F;gutendata&#x2F;resource&#x2F;people&#x2F;&gt;</span><br><span class="line">PREFIX owl:  &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2002&#x2F;07&#x2F;owl#&gt;</span><br><span class="line">PREFIX rdf:  &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns#&gt;</span><br><span class="line">PREFIX rdfs: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;01&#x2F;rdf-schema#&gt;</span><br><span class="line">PREFIX skos: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2004&#x2F;02&#x2F;skos&#x2F;core#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?dbpProperty ?dbpValue ?gutenProperty ?gutenValue </span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  SERVICE &lt;http:&#x2F;&#x2F;DBpedia.org&#x2F;sparql&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    &lt;http:&#x2F;&#x2F;dbpedia.org&#x2F;resource&#x2F;Joseph_Hocking&gt; ?dbpProperty ?dbpValue .</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SERVICE &lt;http:&#x2F;&#x2F;wifo5-04.informatik.uni-mannheim.de&#x2F;gutendata&#x2F;sparql&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    gp:Hocking_Joseph ?gutenProperty ?gutenValue . </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>注意：由于<code>SERVICE</code> 方式的远端查询在服务器端执行， <code>SERVICE</code> 后的 URI 应是远端 SPARQL 执行入口。</p></div><h1 id="常见函数">常见函数</h1><h2 id="maxminavgsumcount">MAX()、MIN()、AVG()、SUM()、COUNT()</h2><p>这些聚集函数与 SQL 中类似，不再赘述。</p><h1 id="总结">总结</h1><p>本文主要介绍了 SPARQL 语言的功能和基本语法，要点如下：</p><ul><li>在 SPARQL 语句中，通常以 <code>？变量名</code> 表示变量；而常量一般为字符串、数字及 URI，其中 URI 由尖括号（&lt; &gt;）包裹。</li><li>SPARQL 中使用了多种标点符号，具有丰富的含义。</li><li>SPARQL 支持多种关键词查询数据。这些关键词包括 <code>SELECT</code> 、<code>CONSTRUCT</code> 、<code>DESCRIBE</code> 、 <code>ASK</code> 。</li><li>SPARQL 提供了很多关键字，能够表达复杂的查询任务。</li><li>SPARQL 支持许多强大的函数，提高了其易用性。</li></ul><h1 id="参考资料">参考资料</h1><ul><li>Bob DuCharme. <a href="http://learningsparql.com/" target="_blank" rel="noopener">Learning SPARQL: querying and updating with SPARQL 1.1</a></li><li><a href="https://www.w3.org/TR/sparql11-query/" target="_blank" rel="noopener">SPARQL 1.1 Query Language W3C Recommendation</a>.</li></ul><h1 id="推荐阅读">推荐阅读</h1><ul><li><a href="https://www.dataversity.net/introduction-to-sparql/" target="_blank" rel="noopener">Introduction to: SPARQL</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文将简要介绍 SPARQL 的基本语法
    
    </summary>
    
    
      <category term="研究" scheme="https://cosmosning.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="SPARQL" scheme="https://cosmosning.github.io/tags/SPARQL/"/>
    
      <category term="图数据库查询语言" scheme="https://cosmosning.github.io/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>RDF简介</title>
    <link href="https://cosmosning.github.io/2020/07/21/intro-to-rdf/"/>
    <id>https://cosmosning.github.io/2020/07/21/intro-to-rdf/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-07-21T13:44:26.000Z</published>
    <updated>2020-11-12T01:07:59.780Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习图数据库的基础知识。本文将参考 《<a href="http://learningsparql.com/" target="_blank" rel="noopener">Learning SPARQL: querying and updating with SPARQL 1.1</a>》这本书，简单介绍图数据的数据模型 RDF。主要内容如下：</p><ol type="1"><li>RDF 简介</li><li>RDF 三元组</li><li>RDF 存储格式</li><li>RDF 其他概念</li></ol></blockquote><h1 id="rdf-简介">RDF 简介</h1><p>RDF 全称 Resource Description Framework（资源描述框架），是一种数据模型，它提供了一种独特的结构来存储数据文件。RDF 独特的结构使其在 Semantic Web、图数据库等领域应用十分广泛。</p><h1 id="基本格式">基本格式</h1><p>在 RDF 中，每一个基本单元可由一个三元组 <span class="math inline">\((s,\ p,\ o)\)</span> 构成，其中 <span class="math inline">\(s\)</span> 代表 subject（主语），<span class="math inline">\(p\)</span> 代表 predicate（谓语）， <span class="math inline">\(o\)</span> 代表 object（宾语）。每一个三元组都可以陈述这样一个事实：一个由 <span class="math inline">\(s\)</span> 唯一标记的资源实体拥有 <span class="math inline">\(p\)</span> 属性，其属性值为 <span class="math inline">\(o\)</span> 。</p><p>每一个三元组都可以通过图（graph）来表示，具体如下图：</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/triple.png" alt="三元组图示" /><figcaption>三元组图示</figcaption></figure><h1 id="存储方式及其结构">存储方式及其结构</h1><h2 id="文件存储序列化">文件存储（序列化）</h2><p>当数据以文件的形式存储时，RDF 有如下几种序列化格式</p><h3 id="rdfxml">RDF/XML</h3><p>RDF/XML 是最古老的格式，最初出现在 1999 年 RDF 规格说明中。顾名思义，这种方式采取了与 XML 类似的结构存储数据单元（也就是一个三元组）。一个简单的例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 本例来自书籍《Learning SPARQL》，详见参考资料（下同） --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Being XML, RDF/XML uses regular XML comment delimiters. --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- filename: ex029.rdf --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rdf:RDF</span> <span class="attr">xmlns:rdf</span>=<span class="string">"http://www.w3.org/1999/02/22-rdf-syntax-ns#"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:dc</span>=<span class="string">"http://purl.org/dc/elements/1.1/"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:v</span>=<span class="string">"http://www.w3.org/2006/vcard/"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">rdf:Description</span> <span class="attr">rdf:about</span>=<span class="string">"urn:isbn:006251587X"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dc:title</span>&gt;</span>Weaving the Web<span class="tag">&lt;/<span class="name">dc:title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dc:creator</span> <span class="attr">rdf:resource</span>=<span class="string">"http://www.w3.org/People/Berners-Lee/card#i"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rdf:Description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">rdf:Description</span> <span class="attr">rdf:about</span>=<span class="string">"http://www.w3.org/People/Berners-Lee/card#i"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">v:title</span>&gt;</span>Director<span class="tag">&lt;/<span class="name">v:title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rdf:Description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">rdf:RDF</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 RDF/XML 格式存储时，其文件后缀名为 <code>.rdf</code>。文件中，所有数据由<code>&lt;rdf:RDF&gt;</code> 和 <code>&lt;/rdf:RDF&gt;</code> 包裹，并且在 <code>&lt;rdf:RDF&gt;</code> 属性中定义了前缀（prefix）。</p><div class="note info"><p class="note-title">前缀 prefix</p><p>RDF 是在 Semantic Web 的背景下提出的，而 Semantic Web 要求在全网下能够唯一标识一个资源，故其采用了 <code>URI</code> 作为资源的唯一标记。<code>URI</code> 一般较为冗长，而定义前缀 ，可以减少数据单元中冗长的书写，从而突出数据的重点；当处于不同的前缀中时，数据资源也不会因同名而相互冲突。由于第二点的优势， 前缀又被称作名称空间（namespace）。</p></div><p>每一个数据单元的主语为 <code>rdf:Description</code> 中 <code>rdf:about</code> 属性的值；<code>rdf:Description</code> 子结点标签则代表了数据单元的谓语；宾语可以是 <code>rdf:Description</code> 子结点标签中的纯文字，也可以是子结点标签 <code>rdf:resource</code> 属性所设定的 URI 值。</p><p>由于 XML 受限的表达性、RDF/XML 数据文件解析困难等原因，RDF/XML 并没有流行开来。</p><h3 id="n3">N3</h3><p>N3 是 Notation 3 的缩写，它是 RDF 序列化的另一种格式。这种格式继承了 RDF/XML 的优势，尝试改进并弥补了 RDF/XML 部分不足。下面是一个用 N3 格式存储的 RDF 数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># The hash symbol is the comment delimiter in n3. </span><br><span class="line"># filename: ex031.n3</span><br><span class="line"></span><br><span class="line">@prefix dc: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">purl.org</span>/<span class="attr">dc</span>/<span class="attr">elements</span>/<span class="attr">1.1</span>/&gt;</span> .</span><br><span class="line">@prefix v:  <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2006</span>/<span class="attr">vcard</span>/&gt;</span> .</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">People</span>/<span class="attr">Berners-Lee</span>/<span class="attr">card</span>#<span class="attr">i</span>&gt;</span></span><br><span class="line">      v:title "Director" .</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">urn:isbn:006251587X</span>&gt;</span></span><br><span class="line">      dc:creator <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">People</span>/<span class="attr">Berners-Lee</span>/<span class="attr">card</span>#<span class="attr">i</span>&gt;</span> ;</span><br><span class="line">      dc:title "Weaving the Web" .</span><br></pre></td></tr></table></figure><p>通过 N3 格式存储时，其文件后缀名为 <code>.n3</code>。与 RDF/XML 格式类似，N3 使用三元组来声明前缀。这个三元组中， <code>@prefix</code> 为主语，<code>&lt;prefix name&gt;:</code> 为谓语，<code>&lt;uri&gt;</code> 则为宾语，并且用英文句号作为三元组的结束标记。在声明完前缀之后，便可以接着以三元组的形式存储数据。例如，第 8 至 9 行为一个三元组，其主语为 <code>&lt;http://www.w3.org/People/Berners-Lee/card#i&gt;</code>，谓语为 <code>v:title</code>，宾语为 <code>"Director"</code>。该三元组说明，由主语标识的资源（此例为人）的头衔为 Director。第 11 至 13 行为第 2 、3 个三元组，分别表示由 <code>&lt;urn:isbn:006251587X&gt;</code> 所标识的书籍的作者是 <code>&lt;http://www.w3.org/People/Berners-Lee/card#i&gt;</code> 这个人；这本书的书名为 <code>"Weaving the Web"</code> 。</p><div class="note info"><p class="note-title">N3中的 <code>.</code>、<code>;</code>、<code>,</code></p><ul><li><code>.</code> 代表三元组的结束</li><li><code>;</code> 代表下一个三元组与当前三元组拥有<strong>相同的主语</strong></li><li><code>,</code> 代表下一个三元组与当前三元组拥有<strong>相同的主语和谓语</strong></li></ul></div><h3 id="turtle">Turtle</h3><p>Turtle 是另一种 RDF 序列化的格式，并且使用十分广泛。下面是一个例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex002.ttl</span><br><span class="line"></span><br><span class="line">@prefix ab: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">addressbook</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">ab:richard ab:homeTel "(229) 276-5135" . </span><br><span class="line">ab:richard ab:email   "richard49@hotmail.com" . </span><br><span class="line"></span><br><span class="line">ab:cindy ab:homeTel "(245) 646-5488" . </span><br><span class="line">ab:cindy ab:email   "cindym@gmail.com" . </span><br><span class="line"></span><br><span class="line">ab:craig ab:homeTel "(194) 966-1505" . </span><br><span class="line">ab:craig ab:email   "craigellis@yahoo.com" . </span><br><span class="line">ab:craig ab:email   "c.ellis@usairwaysgroup.com" .</span><br></pre></td></tr></table></figure><p>Turtle 格式与 N3 很类似，这里不再介绍。</p><h3 id="rdfa">RDFa</h3><p>RDFa 是另一个受到用户们喜爱的 RDF 序列化格式。RDFa 不仅仅能以 XML 的格式存储，更强大的是其也能嵌入到 HTML 文件中。这使得 SPARQL 等查询工具能够轻松地从中获得以三元组形式存储的数据。下面展示了一个具体的<a href="https://www.dataversity.net/introduction-to-rdfa-2/" target="_blank" rel="noopener">例子</a>：</p><p>如果你有一个 HTML 文件，其中有下面一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">My name is Juan Sequeda. Please visit my homepage!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果将 RDFa 嵌入其中，那么可以这么写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">vocab</span>=<span class="string">"http://schema.org/"</span> <span class="attr">typeof</span>=<span class="string">"Person"</span>&gt;</span></span><br><span class="line">My name is</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">property</span>=<span class="string">"name"</span>&gt;</span>Juan Sequeda<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.</span><br><span class="line">Please visit</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">property</span>=<span class="string">"url"</span> <span class="attr">href</span>=<span class="string">"http://www.juansequeda.org/"</span>&gt;</span>my homepage<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数据库存储">数据库存储</h2><p>除了文件序列化存储方式，RDF 数据亦可存储在数据库中。数据库中 RDF 的存储结构通常由数据库管理系统决定。这里先搁置一边。</p><h1 id="其他概念">其他概念</h1><h2 id="数据类型">数据类型</h2><p>根据上一节的例子，我们发现 RDF 中主要有两类数据，一类为 URI ，另一类为字符串。尽管很多处理 RDF 数据的工具能够根据字符串数据推测数据类型，但仍然建议你在数据中指明各个数据的类型。</p><div class="note info"><p class="note-title">没有双引号的字符串的类型推断</p><p>当你省略了字符串的双引号，那么处理 RDF 数据的工具将认为该数据类型要么是布尔量（真或假），要么是数字。</p></div><p>在 Turtle 格式中，在数据后面加上两个脱字符（<code>^</code>），并指明标定数据类型的 URI（可使用前缀缩写表示，也可以使用完整的 URI 表示），就可以手动指定数据类型。具体的例子如下（第 7 至 10 行）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex033.ttl</span><br><span class="line"></span><br><span class="line">@prefix xsd: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2001</span>/<span class="attr">XMLSchema</span>#&gt;</span> .</span><br><span class="line">@prefix d:   <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">data</span>#&gt;</span> .</span><br><span class="line">@prefix dm:  <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">demo</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">d:item342 dm:shipped     "2011-02-14"^^<span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2001</span>/<span class="attr">XMLSchema</span>#<span class="attr">date</span>&gt;</span> . </span><br><span class="line">d:item342 dm:quantity    "4"^^xsd:integer . </span><br><span class="line">d:item342 dm:invoiced    "false"^^xsd:boolean . </span><br><span class="line">d:item342 dm:costPerItem "3.50"^^xsd:decimal .</span><br></pre></td></tr></table></figure><p>在 RDF/XML 格式中，数据类型由数据标签中 <code>rdf:datatype</code> 属性值所确定（第 8 至 15 行）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- filename: ex035.rdf --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rdf:RDF</span> <span class="attr">xmlns:rdf</span>=<span class="string">"http://www.w3.org/1999/02/22-rdf-syntax-ns#"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:dm</span>=<span class="string">"http://learningsparql.com/ns/demo#"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema#"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">rdf:Description</span> <span class="attr">rdf:about</span>=<span class="string">"http://learningsparql.com/ns/demo#item342"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dm:shipped</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">rdf:datatype</span>=<span class="string">"http://www.w3.org/2001/XMLSchema#date"</span>&gt;</span>2011-02-14<span class="tag">&lt;/<span class="name">dm:shipped</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dm:quantity</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">rdf:datatype</span>=<span class="string">"http://www.w3.org/2001/XMLSchema#integer"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">dm:quantity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dm:invoiced</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">rdf:datatype</span>=<span class="string">"http://www.w3.org/2001/XMLSchema#boolean"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">dm:invoiced</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dm:costPerItem</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">rdf:datatype</span>=<span class="string">"http://www.w3.org/2001/XMLSchema#decimal"</span>&gt;</span>3.50<span class="tag">&lt;/<span class="name">dm:costPerItem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rdf:Description</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">rdf:RDF</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="语言标记标签">语言标记、标签</h2><h3 id="lang"><span class="citation" data-cites="lang">@lang</span></h3><p>RDF 支持国际化，即对于同一个数据，有针对不同语言的不同表示。其一般格式为<code>数据@语言缩写</code>（语言缩写参考了 ISO 639 以及 ISO 3166-1）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex037.ttl</span><br><span class="line"></span><br><span class="line">@prefix :     <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">demo</span>#&gt;</span> . </span><br><span class="line">@prefix rdfs: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2000</span>/<span class="attr">01</span>/<span class="attr">rdf-schema</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">:sideDish42 rdfs:label "french fries"@en-US . </span><br><span class="line">:sideDish42 rdfs:label "chips"@en-GB . </span><br><span class="line"></span><br><span class="line">:sideDish43 rdfs:label "chips"@en-US . </span><br><span class="line">:sideDish43 rdfs:label "crisps"@en-GB .</span><br></pre></td></tr></table></figure><h3 id="rdfslabelrdfscomment">rdfs:label、rdfs:comment</h3><p><code>rdfs:label</code>、<code>rdfs:comment</code> 是 RDF 中非常重要的两个属性名。<code>rdfs:label</code> 通常用来以方便人阅读的名称指代资源，<code>rdfs:comment</code> 通常用来更细节地描述资源。这两个属性值会加深我们对相关资源的理解。</p><div class="note info"><p>P.S. 在 W3C SKOS 标准下，有两个相关的属性，分别是 <code>skos:prefLabel</code>（代表偏好标签） 和 <code>skos:altLabel</code>（代表替代标签）。</p></div><h2 id="空结点及其作用">空结点及其作用</h2><p>在实际情况下，有很多数据是复合数据，即该数据可以分解为更小的数据项（小数据项并不可再分）。例如，地址信息就可以分解为国家、省份、城市、区县、街道、邮编等数据项。那么，如何在 RDF 中表示这样的数据呢？这就需要引入一个独特的结点——空结点。</p><p>具体的，空结点将作为联系复合数据属性与各个小数据项之间的桥梁：一是作为复合数据属性（谓语）的属性值（宾语），二是作为小数据项谓语的主语。举个书上的例子你就能理解了（其中 <code>_:b1</code> 为空结点）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex041.ttl</span><br><span class="line"></span><br><span class="line">@prefix ab: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">addressbook</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">ab:i0432 ab:firstName    "Richard" ;</span><br><span class="line">        ab:lastName      "Mutt" ;</span><br><span class="line">        ab:homeTel       "(229) 276-5135" ;</span><br><span class="line">        ab:email         "richard49@hotmail.com" ;</span><br><span class="line">        ab:address       _:b1 .</span><br><span class="line"></span><br><span class="line">_:b1    ab:postalCode    "49345" ;</span><br><span class="line">        ab:city          "Springfield" ;</span><br><span class="line">        ab:streetAddress "32 Main St." ;</span><br><span class="line">        ab:region        "Connecticut" .</span><br></pre></td></tr></table></figure><p>由此可知，空结点的一般格式为 <code>_:&lt;空结点名称&gt;</code></p><div class="note info"><p>有时，Turtle 和 SPARQL 也使用方括号（<code>[]</code>）代表空结点。</p></div><h2 id="named-graphs">Named Graphs</h2><p>和空结点类似，Named Graphs 也可以用来将一些相关的三元组组合在一起。而与之不同的是，Named Graphs 更加强大——可进一步赋予其元数据（metadata）。这种特性使得 Named Graphs 在某些应用场景下有着独特的优势。</p><h2 id="rdf-模式和-owl">RDF 模式和 OWL</h2><p>在程序设计中，经常会考虑复用问题，因为复用可以有效提高软件开发效率。十分幸运，RDF 也提供了复用方案，即 RDF 模式和 OWL（Web Ontological Language）。</p><p>RDF 模式使用一系列三元组描述了有关该类资源的事实（如指明 <code>rdf:type</code>、 <code>rdfs:label</code> 、<code>rdf:comment</code> 等）。这些事实也被称为该类资源的元数据。</p><p>下面是两个具体的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex042.ttl</span><br><span class="line"></span><br><span class="line">@prefix dc:   <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">purl.org</span>/<span class="attr">dc</span>/<span class="attr">elements</span>/<span class="attr">1.1</span>/&gt;</span> .</span><br><span class="line">@prefix rdf:  <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">1999</span>/<span class="attr">02</span>/<span class="attr">22-rdf-syntax-ns</span>#&gt;</span> .</span><br><span class="line">@prefix rdfs: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2000</span>/<span class="attr">01</span>/<span class="attr">rdf-schema</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">dc:creator</span><br><span class="line">      rdf:type rdf:Property ;     </span><br><span class="line">      # a rdf:Property ;</span><br><span class="line">      rdfs:comment "An entity primarily responsible for making the resource."@en-US ;</span><br><span class="line">      rdfs:label "Creator"@en-US .</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex043.ttl</span><br><span class="line"></span><br><span class="line">@prefix ab:   <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">addressbook</span>#&gt;</span> .</span><br><span class="line">@prefix rdf:  <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">1999</span>/<span class="attr">02</span>/<span class="attr">22-rdf-syntax-ns</span>#&gt;</span> .</span><br><span class="line">@prefix rdfs: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2000</span>/<span class="attr">01</span>/<span class="attr">rdf-schema</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">ab:Musician</span><br><span class="line">      rdf:type rdfs:Class ;</span><br><span class="line">      rdfs:label "Musician" ;</span><br><span class="line">      rdfs:comment "Someone who plays a musical instrument" .</span><br><span class="line"></span><br><span class="line">ab:MusicalInstrument</span><br><span class="line">      a rdfs:Class ;</span><br><span class="line">      rdfs:label "musical instrument" .</span><br></pre></td></tr></table></figure><p>在元数据中，有两个非常特殊的属性 <code>rdfs:domain</code> 和 <code>rdfs:range</code> ：</p><ul><li><code>rdfs:domain</code> ：<strong>该属性的值是 <code>rdfs:domain</code> 所在三元组主语的类别</strong></li><li><code>rdfs:range</code> ：<strong>该属性的值是 <code>rdfs:range</code> 所在三元组宾语的类别</strong></li></ul><p>依照这样的关系，在 RDF 中，我们能推理出很多隐藏在图中的结论。</p><div class="note info no-icon"><p class="note-title">面向对象 V.S. RDF 模式</p><ul><li>在面向对象系统中，需要实例化一个类，生成一个对象，并将具体的值赋给这个对象。</li><li>在基于 RDF 的标准下，为资源的元数据添加一个属性，就有可能使得该资源属于某一个之前未属于的类别。</li></ul></div><p>然而，RDF 模式还是有限的，它无法描述类之间的联系。要解决这个问题，便引入了 OWL。</p><p>下面，我将结合书上的例子说明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># filename: ex046.ttl</span><br><span class="line"></span><br><span class="line">@prefix ab:   <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">addressbook</span>#&gt;</span> .</span><br><span class="line">@prefix rdf:  <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">1999</span>/<span class="attr">02</span>/<span class="attr">22-rdf-syntax-ns</span>#&gt;</span> .</span><br><span class="line">@prefix rdfs: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2000</span>/<span class="attr">01</span>/<span class="attr">rdf-schema</span>#&gt;</span> .</span><br><span class="line">@prefix owl:  <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2002</span>/<span class="attr">07</span>/<span class="attr">owl</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">ab:i0432  </span><br><span class="line">   ab:firstName "Richard" ;</span><br><span class="line">   ab:lastName  "Mutt" ;</span><br><span class="line">   ab:spouse    ab:i9771 . </span><br><span class="line"></span><br><span class="line">ab:i8301  </span><br><span class="line">   ab:firstName "Craig" ;</span><br><span class="line">   ab:lastName  "Ellis" ;</span><br><span class="line">   ab:patient   ab:i9771 . </span><br><span class="line"></span><br><span class="line">ab:i9771</span><br><span class="line">   ab:firstName "Cindy" ; </span><br><span class="line">   ab:lastName  "Marshall" .  </span><br><span class="line"></span><br><span class="line">ab:spouse</span><br><span class="line">   rdf:type owl:SymmetricProperty ; </span><br><span class="line">   rdfs:comment "Identifies someone's spouse" .</span><br><span class="line"></span><br><span class="line">ab:patient </span><br><span class="line">   rdf:type rdf:Property ;</span><br><span class="line">   rdfs:comment "Identifies a doctor's patient" . </span><br><span class="line"></span><br><span class="line">ab:doctor </span><br><span class="line">   rdf:type rdf:Property ;</span><br><span class="line">   rdfs:comment "Identifies a doctor treating the named resource" ;</span><br><span class="line">   owl:inverseOf ab:patient .</span><br></pre></td></tr></table></figure><p>其中，<code>ab:spouse</code> 的 <code>rdf:type</code> 为 <code>SymmetricProperty</code> ，表示这个属性是对称的。在本例中，ab:i0432 的配偶是 ab:i9771 ，那么根据对称属性的性质推理，我们可以得到，ab:i9771 的配偶则是 ab:i0432 。又如，<code>ab:doctor</code> 的 <code>owl:inverseOf</code> 的值为 <code>ab:patient</code>，则在本例中，由于 ab:i8301 有一位病人 ab:i9771，则 ab:i9771 有一位医生 ab:i8301。</p><h1 id="总结">总结</h1><p>本文主要介绍了有关 RDF 的基本概念、格式、存储结构和其他一些细节。最后，对全文做一个简单的总结。</p><ul><li>RDF 全称 Resource Description Framework（资源描述框架），是一种数据模型，它提供了一种独特的结构来存储数据文件。</li><li>RDF 数据单元是一个三元组 <span class="math inline">\((s,\ p,\ o)\)</span> ，其中 <span class="math inline">\(s\)</span> 代表 subject（主语），<span class="math inline">\(p\)</span> 代表 predicate（谓语）， <span class="math inline">\(o\)</span> 代表 object（宾语）。每一个三元组都可以陈述这样一个事实：一个由 <span class="math inline">\(s\)</span> 唯一标记的资源实体拥有 <span class="math inline">\(p\)</span> 属性，其属性值为 <span class="math inline">\(o\)</span> 。</li><li>RDF 数据的存储主要有两种：文件序列化存储（包括 RDF/XML、Turtle、RDFa 等格式）、数据库存储。</li><li>RDF 中的数据类型指定一般可表示为 <code>数据^^&lt;数据类型URI&gt;</code> 。</li><li>RDF 支持国际化，一般格式为<code>数据@语言缩写</code>。</li><li><code>rdfs:label</code>、<code>rdfs:comment</code> 是 RDF 中非常重要的两个属性名。<code>rdfs:label</code> 通常用来以方便人阅读的名称指代资源，<code>rdfs:comment</code> 通常用来更细节地描述资源。</li><li>RDF 中，空结点可用来连接数据。</li><li>Named Graphs 可用于组合三元组数据，并可赋予一些元数据。</li><li>RDF 模式和 OWL 可用于 RDF 资源、属性的复用。RDF 模式中可定义类、属性的事实元数据，并提供给外界使用，达到复用的目的；OWL 则扩展了 RDF 模式的表达性，从而支持描述类之间的关系。</li></ul><h1 id="参考资料">参考资料</h1><ul><li>Bob DuCharme. <a href="http://learningsparql.com/" target="_blank" rel="noopener">Learning SPARQL: querying and updating with SPARQL 1.1</a></li><li>Juan Sequeda. <a href="https://www.dataversity.net/introduction-to-rdfa-2/" target="_blank" rel="noopener">Introduction to: RDFa</a>.</li><li>Juan Sequeda. <a href="https://www.dataversity.net/introduction-to-ontologies/" target="_blank" rel="noopener">Introduction to: Ontologies</a>.</li></ul><h1 id="拓展阅读">拓展阅读</h1><ul><li><a href="https://www.w3.org/TR/rdf-primer/" target="_blank" rel="noopener">W3C RDF Primer</a></li><li><a href="https://www.dataversity.net/introduction-to-rdf-vs-xml/" target="_blank" rel="noopener">Introduction to: RDF vs XML</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文主要介绍 RDF 的基本概念
    
    </summary>
    
    
      <category term="研究" scheme="https://cosmosning.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="RDF" scheme="https://cosmosning.github.io/tags/RDF/"/>
    
      <category term="数据模型" scheme="https://cosmosning.github.io/tags/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
</feed>
