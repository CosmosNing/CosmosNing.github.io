<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CosmosNing的个人博客</title>
  <link rel="alternate" type="text/html" href="https://cosmosning.github.io"/>
  <link rel="self" type="application/atom+xml" href="/atom.xml"/>
  
  <updated>2023-06-02T11:13:14.774Z</updated>
  <id>https://cosmosning.github.io/</id>
  <icon>https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/avatar-32.ico</icon>
  <subtitle>探索·好奇</subtitle>
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git基础命令总结</title>
    <link href="https://cosmosning.github.io/2023/06/02/summary-of-basic-git-commands/"/>
    <id>https://cosmosning.github.io/2023/06/02/summary-of-basic-git-commands/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2023-06-02T08:01:54.000Z</published>
    <updated>2023-06-02T11:13:14.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-基础命令总结">Git 基础命令总结</h1><h2 id="总结图示">总结图示</h2><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2023/06/02/git_cmd.svg"alt="Git基础命令总结图示" /><figcaption aria-hidden="true">Git基础命令总结图示</figcaption></figure><h3 id="核心概念">核心概念</h3><ul><li>工作区：即当前仓库目录下的所有文件所在的区域</li><li>暂存区：<code>git add</code>命令执行后，修改文件暂时所在的区域（等待后续<code>git commit</code>命令统一提交）</li><li>本地仓库：<code>git commit</code>命令执行后，提交文件所在的区域</li><li>远端仓库：与本地仓库关联；通过<code>git push</code>可将本地提交同步至远端。</li></ul><h3 id="核心操作流">核心操作流</h3><p>Git的核心操作流为：<code>git add</code> <spanclass="math inline">\(\rightarrow\)</span> <code>git commit</code> <spanclass="math inline">\(\rightarrow\)</span><code>git push</code>，其中，</p><ul><li><code>git add</code>将修改的文件加入到暂存区；</li><li><code>git commit</code> 将暂存区的修改提交至本地仓库；</li><li><code>git push</code>将本地仓库的提交推送到远端仓库。</li></ul><p>另外，记住在<code>git add</code>与<code>git commit</code>之前，记住执行<code>git pull</code>，从远端拉取最新代码，并解决潜在的冲突。</p><h3 id="不同区域的撤销操作">不同区域的撤销操作</h3><p>一条常规的修改提交操作流是 <code>git add</code> <spanclass="math inline">\(\rightarrow\)</span> <code>git commit</code> <spanclass="math inline">\(\rightarrow\)</span><code>git push</code>。但是如果在其中某一步，我们需要撤销相应的操作，该怎么办呢？Git提供了如下命令，在不同区域实现撤销操作：</p><ul><li>对于已纳入Git管理的文件，如果要丢弃工作区中的修改，可使用：<ul><li><code>git restore &lt;file&gt;</code></li><li><code>git checkout -- &lt;file&gt;</code></li></ul></li><li>对于已经被<code>git add</code>命令加入暂存区的文件，可使用：<ul><li><code>git restore --staged &lt;file&gt;</code>将暂存区的相应文件放回工作区，并保持修改不改变</li><li><code>git reset HEAD &lt;file&gt;</code>（同上）</li></ul></li><li>对于已经被 <code>git commit</code> 命令提交至本地仓库，可使用：<ul><li><code>git reset --soft &lt;commit id&gt;</code>将提交头节点（HEAD）移动到指定commitid，<strong>并将修改保留在暂存区</strong>。</li><li><code>git reset --mixed &lt;commit id&gt;</code>将提交头节点（HEAD）移动到指定commitid，<strong>并将修改保留在工作区</strong>。</li><li><code>git reset --hard &lt;commit id&gt;</code>将提交头节点（HEAD）移动到指定commitid，<strong>不保留任何修改</strong>（如果修改包含新文件的提交，那么这个新文件将被删除。<strong>请慎用</strong>）。</li></ul></li><li>对于已经被<code>git push</code>到远端仓库，没有相应的一条命令实现，但是可采用如下方法：<ul><li>首先，通过<code>git reset</code> 命令将提交头节点移动到指定提交</li><li>再通过 <code>git push -f</code> 强制更新远端</li><li>最后再修改本地仓库文件，进行 <code>git add</code> <spanclass="math inline">\(\rightarrow\)</span> <code>git commit</code> <spanclass="math inline">\(\rightarrow\)</span><code>git push</code>操作。</li></ul></li></ul><h2 id="参考">参考</h2><ul><li><a href="https://www.jianshu.com/p/c6927e80a01d" target="_blank" rel="noopener">git reset--soft,--hard的区别</a></li><li><a href="https://juejin.cn/post/7130883174472630286" target="_blank" rel="noopener">gitrestore指令和git restore --staged 的使用)</a></li><li><ahref="https://blog.csdn.net/hanchao5272/article/details/79435730">Git撤销已经推送(push)至远端仓库的提交(commit)信息</a></li></ul><h2 id="推荐阅读">推荐阅读</h2><ul><li><a href="/2019/12/30/git-ji-chu-ru-men/">Git 基础入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      总结常用的Git命令及其用法
    
    </summary>
    
    
      <category term="笔记" scheme="https://cosmosning.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://cosmosning.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Logseq：开源优雅的知识管理工具</title>
    <link href="https://cosmosning.github.io/2020/12/06/review-of-logseq/"/>
    <id>https://cosmosning.github.io/2020/12/06/review-of-logseq/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-12-06T06:29:14.000Z</published>
    <updated>2023-06-02T11:13:14.774Z</updated>
    
    <content type="html"><![CDATA[<figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/12/altumcode-GVASc0_Aam0-unsplash.jpg"alt="题图" /><figcaption aria-hidden="true">题图</figcaption></figure><h1 id="前言">前言</h1><p>笔记，对于我个人来说，是一个非常重要的整理与回顾知识的工具。找到适合自己的笔记载体，将会极大地提高的效率。为追求最佳效率，我尝试过多种方式，从手写到电子，从文档到导图。它们各具特色，又难免缺失某种特性而使我最终放弃。</p><h2 id="印象笔记">印象笔记</h2><p>16年，新买的笔记本电脑上预装了印象笔记。当时的印象笔记还仅支持富文本编辑模式。富文本编辑意味着所见即所得，格式可以轻松地点击菜单按钮随时调整。</p><p>但是对于我来说，这就意味着我将要腾出一只手握住鼠标，在需要时调整格式。这其实会降低笔记的效率，因为这种模式下，你不仅仅要关注笔记的内容，而且需时不时地分心调整格式。这与我追求高效的笔记体验背道而驰。</p><p>除此以外，在富文本模式下，公式的输入非常繁琐，这也是我最终放弃印象笔记的原因之一。</p><p>虽然，印象笔记在 18 年开始支持Markdown，但其编辑、预览双屏的设计，对于追求简洁的我太过复杂，也就没有再拾起。</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/12/yinxiang-markdown.png"alt="印象笔记 Markdown 双屏设计" /><figcaption aria-hidden="true">印象笔记 Markdown 双屏设计</figcaption></figure><h2 id="typora">Typora</h2><p>18 年左右，经朋友推荐，了解到 <a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>这款简洁的 Markdown 编辑器，并一直使用至今。</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/12/typora.png"alt="Typora:所见即所得" /><figcaption aria-hidden="true">Typora:所见即所得</figcaption></figure><p>Typora 主要令我喜爱的一点是其“<strong>所见即所得</strong>”的即时Markdown 渲染。该软件只用一屏，既提供了 Markdown的排版功能，又减去了编辑模式下 Markdown 中的影响阅读体验的格式符号。</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/12/fences.png"alt="Typora 代码块" /><figcaption aria-hidden="true">Typora 代码块</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/12/math.png"alt="Typora 数学公式" /><figcaption aria-hidden="true">Typora 数学公式</figcaption></figure><p>然而，Typora只是一个编辑器，只能记录，<strong>难以检索和回顾</strong>。因此，仅靠Typora，难以完成笔记的完整闭环。一种常见的工作流可以勉强解决这个问题，即Typora（编辑）+ Hexo（生成静态博客网页）+ GitHubPages（发布与检索）。然而，笔记的<strong>私密性</strong>和博客的<strong>开放性</strong>的矛盾无法得到有效解决，这使我陷入了两难的境地。</p><h2 id="幕布">幕布</h2><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/12/mubu.png"alt="幕布" /><figcaption aria-hidden="true">幕布</figcaption></figure><p>20年，准备考研复试的专业课时，我开始尝试幕布这个在线笔记软件。对于整理概念性的知识，幕布绝对是一个非常强大的工具。将一门课，一本书化为一个个知识点，并通过层次表达它们的关系，最后还能生成相应的思维导图，这个笔记体验真的是太美妙了。</p><p>美中不足的是，幕布并<strong>不支持公式和代码块的渲染</strong>，这对于有大量公式代码笔记需求的我来说有点遗憾。</p><h2 id="logseq">Logseq</h2><p>最近，在 GitHub 上发现了一款开源笔记应用，<ahref="https://github.com/logseq/logseq">Logseq</a>，个人感觉比较完美的满足了我的几点需求：</p><ol type="1"><li>支持 Markdown，并且所见即所得 ；</li><li>支持公式和代码块渲染；</li><li>保持笔记的私密性。</li></ol><p>下一部分，我将聊一聊我对 Logseq 的使用体验。</p><h1 id="logseq-初体验">Logseq 初体验</h1><h2 id="快速上手">快速上手</h2><p>使用 Logseq 非常简单，只需要你拥有一个浏览器，一个 GitHub账户及笔记仓库。</p><div class="note info"><p>如果要保持你笔记的私密性，你可以创建一个<strong>私有</strong>的GitHub 笔记仓库供 Logseq 存储数据文件。</p></div><p>当你，准备好上述要求，只需访问 <ahref="https://logseq.com/">https://logseq.com/</a> ，并使用 Github登录授权，设置好笔记仓库，就可以开始你的笔记了。</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/12/daily-notes.PNG"alt="Logseq默认界面" /><figcaption aria-hidden="true">Logseq默认界面</figcaption></figure><p>登陆后，Logseq会默认创建一个标题为今天的文件，你可以直接在此开始笔记。如果要创建新的页面，你可以在左上的搜索框输入新页面的文件名，并选择相应的下拉选项，完成创建。</p><h2 id="体验感受">体验感受</h2><p>从我的使用体验来说，Logseq 的手感是十分惊艳的。主要有如下几点：</p><ul><li><strong>快速笔记</strong><ul><li>十分类似于幕布的高效的笔记手感</li></ul></li><li><strong>数据完全属于你</strong><ul><li>Logseq不保存你的任何数据。它在运行过程中，仅仅将你的数据缓存在浏览器的本地缓存中，并与你设定的GitHub 仓库同步。</li></ul></li><li><strong>强大的页面引用、块引用</strong><ul><li>受 <a href="https://roamresearch.com/" target="_blank" rel="noopener">Roam</a> 启发</li><li>这建立了独立的笔记文件之间的联系，更利于笔记整合成知识库。</li></ul></li><li><strong>支持 Markdown，并且所见即所得</strong></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/12/markdown-support.png"alt="Logseq 中 Markdown 支持情况" /><figcaption aria-hidden="true">Logseq 中 Markdown 支持情况</figcaption></figure><ul><li><strong>丰富的命令</strong><ul><li>键入 <code>/</code> （slash键），你会发现一个全新的大陆：可以创建待办事项、插入页面引用或者块引用，甚至还能在其中插入一个画图的页面。</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/12/commands.PNG"alt="Logseq 中的命令" /><figcaption aria-hidden="true">Logseq 中的命令</figcaption></figure><h2 id="使用场景">使用场景</h2><p>在我看来，Logseq 具有非常丰富的使用场景：</p><ul><li><strong>自由写作</strong>：你可以在 Logseq写下任何你思想的火花，供日后整理。</li><li><strong>待办事项</strong>：Logseq提供了比较丰富的待办事项功能，包括创建待办事项，设置事项优先级，设定deadline 和 schedule。</li><li><strong>知识整理</strong>：这也许是 Logseq最核心的使用方式之一。</li><li>...（也许还有更多）</li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/12/deadline-and-schedule.png"alt="Logseq 的 deadline 和 schedule" /><figcaption aria-hidden="true">Logseq 的 deadline 和schedule</figcaption></figure><h1 id="从内联到外联">从内联到外联</h1><p>传统的笔记软件，通常把笔记独立为一个一个文件，关注一个文件内的内在联系，而忽视了不同笔记之间的联系。</p><p>Logseq 受 Roam启发，将不同的笔记文件通过<strong>页面引用</strong>联系起来，从而更好地构建自己的知识网络。</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/12/KG.PNG"alt="Logseq 图谱示例" /><figcaption aria-hidden="true">Logseq 图谱示例</figcaption></figure><p>近期，新版的幕布也上线了 <code>@文件名</code>引用不同的笔记，想必也是受到类似应用的启发。</p><p>由此可见，笔记软件正在从内联走向外联，越来越符合对知识整理的需求。</p><h1 id="不足">不足</h1><p>目前来说，Logseq 还存在许多不足：</p><ul><li>Logseq 还处在快速迭代阶段，很多功能存在不稳定的可能；</li><li>相关的文档稀少，对新手不太友好；</li></ul><p>但我相信，开源社区的支持会使得它更加完善。</p>]]></content>
    
    <summary type="html">
    
      最近，我看到一款非常好用的笔记软件——Logseq，本文主要聊聊我的感受和体验。
    
    </summary>
    
    
      <category term="杂谈" scheme="https://cosmosning.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="工具" scheme="https://cosmosning.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="笔记" scheme="https://cosmosning.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Keyword Search over Knowledge Graphs via Static and Dynamic Hub Labelings 阅读笔记</title>
    <link href="https://cosmosning.github.io/2020/10/08/notes-of-keyword-search-knowledge-2020/"/>
    <id>https://cosmosning.github.io/2020/10/08/notes-of-keyword-search-knowledge-2020/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-10-08T01:35:02.000Z</published>
    <updated>2023-06-02T11:13:14.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="highlights">Highlights</h1><ul><li><strong>Static Hub Labelings</strong></li><li><strong>Dynamic Hub Labelings</strong></li></ul><h1 id="what">What？</h1><h2 id="problem">Problem</h2><p>一种常见的图数据上的关键词查询的方法是，将每一个关键词与图上的一个顶点匹配，并且从中抽取出包含这些匹配顶点的最小权重的树（这种树被称为<em>minimum-weight Steinertrees</em>）。更规范地说，给定一个有权边的数据图和一个关键词查询，首先对于每一个关键词，在图中找到与之匹配的所有顶点，形成一个匹配集；然后，在图中找到一个扩展匹配集的树，该树对于每一个匹配集，至少包含其中的一个顶点，并且总边权重最小。这个优化问题叫做<em>group Steiner tree (GST) problem</em> 。</p><div class="note info"><p>数据图中的边也可以被关键词匹配。我们可以通过 <em>graphsubdivision</em>将边匹配转换为点匹配，之后使用点匹配的方式处理该匹配就行了。</p></div><h2 id="contributions">Contributions</h2><ul><li>设计了一个质量有保证的近似算法，能够在毫秒级内，从百万级大小的知识图谱中返回不错的结果。</li><li>设计了动态、静态 HL，提高了总体的效率。</li></ul><h1 id="why">Why？</h1><p>知识图谱越来越大，现存的算法太慢了。</p><h1 id="how">How？</h1><h2 id="problem-formulation">Problem Formulation</h2><ul><li><strong>知识图谱（<em>KG</em>）</strong>：规范的，知识图谱是一个简单的无向图<span class="math inline">\(G=&lt;V,E&gt;\)</span> ，其中 <spanclass="math inline">\(V\)</span> 是包含 <spanclass="math inline">\(n\)</span>个顶点的有限集合，用来指代实体（<em>entity</em>），而 <spanclass="math inline">\(E\subseteq V\times V\)</span>是顶点无序对的有限集合，作为图的无向边，用来代表实体之间的关系（<em>relation</em>）。<ul><li><strong>边权重</strong>：定义一个权重函数 <spanclass="math inline">\(\textrm{wt}:E\mapsto \mathbb{R}^{0+}\)</span>（<strong>小权重表示重要性大</strong>）。</li></ul></li><li><strong>图中术语</strong><ul><li><span class="math inline">\(\textrm{len}(p)\)</span> ：对于一条路径<span class="math inline">\(p\)</span>，它的<strong>长度</strong>是路径中所有边的权重之和。</li><li><span class="math inline">\(\textrm{dist}(u,v)\)</span> ：在图 <spanclass="math inline">\(G\)</span> 中，连接 <spanclass="math inline">\(u\)</span> 、<spanclass="math inline">\(v\)</span>的<strong>最短路径的长度</strong>。如果不存在，那么为 <spanclass="math inline">\(\infty\)</span> 。</li></ul></li><li><strong>关键词映射</strong>：定义一个获取函数 <spanclass="math inline">\(\textrm{hits}:\mathbb{K}\mapsto 2^V\)</span>，它将关键词映射到顶点集 <span class="math inline">\(V\)</span>的子集。</li><li><strong>关键词查询</strong>：一个<strong>关键词查询</strong> <spanclass="math inline">\(Q\subseteq \mathbb{K}\)</span>是一个关键词的有限集合。<ul><li>给定一个含有 <span class="math inline">\(g\)</span> 个关键词的查询<span class="math inline">\(Q=\{k_1,k_2,\dots,\ k_g\}\)</span> ，将<span class="math inline">\(\textrm{hits}(k_i)\)</span> 简记为 <spanclass="math inline">\(K_i\)</span> （<span class="math inline">\(1\lei\le g\)</span>），并称之为<strong>关键词顶点</strong>。</li><li>给定一个图 <span class="math inline">\(G=&lt;V,E&gt;\)</span> ，在<span class="math inline">\(G\)</span> 上关于 <spanclass="math inline">\(Q\)</span> 的结果是一个 <em>group Steiner tree(GST)</em> ，记作 <span class="math inline">\(T=&lt;V_T,E_T&gt;\)</span>，满足以下条件<ul><li><span class="math inline">\(V_T\subseteq V,E_T\subseteq E\)</span>，并且 <span class="math inline">\(T\)</span> 是一棵树；</li><li><span class="math inline">\(V_T\)</span> 包含来自每一个 <spanclass="math inline">\(K_i\)</span> （<span class="math inline">\(1\lei\le g\)</span>）中的至少一个顶点，也就是 <spanclass="math inline">\(V_T\cap K_i \ne \emptyset\)</span> ；</li><li>树的权重（定义为 <spanclass="math inline">\(\textrm{WT}(T)=\sum_{e\inE_T}\textrm{wt}(e)\)</span>）最小</li></ul></li></ul></li></ul><h2 id="overview-of-two-algorithm">Overview of Two Algorithm</h2><p>第一个算法 <em>KeyKG</em>为每一个关键词选取匹配的顶点，并且找到对应的树。对于 <spanclass="math inline">\(g\)</span> 个关键词，<em>KeyKG</em> 是一个 <spanclass="math inline">\((g-1)\)</span> - 近似算法，也就是说，一个 GST的边权值的总和至多是最小权重的 <spanclass="math inline">\((g-1)\)</span>倍。获得这样的近似效果要归功于匹配顶点集的选择和利用最短路径树的构造。为了更高效的在线计算距离和最短路径，该文章设计了一个HL ，这个 HL 使用了一种全新的基于 <em>betweenness centrality</em>的启发式方法改善了现存的 <em>pruned landmark labeling</em>。传统的，这种 HL是静态的，因为它是离线生成的，并且对查询是不变的。在巨大的知识图谱中，使用静态 HL 的 <em>KeyKG</em>算法至少比目前先进的算法快一个数量级，并且所得结果的质量也较高。</p><p>第二个算法 <em>KeyKG+</em> 通过使用一种新颖的 HL 扩展了<em>KeyKG</em> 算法。这里所提出的 HL是动态的，因为它是在处理一个具体的查询时，通过倒排和聚集某些查询相关的静态标签，而动态生成的。它减少了KeyKG 算法中的重复操作（这些重复操作是指使用传统静态 HL计算顶点集的距离）。尽管在线生成会花费额外的时间，使用动态 HL为总体效率带来了几个数量级的提高。</p><h2 id="keykg-with-static-hl">KeyKG With Static HL</h2><h3 id="algorithm-keykg">Algorithm KeyKG</h3><h4 id="algorithm-explained">Algorithm Explained</h4><p>如下图<strong>算法 1</strong> 所示，<em>KeyKG</em>在知识图谱中找到一个 <em>GST</em> ，这个 <em>GST</em> 是由 <spanclass="math inline">\(g\)</span> 个关键词集合扩展而来。简而言之，<em>KeyKG</em> 首先贪婪地选择一组相互靠近的一组关键词顶点集合（记作<spanclass="math inline">\(U_x\)</span>），这组关键词顶点集合包含了来自每一个<span class="math inline">\(K_i\)</span> （<spanclass="math inline">\(1\le i\le g\)</span>）中的一个顶点（<strong>Line 1- 8</strong>）。然后，<em>KeyKG</em> 贪婪地找到一个由 <spanclass="math inline">\(U_x\)</span> 扩展而来的 <em>GST</em> （记作 <spanclass="math inline">\(T_{u_{min}}\)</span>），这个过程是通过迭代地扩展最短路径而得到的（<strong>Line9 - 18</strong>）。</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/10/Algo1.PNG"alt="算法 1" /><figcaption aria-hidden="true">算法 1</figcaption></figure><p>具体的，对于每一个 <span class="math inline">\(v_1 \in K_1\)</span>（<strong>Line 1</strong>），<em>KeyKG</em> 从每一个 <spanclass="math inline">\(K_i\)</span> 找到一个顶点 <spanclass="math inline">\(v_i\)</span> ，它距离 <spanclass="math inline">\(v_1\)</span> 的距离最短（<strong>Line 2 -4</strong>）。令 <span class="math inline">\(U_{v_1}\)</span>为所有这样的顶点 <span class="math inline">\(v_i\)</span> （包括 <spanclass="math inline">\(v_1\)</span>）的的集合，并且令 <spanclass="math inline">\(W_{v_1}\)</span> 为它们到 <spanclass="math inline">\(v_1\)</span> 的距离之和（<strong>Line 5 -6</strong>）。令 <span class="math inline">\(x\in K_1\)</span> 为 <spanclass="math inline">\(K_1\)</span> 中 <spanclass="math inline">\(W_{v_1}\)</span> 最小的顶点（<strong>Line8</strong>）。</p><div class="note info"><p><strong>扩展 <span class="math inline">\(U_x\)</span> 所得到的 GST可能有较小的权重</strong></p><ul><li>因为 <span class="math inline">\(U_x\)</span> 包含了来自每一个 <spanclass="math inline">\(K_i\)</span> （<span class="math inline">\(1\lei\le g\)</span>）中的一个顶点，并且这些顶点相对而言十分接近，所以扩展<span class="math inline">\(U_x\)</span> 所得到的 GST可能有较小的权重。</li></ul></div><p><strong>算法 1</strong> 剩下的部分以每一个 <spanclass="math inline">\(u\in U_x\)</span> 构造一个 <em>GST</em> <spanclass="math inline">\(T_u\)</span> ，并且从这 <spanclass="math inline">\(|U_x|\)</span> 棵 <em>GST</em>中找出权重最小的那一个。具体的，每一棵 <spanclass="math inline">\(T_u\)</span> 被初始化为只含有一个单一的顶点 <spanclass="math inline">\(u\)</span> （<strong>Line 9 -10</strong>）。然后，不断迭代直至 <spanclass="math inline">\(T_u\)</span> 扩展了 <spanclass="math inline">\(U_x\)</span> 中的所有顶点（<strong>Line11</strong>）：从 <span class="math inline">\(T_u\)</span> 中选取一个点<span class="math inline">\(s_{\textrm{min}}\)</span> ，从 <spanclass="math inline">\(U_x-T_u\)</span> 中选一个点 <spanclass="math inline">\(t_{\textrm{min}}\)</span>，它们之间的距离最短（<strong>Line 12</strong>）。接着，找到 <spanclass="math inline">\(s_{\textrm{min}}\)</span> 和 <spanclass="math inline">\(t_{\textrm{min}}\)</span>之间的最短路径，并将路径上的顶点和边加入 <spanclass="math inline">\(T_u\)</span> （<strong>Line 13 -14</strong>）。令<span class="math inline">\(u_{\textrm{min}}\in U_x\)</span>表示一个顶点，满足它所对应的 <span class="math inline">\(T_u\)</span>的权重最小（<strong>Line 17</strong>）。最终 <em>KeyKG</em> 将 <spanclass="math inline">\(T_{u_\textrm{min}}\)</span> 作为结果返回。</p><div class="note default"><p><strong>算法 1 中的 <code>getD</code> 和<code>getSP</code></strong></p><ul><li><code>getD</code> ：计算两个顶点之间的距离。</li><li><code>getSP</code>：计算两个顶点之间的最短路径。</li></ul></div><h4 id="running-example">Running Example</h4><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/10/example-of-KeyKG.PNG"alt="KeyKG 执行的例子" /><figcaption aria-hidden="true">KeyKG 执行的例子</figcaption></figure><p>举个例子，如上图，给定一个查询 <spanclass="math inline">\(Q=\{k_1,k_2,k_3\}\)</span> ，则 <spanclass="math inline">\(K_1=\{B,F\},\;K_2=\{E\},\;K_3=\{C,D\}\)</span>。</p><ul><li>对于 <span class="math inline">\(B\in K_1\)</span> ，<spanclass="math inline">\(E\)</span> 必选；由于 <spanclass="math inline">\(\textrm{dist}(B,C) = 1 &lt; 1.6 =\textrm{dist}(B,D)\)</span> ，所以选择 <spanclass="math inline">\(C\)</span> 。故 <span class="math inline">\(U_B =\{B,E,C\}\)</span> 。</li><li>对于 <span class="math inline">\(B\in K_2\)</span> ，<spanclass="math inline">\(E\)</span> 必选；由于 <spanclass="math inline">\(\textrm{dist}(F,C) = 1.1 &lt; 1.7 =\textrm{dist}(F,D)\)</span> ，所以选择 <spanclass="math inline">\(C\)</span> 。故 <span class="math inline">\(U_B =\{F,E,C\}\)</span> 。</li></ul><p>下面计算各自的权重之和：</p><ul><li>对于 <span class="math inline">\(U_B\)</span> ，<spanclass="math inline">\(W_B=\textrm{dist}(B,E)+\textrm{dist}(B,C) = 0.8+1= 1.8\)</span></li><li>对于 <span class="math inline">\(U_F\)</span> ，<spanclass="math inline">\(W_B=\textrm{dist}(F,E)+\textrm{dist}(F,C) =0.9+1.1 = 2\)</span></li></ul><p>由于 <span class="math inline">\(W_B &lt; W_F\)</span> ，故 <spanclass="math inline">\(x = B\)</span> 。</p><p>接下来生成 <em>GST</em> ：</p><ul><li><span class="math inline">\(T_B\)</span><ul><li>初始化 <span class="math inline">\(T_B\)</span> 中仅有一个顶点 <spanclass="math inline">\(B\)</span></li><li>令 <span class="math inline">\(s_{\textrm{min}} = B\)</span> ，则<span class="math inline">\(t_{\textrm{min}} = E\)</span> ，因为 <spanclass="math inline">\(\textrm{dist}(B,E) &lt;\textrm{dist}(B,C)\)</span></li><li>令 <span class="math inline">\(t_{\textrm{min}} = C\)</span> ，则<span class="math inline">\(s_\textrm{min} = E\)</span> ，因为 <spanclass="math inline">\(dist(E,C) &lt; \textrm{dist}(B,C)\)</span></li><li>再求出相关最短距离的路径，将路径上的顶点和边加入 <spanclass="math inline">\(T_B\)</span> ，即可得到图 <strong>KeyKG执行的例子</strong> 中的 <span class="math inline">\(T_B\)</span></li></ul></li><li><span class="math inline">\(T_E\)</span> ：类似 <spanclass="math inline">\(T_B\)</span> 分析可得</li><li><span class="math inline">\(T_C\)</span> ：类似 <spanclass="math inline">\(T_B\)</span> 分析可得</li></ul><h3 id="static-hl">Static HL</h3><h4 id="why-we-need-hub-labeling">Why we need Hub Labeling？</h4><p>由上述介绍可知，<em>KeyKG</em> 依赖于两个子函数 <code>getD</code> 和<code>getSP</code>。在巨大的知识图谱中，一种直观的在线的实现这些子函数的方法（例如Dijkstra算法）的执行时间太长了；另一方面，离线生成每对顶点之间的距离和最短路径的空间开销十分大。为了权衡时空开销，这篇文章使用了Hub Labeling ，一种离线生成的索引结构。</p><h4 id="basic-concept">Basic Concept</h4><p>一个静态的 HL 是一个图上的离线生成的索引结构。规范的说，对于一个图<span class="math inline">\(G=&lt;V,E&gt;\)</span> ，一个静态的 HL，可以看作一个函数 <span class="math inline">\(L:V\mapsto 2^V\)</span>，它将顶点映射到顶点的集合（称作 <em>hub</em>），并且满足下列条件：</p><ul><li><span class="math inline">\(\forall u,v\in V\)</span> ，并且 <spanclass="math inline">\(u，v\)</span> 在 <spanclass="math inline">\(G\)</span> 中是连通的，<spanclass="math inline">\(\exists h\in L(u)\cap L(v)\)</span> ，使得 <spanclass="math inline">\(h\)</span> 在 <spanclass="math inline">\(u,v\)</span> 之间的最短路径上</li></ul><div class="note info"><p>对于 <span class="math inline">\(\forall v\in V\)</span> ， <spanclass="math inline">\(L(v)\)</span> 称为顶点 <spanclass="math inline">\(v\)</span> 的<strong>标签</strong>。</p></div><h4 id="supporting-for-computing-getd-but-not-getsp">Supporting ForComputing <code>getD</code> but not <code>getSP</code></h4><p>在标准的索引结构中，每一个 <span class="math inline">\(L(v)\)</span>是一个列表，其中包含按标识符排序的 hubs 。对于每一个 <spanclass="math inline">\(h\in L(v)\)</span> ，<spanclass="math inline">\(\textrm{dist}(v,h)\)</span>也会预先计算出来并保存。这样我们就可以通过如下公式计算 <code>getD</code>： <span class="math display">\[\textrm{getD}(u,v)=\begin{cases}\underset{h\in L(u)\cap L(v)}{min} \textrm{dist}(u,h) +\textrm{dist}(v,h) &amp; L(u)\cap L(v) \ne \emptyset\\\infty &amp; L(u)\cap L(v) = \emptyset\\\end{cases}\]</span> 其中，<span class="math inline">\(\textrm{dist}(u,h)\)</span>和 <span class="math inline">\(\textrm{dist}(v,h)\)</span> 分别存储在<span class="math inline">\(L(u)\)</span> 和 <spanclass="math inline">\(L(v)\)</span> 中。</p><p>但是，无法计算 <code>getSP</code></p><h4 id="improvement-in-construction">Improvement in Construction</h4><p><strong>动机</strong></p><p>从 <span class="math inline">\(\textrm{getD}(u,v)\)</span>计算公式来看，当索引标签较小时，<code>getD</code>的在线计算会更快。但是，最小化索引标签的平均大小是一个 NP-Hard问题，并且具有对数不可近似性（<em>logarithmicinapproximability</em>）。给定一个图，有很多不同的启发式的方法能够构建合理的较小的索引标签。在其他的方法中，<em>prunedlandmark labeling</em> (PLL) 是一个非常热门的实现方法，它利用了 Dijkstra算法，并且能够高效的剪枝达到缩小索引标签大小的目的。</p><p><strong>算法</strong></p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/10/Algo2.PNG"alt="Algorithm 2" /><figcaption aria-hidden="true">Algorithm 2</figcaption></figure><p>如<strong>算法 2</strong> 所示，标准的 PLL 基本流程是执行 Dijkstra算法 <span class="math inline">\(n\)</span> 次，其中 <spanclass="math inline">\(n\)</span> 为顶点的个数（Line 3 -24），并且在此过程中迭代地扩展顶点标签（Line 4，Line 12）。记 <spanclass="math inline">\(i\)</span> 次迭代后 <spanclass="math inline">\(v\)</span> 的标签为 <spanclass="math inline">\(L_i(v)\)</span> 。在第 <spanclass="math inline">\(i\)</span> 次迭代，Dijkstra 算法从一个不同的顶点<span class="math inline">\(v_i\in V\)</span> 出发（Line7），访问其他顶点并且计算它们与 <span class="math inline">\(v_i\)</span>之间的距离，存储到 <span class="math inline">\(d\)</span> 中（Line 14 -15），再将 <span class="math inline">\(v_i\)</span>加入到它们的索引标签中。</p><div class="note info"><p><strong>关于剪枝</strong></p><ul><li>由于一些顶点 <span class="math inline">\(u\)</span>没有被访问到，所以它们的标签可以剪掉。</li><li>当 <span class="math inline">\(u\)</span> 与 <spanclass="math inline">\(v_i\)</span> 的距离可由构造好的 <spanclass="math inline">\(L_{i-1}\)</span> 标签计算得到，也就是 Line 11的条件为假，那么会发生剪枝。</li></ul></div><p><strong>改进：Betweenness Centrality</strong></p><p>我们的目标是能够做更多剪枝来提高整个系统的性能。具体的，我们想要迭代早期构造的索引标签能够支持计算更多对顶点之间的距离，这样在后期的迭代过程中，就可以更频繁地发生剪枝操作。直观地，这可以通过这种方式实现，即在Dijkstra算法迭代的早期，选择那些许多最短路径都经过的顶点作为起始顶点。为了实现这个想法，原始的PLL实现方式是利用一些启发式的方法，对这些起始顶点按照其度数降序排列，因为高度数的顶点更有可能出现在许多顶点对之间的最短路径上。与传统方法不同，我们基于<em>betweenness centrality</em> 对它们降序排序。顶点 <spanclass="math inline">\(v\)</span> 的 <em>betweenness centrality</em>定义如下： <span class="math display">\[\textrm{bc}(v)=\underset{s,\;t\in V\backslash\\{v\}}{\sum}\frac{\sigma_{st}(v)}{\sigma_{st}}\]</span> 其中，<span class="math inline">\(\sigma_{st}\)</span>表示顶点 <span class="math inline">\(s,\;t\)</span>之间最短路径的个数，<span class="math inline">\(\sigma_{st}(v)\)</span>表示上述路劲中经过顶点 <span class="math inline">\(v\)</span> 的。</p><div class="note info"><p><strong>图上任意两个顶点之间的最短路径不止一条</strong>，因为可能存在<strong>最小权值相等但是路径不同</strong>的情况。</p></div><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/10/example-of-KeyKG.PNG"alt="KeyKG 执行的例子" /><figcaption aria-hidden="true">KeyKG 执行的例子</figcaption></figure><div class="note default"><p>举个例子，如上图中的图。可以用 Floyd算法计算出任意两顶点之间的最短距离和路径。之后依据这个信息和<em>betweenness centrality</em> 的定义可得：</p><ul><li><span class="math inline">\(\textrm{bc}(A) = 7\)</span></li><li><span class="math inline">\(\textrm{bc}(B)=4\)</span></li><li><spanclass="math inline">\(\textrm{bc}(C)=\textrm{bc}(D)=\textrm{bc}(E)=\textrm{bc}(F)=0\)</span></li></ul><p>但是，论文中用了 [4]（<strong>TODO</strong>）中的近似算法来缩短计算时间。</p></div><p><strong>构造 Static HL 的例子</strong></p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/10/example-of-KeyKG.PNG"alt="KeyKG 执行的例子" /><figcaption aria-hidden="true">KeyKG 执行的例子</figcaption></figure><p>假设图的结构如上图所示。</p><p>首先初始化 <span class="math inline">\(L_0(v)\)</span> ：</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(L_0(A)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_0(B)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_0(C)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_0(D)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_0(E)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_0(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>接着按照 <em>betweenness centrality</em> 对顶点降序排序，顺序为<strong>A, B, C, D, E, F</strong>；</p><hr /><p>进入第一次循环：</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td></tr></tbody></table><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(d[A]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[B]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[C]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[D]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[E]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>0</strong></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td></tr></tbody></table><p>PQ 优先队列为：</p><table><thead><tr class="header"><th style="text-align: center;">A</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头（队尾）</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>进入内层 while 循环，</p><p>从 PQ 中弹出 <span class="math inline">\(A\)</span> 赋给 <spanclass="math inline">\(u\)</span> ，即 <spanclass="math inline">\(u=A\)</span> ；</p><p>将 <span class="math inline">\(visit[u]\)</span> 置 1，则：</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><p>利用 <span class="math inline">\(L_0\)</span> 计算 <spanclass="math inline">\(\textrm{getD}(v_1,u)\)</span> ，即计算 <spanclass="math inline">\(\textrm{getD}(A,A)\)</span> 。由于 <spanclass="math inline">\(L_0(A)=\emptyset\)</span> ，故 <spanclass="math inline">\(L_0(A)\cap L_0(A) = \emptyset\)</span>，所以 <spanclass="math inline">\(\textrm{getD}(A,A) = \infty\)</span> （利用 <spanclass="math inline">\(\textrm{getD}\)</span> 的公式可得）。</p><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[A] = 0&lt; \textrm{getD}(v_1,u)\)</span> ，故 Line 11的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrowL_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 42%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td></tr></tbody></table><hr /><p>在接下来的对 <span class="math inline">\(u=A\)</span>未被访问的邻居顶点执行操作。</p><p>访问第一个邻居 <span class="math inline">\(B\)</span> 后，<spanclass="math inline">\(d\)</span> 变化如下：</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(d[A]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[B]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[C]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[D]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[E]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;"><strong>0.6</strong></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td></tr></tbody></table><p>则有属于 <span class="math inline">\(L_1(B)\)</span> 的 <spanclass="math inline">\(A(\textrm{dist} = 0.6, \textrm{pred}= A)\)</span>，同时 B 插入到 PQ 中。</p><p>类似的，有</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(d[A]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[B]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[C]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[D]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[E]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0.6</td><td style="text-align: center;"><strong>0.4</strong></td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;"><strong>0.3</strong></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td></tr></tbody></table><p>属于 <span class="math inline">\(L_1(C)\)</span> 的 <spanclass="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}=A)\)</span></p><p>属于 <span class="math inline">\(L_1(D)\)</span> 的 <spanclass="math inline">\(A(\textrm{dist} = 1, \textrm{pred}=A)\)</span></p><p>属于 <span class="math inline">\(L_1(E)\)</span> 的 <spanclass="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}=A)\)</span></p><p>在所有 A 的邻居访问完后，PQ 变为</p><table><thead><tr class="header"><th style="text-align: center;">E</th><th style="text-align: center;">C</th><th style="text-align: center;">B</th><th style="text-align: center;">D</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">队尾</td><td style="text-align: center;"></td></tr></tbody></table><p>然后，回到 <code>while</code> 循环。</p><hr /><p>PQ 弹出 E，置 <span class="math inline">\(visit\)</span> 为 1：</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">0</td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[E] = 0.3&lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,E) = \infty\)</span> ，故Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrowL_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 31%" /><col style="width: 8%" /><col style="width: 8%" /><col style="width: 8%" /><col style="width: 33%" /><col style="width: 8%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>E 未访问的邻居为 B，但由于 <spanclass="math inline">\(d[u]+\text{wt}((u,w)) = d[E] + \text{wt}((E,B)) =0.3 + 0.8 = 1.1 &gt; d[B] = 0.6\)</span>，所以不更新；又由于 B 在 PQ中，所以不加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;">C</th><th style="text-align: center;">B</th><th style="text-align: center;">D</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头</td><td style="text-align: center;"></td><td style="text-align: center;">队尾</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>PQ 弹出 C，置 <span class="math inline">\(visit\)</span> 为 1：</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[C] = 0.4&lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,C) = \infty\)</span> ，故Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrowL_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 25%" /><col style="width: 7%" /><col style="width: 26%" /><col style="width: 7%" /><col style="width: 26%" /><col style="width: 7%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>C 未访问的邻居为 F，但由于 <spanclass="math inline">\(d[u]+\text{wt}((u,w)) = d[C] + \text{wt}((C,F)) =0.4 + 2 = 2.4 &lt; d[F] = \infty\)</span>，所以，更新 <spanclass="math inline">\(d[F]\)</span> ：</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(d[A]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[B]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[C]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[D]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[E]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0.6</td><td style="text-align: center;">0.4</td><td style="text-align: center;">1</td><td style="text-align: center;">0.3</td><td style="text-align: center;"><strong>2.4</strong></td></tr></tbody></table><p>此时，属于 <span class="math inline">\(L_1(F)\)</span> 的 <spanclass="math inline">\(A(\textrm{dist} = 2.4, \textrm{pred}=C)\)</span></p><p>又由于 F 不在 PQ 中，所以加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;">B</th><th style="text-align: center;">D</th><th style="text-align: center;">F</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头</td><td style="text-align: center;"></td><td style="text-align: center;">队尾</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>PQ 弹出 B，置 <span class="math inline">\(visit\)</span> 为 1：</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[B] = 0.6&lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,B) = \infty\)</span> ，故Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrowL_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table style="width:100%;"><colgroup><col style="width: 21%" /><col style="width: 23%" /><col style="width: 22%" /><col style="width: 5%" /><col style="width: 22%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math display">\[A(\textrm{dist} = 0.6, \textrm{pred}=A)\]</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>B 未访问的邻居为 F，但由于 <spanclass="math inline">\(d[u]+\text{wt}((u,w)) = d[B] + \text{wt}((B,F)) =0.6 + 0.1 = 0.7 &lt; d[F] = 2.4\)</span>，所以，更新 <spanclass="math inline">\(d[F]\)</span> ：</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(d[A]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[B]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[C]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[D]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[E]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0.6</td><td style="text-align: center;">0.4</td><td style="text-align: center;">1</td><td style="text-align: center;">0.3</td><td style="text-align: center;"><strong>0.7</strong></td></tr></tbody></table><p>此时，属于 <span class="math inline">\(L_1(F)\)</span> 的 <spanclass="math inline">\(A(\textrm{dist} = 0.7, \textrm{pred}=B)\)</span></p><p>又由于 F 在 PQ 中，所以不加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;">D</th><th style="text-align: center;">F</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头</td><td style="text-align: center;">队尾</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>PQ 弹出 D，置 <span class="math inline">\(visit\)</span> 为 1：</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[D] = 1&lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,D) = \infty\)</span> ，故Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrowL_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 18%" /><col style="width: 20%" /><col style="width: 19%" /><col style="width: 18%" /><col style="width: 19%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math display">\[A(\textrm{dist} = 0.6, \textrm{pred}=A)\]</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 1, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>D 没有未访问的邻居，故不更新 <spanclass="math inline">\(d[F]\)</span> ，也就没有顶点加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;">F</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头（队尾）</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>PQ 弹出 F，置 <span class="math inline">\(visit\)</span> 为 1：</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><spanclass="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"><strong>1</strong></td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[F] = 0.7&lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,F) = \infty\)</span> ，故Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrowL_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 16%" /><col style="width: 17%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math display">\[A(\textrm{dist} = 0.6, \textrm{pred}=A)\]</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 1, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.7, \textrm{pred}=B)\)</span></td></tr></tbody></table><p>F 没有未访问的邻居，故不更新 <spanclass="math inline">\(d[F]\)</span> ，也就没有顶点加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td></tr></tbody></table><hr /><p>至此，第一次 for 迭代结束，索引结果为</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.6, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 1, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}=A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A(\textrm{dist} = 0.7, \textrm{pred}=B)\)</span></td></tr></tbody></table><p>类似的处理，可得下图右下角的索引。</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/10/example-of-KeyKG.PNG"alt="KeyKG 执行的例子" /><figcaption aria-hidden="true">KeyKG 执行的例子</figcaption></figure><h4 id="extension-of-index-structure">Extension of Index Structure</h4><p>为了支持计算 <code>getSP</code> ，我们需要扩展 <code>L</code>的索引结构。在<strong>算法 2</strong> 中，对于每一个 hub <spanclass="math inline">\(v_i\in L(w)\)</span> ，我们不仅仅存储了 <spanclass="math inline">\(\textrm{dist}(w,v_i)\)</span> ，还存储了以 <spanclass="math inline">\(v_i\)</span> 为根节点搜索树中 <spanclass="math inline">\(w\)</span> 的前驱顶点，并将其记作 <spanclass="math inline">\(\textrm{pred}(w,v_i)\)</span> （Line 16）。</p><p>有了扩展后的索引结构，<code>getSP</code> 就可以通过<strong>算法3</strong> 计算得到。为了得到顶点 <spanclass="math inline">\(u,\;v\)</span> 之间的一条最短路径 <spanclass="math inline">\(p\)</span> ，我们首先在 <spanclass="math inline">\(p\)</span> 上找到它们所共有的 hub <spanclass="math inline">\(h_{\textrm{min}}\)</span> （Line1），然后重复地跟随前驱顶点，构造路径 <spanclass="math inline">\(p\)</span> 的从 <spanclass="math inline">\(u\)</span> 到 <spanclass="math inline">\(h_{\textrm{min}}\)</span> 的一段（Line 2-8），以及<span class="math inline">\(v\)</span> 到 <spanclass="math inline">\(h_{\textrm{min}}\)</span> 的一段（Line9-14）。</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/10/Algo3.PNG"alt="Algorithm 3" /><figcaption aria-hidden="true">Algorithm 3</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/10/example-of-KeyKG.PNG"alt="KeyKG 执行的例子" /><figcaption aria-hidden="true">KeyKG 执行的例子</figcaption></figure><p>举个例子，比如计算 <code>getSP(D, F)</code> 。</p><p>首先，<code>L(D)</code> 和 <code>L(F)</code> 的公共 hub只有一个，就是 <span class="math inline">\(A\)</span>，则 <spanclass="math inline">\(h_{\textrm{min}} = A\)</span> 。</p><p>然后，通过 <code>pred</code> 信息找到 D-A 的路径，为 D-A ，因为<code>L(D)</code> 中 <span class="math inline">\(A\)</span> 的<code>pred</code> 为 <span class="math inline">\(A\)</span>。</p><p>接着，同样的，找到 F-A 的路径，为 F-B-A，因为 <code>L(F)</code> 中的A 的 <code>pred</code> 为 <span class="math inline">\(B\)</span>，L(B)中的 <span class="math inline">\(A\)</span> 的 <code>pred</code> 为<span class="math inline">\(A\)</span>。</p><p>最后，将上面两个子路径连起来，我们就找到了路径 <spanclass="math inline">\(p\)</span>，为 D-A-B-F。</p><h2 id="keykg-with-dynamic-hl">KeyKG+ With Dynamic HL</h2><h3 id="dynamic-hl">Dynamic HL</h3><h4 id="features">Features</h4><ul><li><strong>查询相关的</strong>（<em>query-relevant</em>）</li><li><strong>在线构造的</strong>（<em>online constructed</em>）</li></ul><h4 id="definition-and-structure">Definition and structure</h4><p>一个动态 HL 是一个 <span class="math inline">\((g-1)\times n\)</span>的矩阵，记作 <span class="math inline">\(M\)</span>。行对应于关键词顶点集 <spanclass="math inline">\(K_2,K_3,\dots,K_g\)</span> ，列对应于 hub顶点。<span class="math inline">\(M\)</span> 的第 <spanclass="math inline">\((i-1)\)</span> 行（记作 <spanclass="math inline">\(M_{i-1}\)</span>）倒排并且聚集了 <spanclass="math inline">\(K_i\)</span> 中顶点的静态索引标签。<spanclass="math inline">\(M_{i-1}\)</span> 的第 j 个元素（记作 <spanclass="math inline">\(M_{i-1,j}\)</span>）是非空的，如果 <spanclass="math inline">\(h_j\in V\)</span> 是一个 hub，并且它在 <spanclass="math inline">\(K_i\)</span> 的至少一个顶点的静态索引标签中。在<span class="math inline">\(K_i\)</span>中的这些顶点中（这些顶点的静态索引标签包括 <spanclass="math inline">\(h_j\)</span>），<spanclass="math inline">\(M_{i-1, j}\)</span> 代表了最小化到达 <spanclass="math inline">\(h_j\)</span> 的距离的顶点。如果， <spanclass="math inline">\(h_j\)</span> 不是一个在 <spanclass="math inline">\(K_i\)</span> 中任意一个顶点的索引标签中的hub，那么我们令 <span class="math inline">\(M_{i-1, j}\)</span> 为null： <span class="math display">\[M_{i-1,j}=\begin{cases}&amp;\underset{u\in K_i\; s.t.\; h_j\inL(u)}{\textrm{argmin}}\textrm{dist}(u, h_j)&amp;h_j\in \bigcup_{u\inK_i}L(u),\\&amp;null&amp;h_j\not\in \bigcup_{u\in K_i}L(u),\end{cases}\]</span> 具体的，论文中使用<strong>二维数组</strong>存储矩阵 <spanclass="math inline">\(M\)</span>，因此可以支持常数时间的随机访问。对于每一个不为 null 的 <spanclass="math inline">\(M_{i-1, j}\)</span> ，与 <spanclass="math inline">\(h_j\)</span> 的距离也是先计算出来，并保存到 <spanclass="math inline">\(M\)</span> 中。</p><h4 id="example">Example</h4><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/10/example-of-KeyKG.PNG"alt="KeyKG 执行的例子" /><figcaption aria-hidden="true">KeyKG 执行的例子</figcaption></figure><ul><li><span class="math inline">\(i = 2\)</span> 时，<spanclass="math inline">\(K_2=\{E\}\)</span> ，<spanclass="math inline">\(L(E) = \{A,B,E\}\)</span> ，因此矩阵 <spanclass="math inline">\(M\)</span> <spanclass="math inline">\(K_2\)</span> 行只有 <spanclass="math inline">\(A,B,E\)</span> 不为 null，其他都为 null；由于<span class="math inline">\(K_2\)</span> 中只有一个元素 <spanclass="math inline">\(E\)</span> ，故 <spanclass="math inline">\(K_2\)</span> 行 <spanclass="math inline">\(A,B,E\)</span> 列中的元素都为 <spanclass="math inline">\(E\)</span> 和到它的距离（从 <spanclass="math inline">\(L(E)\)</span> 中直接取得）。</li><li><span class="math inline">\(i = 3\)</span> 时，<spanclass="math inline">\(K_3=\{C,D\}\)</span> ，<spanclass="math inline">\(L(C)\cup L(D) = \{A,C,D\}\)</span> ，因此矩阵<span class="math inline">\(M\)</span> <spanclass="math inline">\(K_3\)</span> 行只有 <spanclass="math inline">\(A,C,D\)</span> 不为 null，其他都为 null；由于<span class="math inline">\(K_3\)</span> 中有两个元素，故 <spanclass="math inline">\(K_3\)</span> 行 <spanclass="math inline">\(A,C,D\)</span> 列中的元素需要对比一下分别到 <spanclass="math inline">\(C\)</span> 和 <spanclass="math inline">\(D\)</span> 的距离，选择较小的存入矩阵 <spanclass="math inline">\(M\)</span> （比如 <spanclass="math inline">\(M_{K_3, A}\)</span> ，由于 <spanclass="math inline">\(\textrm{dist}(C,A) &lt;\textrm{dist}(D,A)\)</span>，所以将 <spanclass="math inline">\(C\)</span> 存入矩阵）。</li></ul><p>综上所示，矩阵 <span class="math inline">\(M\)</span>如下图所示：</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/11/matrix-M.PNG"alt="Dynamic HL Example" /><figcaption aria-hidden="true">Dynamic HL Example</figcaption></figure><h3 id="algorithm-keykg-1">Algorithm KeyKG+</h3><h4 id="algorithm-explained-1">Algorithm Explained</h4><p>KeyKG+ 如<strong>算法 4</strong> 所示。这个算法主要构造了动态HL，并将其使用在两个方面，提高执行的总体性能，并且对最终结果没有任何影响。</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/11/Algo4.PNG"alt="Algorithm 4" /><figcaption aria-hidden="true">Algorithm 4</figcaption></figure><p>在第一部分，首先，为 <spanclass="math inline">\(K_2,\dots,K_g\)</span> 构造矩阵 <spanclass="math inline">\(M\)</span> （Line 1-3）。然后，按照如下流程利用<span class="math inline">\(M_{i-1}\)</span> 找到 <spanclass="math inline">\(v_i\)</span> （Line 6）。对于每一个 hub <spanclass="math inline">\(h_j\in L(v_1)\)</span> ，我们从 <spanclass="math inline">\(L(v_1)\)</span> 中取得 <spanclass="math inline">\(\textrm{dist}(v_1,h_j)\)</span> ，并且从 <spanclass="math inline">\(M_{i-1}\)</span> 中取 <spanclass="math inline">\(M_{i-1, j}\)</span> 元素的 <spanclass="math inline">\(\textrm{dist}(M_{i-1,j},h_j)\)</span> 。如果 <spanclass="math inline">\(M_{i-1,j}\)</span> 非空，那么我们计算： <spanclass="math display">\[\textrm{dist}(v_1,h_j)+\textrm{dist}(M_{i-1,j},h_j)\]</span> 这个结果表示了 <span class="math inline">\(v_1\)</span> 到在<span class="math inline">\(K_i\)</span> 中经过一个特定的 <spanclass="math inline">\(h_j\)</span> 所能到达的顶点之间的最短距离。最后，通过如下方式，找到 <span class="math inline">\(v_i\)</span> ： <spanclass="math display">\[v_i=\underset{M_{i-1, j}\; s.t.\; h_j\in L(v_1)\; \textrm{and}\; M_{i-1,j}\ne \textrm{null}}{\textrm{argmin}}\textrm{dist}(v_1,h_j)+\textrm{dist}(M_{i-1,j},h_j)\]</span> KeyKG+ Line 6 计算得到的 <spanclass="math inline">\(v_i\)</span> 和 KeyKG Line 3 得到的 <spanclass="math inline">\(v_i\)</span> 等价，但是 KeyKG+ 的效率更高。</p><p>第二部分，我们像为 <span class="math inline">\(K_i\)</span> 创建<span class="math inline">\(M_{i-1}\)</span> 一样，为 <spanclass="math inline">\(V_{T_u}\)</span> （Line 14）创建 <spanclass="math inline">\(M&#39;_{u}\)</span> 。随着 <spanclass="math inline">\(T_u\)</span> 在每次迭代中逐渐扩展（Line21），<span class="math inline">\(M&#39;_{u}\)</span> 通过加入到 <spanclass="math inline">\(T_u\)</span> 的顶点的静态索引标签得到更新（Line22）。对于每一个 <span class="math inline">\(t_i\in(U_x\backslashV_{T_u})\)</span> ，<span class="math inline">\(M&#39;_u\)</span>被用来找到与 <span class="math inline">\(t_i\)</span> 距离最短的顶点<span class="math inline">\(s_i\in V_{T_u}\)</span> （Line16-18）。我们在所有的这样的 <spanclass="math inline">\(&lt;s_i,t_i&gt;\)</span> 中找到最小的 <spanclass="math inline">\(&lt;s_{\textrm{min}},t_{\textrm{min}}&gt;\)</span>（Line 19）</p><p>KeyKG+ Line 16-19 计算得到的 <spanclass="math inline">\(&lt;s_{\textrm{min}},t_{\textrm{min}}&gt;\)</span>和 KeyKG Line 12 得到的 <spanclass="math inline">\(&lt;s_{\textrm{min}},t_{\textrm{min}}&gt;\)</span>等价，但是 KeyKG+ 的效率更高。</p><h4 id="running-example-1">Running Example</h4><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/10/example-of-KeyKG.PNG"alt="KeyKG 执行的例子" /><figcaption aria-hidden="true">KeyKG 执行的例子</figcaption></figure><p>如上图，</p><ul><li>令 <span class="math inline">\(B\in K_1\)</span> 为 <spanclass="math inline">\(v_1\)</span> ，查询其 Static HL，得到 <spanclass="math inline">\(L(B) = \{A,B\}\)</span> ；<ul><li>因为 <span class="math inline">\(M_{1,A} = M_{1,B} = E\)</span>，所以令 <span class="math inline">\(E\in K_2\)</span> 为 <spanclass="math inline">\(v_2\)</span> ；</li><li>因为 <span class="math inline">\(M_{2,A} = C, M_{2,B} =\textrm{null}\)</span> ，所以令 <span class="math inline">\(C\inK_3\)</span> 为 <span class="math inline">\(v_3\)</span> ；</li><li>这样就形成了 <span class="math inline">\(U_B=\{B,E,C\}\)</span>（这与算法 KeyKG 得到的结果是一致的）</li></ul></li><li>令 <span class="math inline">\(F\in K_1\)</span> 为 <spanclass="math inline">\(v_1\)</span> ，查询其 Static HL，得到 <spanclass="math inline">\(L(F) = \{A,B,F\}\)</span> ；<ul><li>因为 <span class="math inline">\(M_{1,A} = M_{1,B} = E, M_{1,F} =\textrm{null}\)</span> ，所以令 <span class="math inline">\(E\inK_2\)</span> 为 <span class="math inline">\(v_2\)</span> ；</li><li>因为 <span class="math inline">\(M_{2,A} = C, M_{2,B} = M_{2,F} =\textrm{null}\)</span> ，所以令 <span class="math inline">\(C\inK_3\)</span> 为 <span class="math inline">\(v_3\)</span> ；</li><li>这样就形成了 <span class="math inline">\(U_F=\{F,E,C\}\)</span>（这与算法 KeyKG 得到的结果是一致的）</li></ul></li></ul><div class="note default"><p><strong>TODO</strong>：另一半的例子怎么解释？？？</p></div><h1 id="how-much">How much？</h1><ul><li>基于 <em>betweenness centrality</em> 的启发式方法构建的 <em>StaticHub Labelings</em> 超越了现存的方案。</li><li><em>Dynamic Hub Labelings</em>则通过倒排并聚集查询相关的静态标签，加速了总体的查询效率。</li></ul><h1 id="what-then">What Then？</h1><ul><li>寻找支持更高效地边删除（<em>edge deletion</em>）的解决方案</li><li>KeyKG+ 的近似比率可以进一步得到提高</li><li>现存 HL 方案无法处理巨大而稠密的图。</li></ul><h1 id="problems-to-solve">Problems to Solve</h1><ul class="task-list"><li><input type="checkbox" disabled="" />Hub Labeling<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a></li><li><input type="checkbox" disabled="" />pruned landmark labeling <a href="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a></li><li><input type="checkbox" disabled="" />PLL<a href="#fn3" class="footnote-ref" id="fnref3"role="doc-noteref"><sup>3</sup></a></li><li><input type="checkbox" disabled="" />between centrality？？？【10】 <a href="#fn4" class="footnote-ref"id="fnref4" role="doc-noteref"><sup>4</sup></a> vs 【4】<a href="#fn5"class="footnote-ref" id="fnref5"role="doc-noteref"><sup>5</sup></a></li></ul><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>Ittai Abraham, Daniel Delling, AndrewV. Goldberg, and Renato Fonseca F. Werneck. 2011. A Hub-Based LabelingAlgorithm for Shortest Paths in Road Networks. In SEA. 230–241.<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>Takuya Akiba, Yoichi Iwata, andYuichi Yoshida. 2013. Fast exact shortest-path distance queries on largenetworks by pruned landmark labeling. In SIGMOD. 349–360<ahref="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p>Takuya Akiba, Yoichi Iwata, andYuichi Yoshida. 2013. Fast exact shortest-path distance queries on largenetworks by pruned landmark labeling. In SIGMOD. 349–360<ahref="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4" role="doc-endnote"><p>Ulrik Brandes. 2001. A fasteralgorithm for betweenness centrality. J. Math. Soc. 25, 2 (2001),163–177.<a href="#fnref4" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn5" role="doc-endnote"><p>Ziyad AlGhamdi, Fuad Jamour, SpirosSkiadopoulos, and Panos Kalnis. 2017. A Benchmark for BetweennessCentrality Approximation Algorithms on Large Graphs. In SSDBM<ahref="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      这篇文章提出了一个实用的近似算法，能够在较短的时间内获得较好的结果。该算法基于 Hub Labeling（HL），一个用来计算距离和最短路径的数据结构，这个数据结构为图中的每一个点标明了能从这个点到达的点的集合。具体的，设计了两类 HL：一个是传统静态的 HL，它采用了一种全新的启发式方法来提高 pruned landmark labeling 的效率；另一个是新颖动态的 HL，它倒排并聚集查询相关的静态标签，使得在处理顶点集时更加高效。
    
    </summary>
    
    
      <category term="研究" scheme="https://cosmosning.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Knowledge graph" scheme="https://cosmosning.github.io/tags/Knowledge-graph/"/>
    
      <category term="Keyword search" scheme="https://cosmosning.github.io/tags/Keyword-search/"/>
    
      <category term="Group Steiner tree" scheme="https://cosmosning.github.io/tags/Group-Steiner-tree/"/>
    
      <category term="Hub labeling" scheme="https://cosmosning.github.io/tags/Hub-labeling/"/>
    
  </entry>
  
  <entry>
    <title>PAC 模型及其变体</title>
    <link href="https://cosmosning.github.io/2020/09/19/pac-learning-and-its-variants/"/>
    <id>https://cosmosning.github.io/2020/09/19/pac-learning-and-its-variants/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-09-19T01:30:55.000Z</published>
    <updated>2023-06-02T11:13:14.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文将介绍通用的学习模型 PAC 及其变体形式。</p><ul><li><p>最原始的 PAC主要需要满足<strong>可实现假设</strong>，<strong>训练样本量要大于样本复杂度函数</strong>。</p></li><li><p>现实情况中，<strong>可实现假设难以满足</strong>（先验知识不一定猜得准），因此<strong>将目标标记函数改为数据-标签分布，并从中采样训练样本</strong>，就可以类似的得到Agnostic PAC 。</p></li><li><p>原始的 PAC中，标记函数将学习问题限制在二元分类任务中。为了获得更加通用的学习模型，我们定义更加一般的损失函数。通过损失函数，可计算真实误差和经验风险：</p></li></ul><blockquote><ul><li><p>在<strong>问题分布</strong>（<spanclass="math inline">\(\mathcal{D}\)</span>）上采样得到的误差函数的<strong>期望</strong>，作为<strong>真实误差</strong>；</p></li><li><p>在<strong>训练样本</strong>（<spanclass="math inline">\(S\)</span>）上采样得到的误差函数的<strong>平均值</strong>，作为<strong>经验风险</strong>；</p></li></ul></blockquote></blockquote><h1 id="pac-learning">PAC Learning</h1><p>在<ahref="/2020/09/16/statistical-learning-framework-and-empirical-risk-minimization/">上一篇文章</a>中，我们证明了对于一个有限的假设集，<mark>如果拥有足量的训练样本（这些训练样本是从同一分布中独立采样，并被同一标记函数标记而生成的），ERM会输出近似正确的假设</mark>。更一般的，我们定义 <em>ProbablyApproximately Correct Learning</em> （PAC）如下：</p><div class="note primary"><p><strong>Def. PAC Learnability</strong></p><p>如果</p><ul><li>存在一个函数 <spanclass="math inline">\(m_{\mathcal{H}}:(0,1)^2\rightarrow\mathbb{N}\)</span> ，</li><li>并且存在一个学习算法满足以下条件：<ul><li>对于任意的 <span class="math inline">\(\epsilon,\delta\in(0,1)\)</span> ，任意的 <spanclass="math inline">\(\mathcal{X}\)</span> 上的分布 <spanclass="math inline">\(\mathcal{D}\)</span> ，任意的标记函数 <spanclass="math inline">\(f: \mathcal{X}\rightarrow \lbrace0,1\rbrace\)</span> ，如果对于 <spanclass="math inline">\(\mathcal{H,D},f\)</span>可实现假设（<em>realizability assumption</em> ，即 <spanclass="math inline">\(\exists\ h^\star\in \mathcal{H}, L_{D,f}(h^\star)= 0\)</span>）成立，那么当学习算法的训练样本量 <spanclass="math inline">\(m \ge m_{\mathcal{H}}(\epsilon, \delta)\)</span>时（这些训练样本是由从 <span class="math inline">\(\mathcal{D}\)</span>中独立采样，并被 <span class="math inline">\(f\)</span>标记而生成的），学习算法会以至少 <span class="math inline">\(1 -\delta\)</span> 的概率返回一个假设 <spanclass="math inline">\(h\)</span>，并且该假设满足 <spanclass="math inline">\(L_{(\mathcal{D},f)}(h) \le \epsilon\)</span></li></ul></li></ul><p>则一个假设类 <span class="math inline">\(\mathcal{H}\)</span> 是 PAC可学习的</p></div><div class="note info"><p><strong>有关 PAC Learnability 的补充说明</strong></p><ul><li><span class="math inline">\(\epsilon\)</span>称作<strong>精度参数</strong>（<em>accuracyparameter</em>），代表输出分类器与最优之间的误差大小（对应 PAC 中的<strong><em>approximately correct</em></strong>）。这意味着，<spanclass="math inline">\(\epsilon\)</span> 允许学习算法犯一些小错误。</li><li><span class="math inline">\(\delta\)</span>称作<strong>置信参数</strong>（<em>confidenceparameter</em>），代表输出分类器满足上述精度要求的可能性（对应 PAC 中的<strong><em>probably</em></strong>）</li><li><span class="math inline">\(m_{\mathcal{H}}:(0, 1) \rightarrow\mathbb{N}\)</span> 称作<strong>样本复杂度</strong>（<em>samplecomplexity</em>）函数，表示<strong>需要多少训练样本数据，才能够保证获得一个尽可能近似正确的答案</strong>。该函数依赖于<span class="math inline">\(\epsilon, \delta,\mathcal{H}\)</span> 。依据PAC Learnability 的定义，存在不止一个 <spanclass="math inline">\(m_{\mathcal{H}}\)</span> 满足条件。通常，我们定义<span class="math inline">\(m_{\mathcal{H}}\)</span>为满足条件的<strong>最小整数</strong>。</li></ul></div><p>对上一篇文章中获得的结论，我们换一种表达，则有下面的推论</p><div class="note default"><p><strong>PAC 可学习的样本复杂度条件</strong></p><p>每一个有限假设类都是 PAC 可学习的，只要它的样本复杂度满足： <spanclass="math display">\[m_{\mathcal{H}} \le \lceil\frac{log(\frac{\mathcal{H}}{\delta})}{\epsilon} \rceil\]</span></p></div><h1 id="a-more-general-learning-model">A More General LearningModel</h1><p>对于大多数任务，可实现假设很难得到满足，而且上述定义只适用于二元分类问题，因此通用性不佳。为了得到更加通用的学习模型，我们对上述模型从以下两个方面进行拓展：</p><ol type="1"><li>去除可实现假设。引入 <strong>Agnostic PAC</strong>解决这个问题。</li><li>学习比二元分类问题更加广泛的任务。通过对<strong>损失函数的一般化</strong>来支持这种拓展。</li></ol><h2id="releasing-the-realizablity-assumption-agnostic-pac-learning">Releasingthe Realizablity Assumption —— Agnostic PAC Learning</h2><h3 id="a-more-realistic-model-for-the-data-generating-distribution">AMore Realistic Model for the Data-Generating Distribution</h3><p>简单来说，我们可以将 “目标标记函数”替换为<strong>数据-标签</strong>生成分布。</p><p>规范地，设 <span class="math inline">\(\mathcal{D}\)</span> 为 <spanclass="math inline">\(\mathcal{X} \times \mathcal{Y}\)</span>上的概率分布，其中 <span class="math inline">\(\mathcal{X}\)</span>为领域集，<span class="math inline">\(\mathcal{Y}\)</span>为标签集。也就是说，<span class="math inline">\(\mathcal{D}\)</span>为在领域点和标签上的联合分布。我们可以将 <spanclass="math inline">\(\mathcal{D}\)</span>看作由两个部分组成：一个在未被标记的领域点上的分布 <spanclass="math inline">\(\mathcal{D}_x\)</span>（有时候，也称作<strong>边缘分布</strong>），另一个为每一个领域点的标签上的<strong>条件概率</strong> <spanclass="math inline">\(\mathcal{D}((x,y)|x)\)</span> 。</p><div class="note info"><p><strong>如何理解条件概率？</strong></p><ul><li>很多事情无法精确刻画，因此可用一个条件分布来描述。随着某一变量的变化，对应事件的概率也会发生变化。例如，<spanclass="math inline">\(\mathcal{D}(y|x)\)</span> 事件 <spanclass="math inline">\(y\)</span> 的概率会随着 <spanclass="math inline">\(x\)</span> 的变化而变化；此外，在 <spanclass="math inline">\(\mathcal{D}(y|x)\)</span> 中，<spanclass="math inline">\(\mathcal{D}(y|x)\)</span> 是关于 <spanclass="math inline">\(y\)</span> 的函数，而 <spanclass="math inline">\(x\)</span> 是作为函数的参数（如果要确定关于 <spanclass="math inline">\(y\)</span> 的函数关系，<spanclass="math inline">\(x\)</span> 要事先指定）。</li></ul></div><h3 id="the-empirical-and-true-error-revised">The Empirical and TrueError Revised</h3><p>与分布的改变相对应，我们定义预测规则 <spanclass="math inline">\(h\)</span><strong>真实误差</strong>（或者叫做<strong>风险</strong>）如下： <spanclass="math display">\[L_{\mathcal{D}}\overset{def}{=}\underset{(x,y)\sim\mathcal{D}}{\mathbb{P}}[h(x)\ne y] \overset{def}{=}\mathcal{D}(\lbrace(x,y): h(x) \ne y \rbrace) \tag{3.1}\]</span> 而经验风险并没有改变，依然是： <span class="math display">\[L_{S}(h)\overset{def}{=}\frac{|\lbrace i\in[m] : h(x_i) \ne y_i\rbrace|}{m}\]</span></p><h3 id="the-goal">The Goal</h3><p>学习算法的目标是寻找一些假设，<spanclass="math inline">\(h:\mathcal{X}\rightarrow \mathcal{Y}\)</span>，尽可能近似最小化真实风险，<spanclass="math inline">\(L_{\mathcal{D}}(h)\)</span></p><h3 id="the-bayes-optimal-predictor">The Bayes Optimal Predictor</h3><p>给定任意的在 <span class="math inline">\(\mathcal{X} \times \lbrace0,1\rbrace\)</span> 上的概率分布，从 <spanclass="math inline">\(\mathcal{X}\)</span> 到 <spanclass="math inline">\(\lbrace 0, 1 \rbrace\)</span> 的最佳标记函数为<span class="math display">\[f_{\mathcal{D}}(x) = \begin{cases} 1 &amp;if\ \mathbb{P}[y=1|x]\ge\frac{1}{2}\\ 0 &amp; otherwise\end{cases}\]</span> 这也就是说，对于任意的二元分类器 <spanclass="math inline">\(g: \mathcal{X}\rightarrow \lbrace 0,1\rbrace\)</span>，<spanclass="math inline">\(L_{\mathcal{D}}(f_{\mathcal{D}}) \leL_{\mathcal{D}}(g)\)</span></p><div class="note info"><p><strong>证明 The Bayes Optimal Predictor</strong>（TODO）</p></div><p>一旦我们对数据生成分布不做任何预先假设，那么将没有算法将保证找到一个预测器，媲美Bayes Optimal Predictor的效果。因此，我们需要学习算法找到一个预测器，在给定某些假设类的基准测试时，<strong>它的误差并不会比可能的最佳的预测器的误差大太多</strong>。因此，我们有如下的<strong>Agnostic PAC Learnability</strong>：</p><div class="note primary"><p><strong>Def. Agnostic PAC Learnability</strong></p><p>如果</p><ul><li><p>存在一个函数 <spanclass="math inline">\(m_{\mathcal{H}}:(0,1)^2\rightarrow\mathbb{N}\)</span> ，</p></li><li><p>并且存在一个学习算法满足以下条件：</p><ul><li>对于任意的 <span class="math inline">\(\epsilon,\delta\in(0,1)\)</span> ，任意的 <span class="math inline">\(\mathcal{X}\times\mathcal{Y}\)</span> 上的分布 <spanclass="math inline">\(\mathcal{D}\)</span> ，当学习算法的训练样本量<span class="math inline">\(m \ge m_{\mathcal{H}}(\epsilon,\delta)\)</span> 时（这些训练样本是由从 <spanclass="math inline">\(\mathcal{D}\)</span>中独立采样而生成的），学习算法会以至少 <span class="math inline">\(1 -\delta\)</span> 的概率返回一个假设 <spanclass="math inline">\(h\)</span>，并且该假设满足： <spanclass="math display">\[L_{\mathcal{D}}(h) \le \underset{h&#39;\in\mathcal{H}}{min}L_D(h&#39;) +\epsilon\]</span></li></ul></li></ul><p>则一个假设类 <span class="math inline">\(\mathcal{H}\)</span> 是Agnostic PAC 可学习的</p></div><h2id="generalized-loss-function-agnostic-pac-learning-for-general-loss-function">GeneralizedLoss Function —— Agnostic PAC Learning for General Loss Function</h2><p>为了适应不同的任务，我们接下来定义通用的损失函数。</p><p>给定任意的集合 <span class="math inline">\(\mathcal{H}\)</span>和领域集 <span class="math inline">\(Z\)</span> ，设 <spanclass="math inline">\(l\)</span> 为任意 <spanclass="math inline">\(\mathcal{H}\times Z\)</span> 到非负实数的函数，<span class="math inline">\(l: \mathcal{H} \times Z \rightarrow\mathbb{R}_+\)</span> ，我们称 <span class="math inline">\(l\)</span>为<strong>损失函数</strong>。</p><p>下面用分类器误差的期望来定义<strong>风险函数</strong>。</p><p>给定一个 <span class="math inline">\(h\in \mathcal{H}\)</span>，关于在 <span class="math inline">\(Z\)</span> 上的概率分布 <spanclass="math inline">\(\mathcal{D}\)</span> ，对应的风险函数为： <spanclass="math display">\[L_{\mathcal{D}}(h)\overset{def}{=}\underset{z\sim\mathcal{D}}{\mathbb{E}}[l(h,z)]\tag{3.3}\]</span> 相似的，经验风险函数为对采样样本 <spanclass="math inline">\(S=(z_1,\dots,z_m)\in Z^m\)</span> 上的损失的期望：<span class="math display">\[L_S(h)\overset{def}{=}\frac{1}{m}\sum_{i=1}^{m}l(h,z_i)\tag{3.4}\]</span> 综上所述，有如下更加通用的 Agnostic PAC 的定义：</p><div class="note primary"><p><strong>Def. Agnostic PAC Learning for General LossFunction</strong></p><p>如果</p><ul><li><p>存在一个函数 <spanclass="math inline">\(m_{\mathcal{H}}:(0,1)^2\rightarrow\mathbb{N}\)</span> ，</p></li><li><p>并且存在一个学习算法满足以下条件：</p><ul><li>对于任意的 <span class="math inline">\(\epsilon,\delta\in(0,1)\)</span> ，任意的 <span class="math inline">\(Z\)</span>上的分布 <span class="math inline">\(\mathcal{D}\)</span>，当学习算法的训练样本量 <span class="math inline">\(m \gem_{\mathcal{H}}(\epsilon, \delta)\)</span> 时（这些训练样本是由从 <spanclass="math inline">\(\mathcal{D}\)</span>中独立采样而生成的），学习算法会以至少 <span class="math inline">\(1 -\delta\)</span> 的概率返回一个假设 <span class="math inline">\(h\in\mathcal{H}\)</span>，并且该假设满足 <span class="math display">\[L_{\mathcal{D}}(h) \le\underset{h&#39;\in\mathcal{H}}{min}L_{\mathcal{D}}(h&#39;)+ \epsilon\]</span> 其中 <span class="math inline">\(L_{\mathcal{D}}(h) =\mathbb{E}_{z\sim D}[l(h, z)]\)</span></li></ul></li></ul><p>则一个假设类 <span class="math inline">\(\mathcal{H}\)</span>关于一个集合 <span class="math inline">\(Z\)</span> 和 损失函数 <spanclass="math inline">\(l:\mathcal{H}\times Z\rightarrow\mathbb{R}_+\)</span> 是 Agnostic PAC 可学习的</p></div><h1 id="reference">Reference</h1><p>Shai Shalev-Shwartz, Shai Ben-David. <ahref="https://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/index.html">UnderstandingMachine Learning: From Theory to Algorithms</a></p>]]></content>
    
    <summary type="html">
    
      本文主要介绍机器学习中一种较通用的 PAC 学习模型及其拓展形式。
    
    </summary>
    
    
      <category term="从理论到算法理解机器学习" scheme="https://cosmosning.github.io/categories/%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="PAC" scheme="https://cosmosning.github.io/tags/PAC/"/>
    
      <category term="Agnostic PAC" scheme="https://cosmosning.github.io/tags/Agnostic-PAC/"/>
    
      <category term="Generalized loss function" scheme="https://cosmosning.github.io/tags/Generalized-loss-function/"/>
    
  </entry>
  
  <entry>
    <title>统计学习框架及经验风险最小化</title>
    <link href="https://cosmosning.github.io/2020/09/16/statistical-learning-framework-and-empirical-risk-minimization/"/>
    <id>https://cosmosning.github.io/2020/09/16/statistical-learning-framework-and-empirical-risk-minimization/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-09-16T01:02:33.000Z</published>
    <updated>2023-06-02T11:13:14.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍两个内容：</p><ol type="1"><li><strong>统计学习框架</strong>。这是一个十分通用的框架，指明了学习的<strong>输入</strong>、<strong>输出</strong>和<strong>学习目标</strong>。</li><li><strong>经验风险最小化</strong>（<strong>ERM</strong>）的学习方法。引入<strong>经验风险</strong>，从而可以<strong>从训练数据中管中窥豹</strong>，归纳出一般规律。但是ERM<strong>会产生过拟合</strong>现象。一种常见的解决方案是<strong>引入归纳偏好</strong>（或者是先验知识）。具体来说，确定一个有<strong>限的假设类</strong>集合，供学习算法学习。这样是否是有效的？通过证明发现，<strong>只要有足够的训练样本，就可以达到比较好的效果</strong>。</li></ol></blockquote><h1 id="a-formal-model-the-statistical-learning-framework">A FormalModel —— The Statistical Learning Framework</h1><h2 id="the-learners-input">The Learner's Input</h2><ul><li><strong>领域集（<em>Domainset</em>）</strong>：这是我们<strong>希望标记的事物的集合</strong>，记作<span class="math inline">\(\mathcal{X}\)</span>。通常情况下，人们会用一个特性向量（vector of<em>features</em>）表示这些领域点（<em>domain points</em>）。</li></ul><div class="note info"><ul><li>领域集（<em>domain set</em>）又称作实例空间（<em>instancespace</em>）</li><li>领域点（<em>domainpoints</em>）又称作实例（<em>instances</em>）</li></ul></div><ul><li><strong>标签集（<em>Labelset</em>）</strong>：这是<strong>可能的标签的集合</strong>，记作 <spanclass="math inline">\(\mathcal{Y}\)</span> 。</li><li><strong>训练数据（<em>Trainingdata</em>）</strong>：这是一系列已经被标记的领域点，常常表示为 <spanclass="math inline">\(S=((x_1,\ y_1)\dots(x_m,\ y_m))\)</span> （这是在<span class="math inline">\(\mathcal{X}\times \mathcal{Y}\)</span>中的<strong>有限</strong>的数对序列）</li></ul><div class="note info"><ul><li>训练数据（<em>training data</em>）又称作 <strong><em>trainingexamples</em></strong>，或者 <strong><em>training set</em></strong></li></ul></div><h2 id="the-learners-output">The Learner's Output</h2><p>人们希望学习器输出一个<strong>预测规则</strong>（<em>predictionrule</em>）：<span class="math inline">\(h:\mathcal{X} \rightarrow\mathcal{Y}\)</span>。这个函数又称作为<strong>预测器</strong>（<em>predictor</em>）、<strong>假设</strong>（<em>hypothesis</em>）或者是<strong>分类器</strong>（<em>classifier</em>）。此外，我们记一个学习算法<span class="math inline">\(A\)</span> ，接受训练数据 <spanclass="math inline">\(S\)</span> 为输入，返回对应假设为 <spanclass="math inline">\(A(S)\)</span> 。</p><h2 id="a-simple-data-generation-model">A Simple Data-generationModel</h2><p>训练数据是如何生成的？这里给出两个假设。</p><ul><li>假设所有的实例都由一个概率分布生成，记这个在 <spanclass="math inline">\(\mathcal{X}\)</span> 上的概率分布为 <spanclass="math inline">\(\mathcal{D}\)</span> 。</li><li>假设存在一个“完全正确”的标记函数 <spanclass="math inline">\(f:\mathcal{X}\rightarrow \mathcal{Y}\)</span>，显然，对于任意的 <span class="math inline">\(i\)</span> ，有 <spanclass="math inline">\(y_i=f(x_i)\)</span></li></ul><p>总的来说，在训练数据中的每一个数对，都由以下方式生成：</p><ol type="1"><li>先从概率分布 <span class="math inline">\(\mathcal{D}\)</span>采样得到一个点 <span class="math inline">\(x_i\)</span> ；</li><li>再利用标记函数 <span class="math inline">\(f\)</span> 为 <spanclass="math inline">\(x_i\)</span> 打上标签。</li></ol><h2 id="measures-of-success">Measures of Success</h2><p>如何衡量算法学习是否成功？这里可以定义一个<strong>分类器的误差</strong>（<em>errorof aclassifier</em>），即学习算法没有正确预测随机数据（这些随机数据，是由前面提到的对于学习算法隐含的概率分布所生成的）的标签的概率。也就是说，<spanclass="math inline">\(h\)</span> 的误差是<strong>从分布 <spanclass="math inline">\(\mathcal{D}\)</span> 随机中取出一个 <spanclass="math inline">\(x\)</span> ，而 <spanclass="math inline">\(h(x)\)</span> 不等于 <spanclass="math inline">\(f(x)\)</span> 的概率</strong>。</p><p>规范的来讲，给定一个领域子集（<em>domain subset</em>），<spanclass="math inline">\(A\subset \mathcal{X}\)</span> ，概率分布 <spanclass="math inline">\(\mathcal{D}\)</span> ，定义一个数 <spanclass="math inline">\(\mathcal{D}(A)\)</span> ，其中 <spanclass="math inline">\(\mathcal{D}(A)\)</span> 表示学习算法在 <spanclass="math inline">\(\mathcal{D}\)</span> 中观察到一个点 <spanclass="math inline">\(x\in A\)</span>的可能性。我们定义预测规则（<em>prediction rule</em>）的误差如下： <spanclass="math display">\[L_{\mathcal{D},f}(h)\overset{def}{=}\underset{x\sim\mathcal{D}}{\mathbb{P}}[h(x)\nef(x)]\overset{def}{=}\mathcal{D}(\lbrace x:h(x)\ne f(x)\rbrace)\tag{2.1}\]</span> <div class="note info"><p><strong>有关 <span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(\mathcal{D}(A)\)</span> 的补充说明</strong></p><ul><li>在许多情况下，我们将 <span class="math inline">\(A\)</span>称作一个事件（<em>event</em>）</li><li>二元分类问题中，我们定义 <span class="math inline">\(A\)</span> 为<span class="math inline">\(\pi :\mathcal{X}\rightarrow\lbrace0,1\rbrace\)</span> ，也就有 <span class="math inline">\(A =\lbrace x\in\mathcal{X}: \pi(x) = 1\rbrace\)</span>。在这种情况下，我们也使用 <span class="math inline">\(\mathbb{P}_{x\sim\mathcal{D}}[\pi(x)]\)</span> 来表达 <spanclass="math inline">\(\mathcal{D}(A)\)</span> 。</li></ul></div></p><div class="note info"><p><strong><span class="math inline">\(L_{\mathcal{D},f}\)</span>的别称</strong></p><p><span class="math inline">\(L_{\mathcal{D},f}\)</span>又称作<strong>泛化误差</strong>（<strong><em>generalizationerror</em></strong>），<strong>风险</strong>（<strong><em>risk</em></strong>），<strong><spanclass="math inline">\(h\)</span> 的真正误差</strong>（<strong><em>trueerror</em> of h</strong>）</p></div><h2 id="a-note-about-the-information-available-to-the-learner">A Noteabout The Information Available to The Learner</h2><p>要注意的是，<strong>学习器本身并不知晓隐含的概率分布 <spanclass="math inline">\(\mathcal{D}\)</span> 和 “完全正确” 的标记函数<span class="math inline">\(f\)</span></strong>。因此，学习器只能通过观察训练数据集，和环境交互，才能发现规律。</p><div class="note info"><h2 id="summary">Summary</h2><ul><li><strong>学习算法的输入和输出</strong>：一个学习算法接受一个<strong>训练集</strong><span class="math inline">\(S\)</span>作为<strong>输入</strong>，并且<strong>输出</strong>一个<strong>预测器</strong>（<em>predictor</em>）<span class="math inline">\(h_S: \mathcal{X} \rightarrow\mathcal{Y}\)</span> 。其中，训练集 <spanclass="math inline">\(S\)</span> 通过以下过程生成：首先从一个未知分布<span class="math inline">\(D\)</span>中采样，然后使用目标函数（<em>target function</em>） <spanclass="math inline">\(f\)</span> 标记。此外，预测器 <spanclass="math inline">\(h_S\)</span> 的下标 <spanclass="math inline">\(S\)</span> 强调了输出的 <spanclass="math inline">\(h_S\)</span> 是依赖于 <spanclass="math inline">\(S\)</span> 的。</li><li><strong>学习算法的目标</strong>：学习算法的目标是找到一个 <spanclass="math inline">\(h_S\)</span> ，关于未知分布 <spanclass="math inline">\(\mathcal{D}\)</span> 和标记函数 <spanclass="math inline">\(f\)</span> ，它能最小化误差。</li></ul></div><h1 id="empirical-risk-minimization-erm">Empirical Risk Minimization（ERM）</h1><h2 id="empirical-error">Empirical Error</h2><p>由于学习器并不知道 <span class="math inline">\(\mathcal{D}\)</span>和 <span class="math inline">\(f\)</span>，因此，式（2.1）无法直接计算。学习器能够计算的是<strong>训练误差</strong>（<em>trainingerror</em>），即分类器在训练数据上产生的误差，其定义如下： <spanclass="math display">\[L_S(h)\overset{def}{=}\frac{|\lbrace i\in[m]:h(x_i)\ne y_i\rbrace|}{m}\tag{2.2}\]</span></p><p>其中 <span class="math inline">\([m]=\lbrace 1,\dots,m\rbrace\)</span> 。</p><div class="note info"><p><strong>训练误差</strong>（<em>trainingerror</em>）有时又称作<strong>经验误差</strong>（<strong><em>empiricalerror</em></strong>）或者<strong>经验风险</strong>（<strong><em>empiricalrisk</em></strong>）</p></div><h2 id="erm">ERM</h2><p>既然学习算法能够从训练数据中获取关于这个世界的简要情况，所以寻找一个在训练数据上效果良好的答案是说得通的。<strong>寻找一个最小化<span class="math inline">\(L_S(h)\)</span> 的 <spanclass="math inline">\(h\)</span></strong>的学习范式称作经验风险最小化（<strong>Empirical RiskMinimization</strong>），简称 <strong>ERM</strong></p><h2 id="the-problem-of-erm-overfitting">The problem of ERM ——Overfitting</h2><p>然而，ERM 可能会产生一种错误——过拟合。下面用一个例子说明。</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/09/example-of-overfitting.PNG"alt="过拟合的例子. Source:《Understanding Machine Learning: From Theory to Algorithms》" /><figcaption aria-hidden="true">过拟合的例子. Source:《UnderstandingMachine Learning: From Theory to Algorithms》</figcaption></figure><p>假设概率分布 <span class="math inline">\(\mathcal{D}\)</span>是灰色正方形框中的均匀分布，如果实例落在蓝色实例所在的黑色正方形框中，标记函数<span class="math inline">\(f\)</span> 将其标记为 1，否则标记为0。考虑如下的预测器：</p><p><span class="math display">\[h_S(x)= \begin{cases}y_i\quad &amp;if\ \exists i\in[m]\ s.t. x_i=x;\\0\quad &amp;ohterwise. \end{cases}\]</span></p><p>因为 <span class="math inline">\(h_S\)</span>在训练数据上，对实例标签的预测全部正确，所以 <spanclass="math inline">\(L_S(h_s) = 0\)</span>。根据经验风险最小化的原则，式子 （2.3）会被 ERM 选中（因为没有比 0更小的训练损失）。然而如果取训练数据以外的一个点 <spanclass="math inline">\(x&#39;\)</span>，并且这个点在黑色正方形框中，那么根据式（2.3），<spanclass="math inline">\(h_S(x&#39;) = 0\)</span> 。而实际上 <spanclass="math inline">\(f(x&#39;) = 1\)</span>，这就会产生错误。</p><p>这种现象称作<strong>“过拟合”</strong>（<em>overfitting</em>）。直观的来说，当学习算法找到的假设<strong>太符合</strong>训练数据时，就会发生过拟合。</p><h2 id="empirical-risk-minimization-with-inductive-bias">Empirical RiskMinimization with Inductive Bias</h2><h3 id="applying-erm-over-a-restricted-search-space">Applying ERM over aRestricted Search Space</h3><p>一种常见的解决 ERM 过拟合的方法是<strong>限制 ERM的搜索空间</strong>。规范的讲，在见到数据之前，学习器应该事先挑选出一个预测器集合。这个预测器集合又称作<strong>“假设类”</strong>（<em>hypothesisclass</em>），记作 <span class="math inline">\(\mathcal{H}\)</span>。每一个 <span class="math inline">\(h\in \mathcal{H}\)</span> 是一个<span class="math inline">\(\mathcal{X}\rightarrow \mathcal{Y}\)</span>的函数。<strong>给定一个假设类 <spanclass="math inline">\(\mathcal{H}\)</span> ，一个训练集 <spanclass="math inline">\(\mathcal{S}\)</span> ，<spanclass="math inline">\(ERM_{\mathcal{H}}\)</span> 学习器使用 ERM规则来选取一个在 <span class="math inline">\(\mathcal{S}\)</span>上有最小可能误差的 <span class="math inline">\(h\)</span> ，其中 <spanclass="math inline">\(h\in \mathcal{H}\)</span></strong>。规范地，我们有如下公式： <span class="math display">\[ERM_{\mathcal{H}}(S)\in \underset{h\in \mathcal{H}}{argmin}(L_S(h))\]</span> 其中，<span class="math inline">\(argmin\)</span> 表示在 <spanclass="math inline">\(\mathcal{H}\)</span> 中使得 <spanclass="math inline">\(L_S(h)\)</span> 最小的假设集合（<spanclass="math inline">\(h\in\mathcal{H}\)</span>）。通过限制学习器从 <spanclass="math inline">\(\mathcal{H}\)</span>中选取预测器，学习器会偏向我们所特定的预测器集合。这种限制常常被称为<strong>归纳偏好</strong>（<em>inductivebias</em>）。由于这种限制的选择在学习器看到数据之前就确定了，因此在理想情况下，它应该基于一些有关所学问题的先验知识（<em>priorknowledge</em>）。</p><p>直观地，<strong>选择一个首先更多的假设类会更好地防止过拟合的发生，但是与此同时，这可能会导致一个更强的归纳偏好</strong>。</p><h3 id="finite-hypothesis-classes">Finite Hypothesis Classes</h3><p>对类的最简单的限制是设置一个其大小的上界（也就是，限制 <spanclass="math inline">\(\mathcal{H}\)</span> 中预测器 <spanclass="math inline">\(h\)</span> 的个数）。对应的，我们有如下结论：</p><ul><li><strong>只要有足够数量的训练样本，如果 <spanclass="math inline">\(\mathcal{H}\)</span> 是一个有限的类（<em>finiteclass</em>），那么 <spanclass="math inline">\(ERM_{\mathcal{H}}\)</span>将不会产生过拟合。</strong></li></ul><p>那么至少需要多少训练样本呢？下面我们讨论这个问题</p><p>在此之前，我们先引入两个假设：</p><ol type="1"><li><strong>可实现假设</strong>（<strong><em>The RealizabilityAssumption</em></strong>）：<span class="math inline">\(\exists h^\star\in \mathcal{H},\ L_{(\mathcal{D},f)}(h^\star) = 0\)</span> 。</li><li><strong>独立同分布假设</strong>（<strong><em>The i.i.d.Assumption</em></strong>）：训练数据中每一个样本都关于分布 <spanclass="math inline">\(\mathcal{D}\)</span><strong>独立同分布</strong>（<strong>independently and identicallydistributed</strong>，short for <strong>i.i.d.</strong>），记作 <spanclass="math inline">\(S\sim D^m\)</span> 。其中， <spanclass="math inline">\(m\)</span> 是 <spanclass="math inline">\(S\)</span> 的大小，<spanclass="math inline">\(D^m\)</span> 表示了根据 <spanclass="math inline">\(\mathcal{D}\)</span> 采样 <spanclass="math inline">\(m\)</span> 个元素，构成 <spanclass="math inline">\(m\)</span> 元组，且每一个元素都独立于 <spanclass="math inline">\(m\)</span> 元组其他元素</li></ol><div class="note info"><p><strong>有关 <code>可实现假设</code> 和 <code>独立同分布假设</code>的补充说明</strong></p><ul><li><code>可实现假设</code> 暗示了在随机的训练样本 <spanclass="math inline">\(S\)</span> ，<spanclass="math inline">\(S\)</span> 由从 <spanclass="math inline">\(\mathcal{D}\)</span> 中采样，又被 <spanclass="math inline">\(f\)</span> 标记所得，<spanclass="math inline">\(L_S(h^\star) = 0\)</span> 的可能性为 1。</li><li><code>独立同分布假设</code> 表示每一个 <spanclass="math inline">\(S\)</span> 中 <spanclass="math inline">\(x_i\)</span> 都是全新地从 <spanclass="math inline">\(\mathcal{D}\)</span> 中采样，并被 <spanclass="math inline">\(f\)</span> 标记后生成的。</li></ul></div><p>此外，定义 <span class="math inline">\(\delta\)</span>为取得一个不具代表性（<em>nonrepresentative</em>）的样本的<strong>概率</strong>，<spanclass="math inline">\(1-\delta\)</span>为预测行为的<strong>置信参数</strong>（<em>confidenceparameter</em>）。</p><div class="note info"><p><strong>什么叫不具代表性（<em>nonrepresentative</em>）的样本？</strong></p><ul><li>这个样本不能代表实例的潜在规律。如一个水果本身很好吃，但是碰巧训练样本都是不好吃的，导致学习器学到了错误的结论。其中的不好吃的训练样本即是不具代表性的样本。</li></ul></div><p>由于我们不能确保完美的标签预测，因此这里我们进一步引入另一个用来衡量预测效果的参数，即<strong>精度参数</strong>（<em>accuracyparameter</em>）。其通常记作 <spanclass="math inline">\(\epsilon\)</span>。我们用如下公式描述学习器是否获得成功：</p><ul><li>事件 <spanclass="math inline">\(L_{(\mathcal{D},f)}(h_s)&gt;\epsilon\)</span>表示学习器的<strong>失败</strong></li><li>事件 <span class="math inline">\(L_{(\mathcal{D},f)}(h_S)\le\epsilon\)</span> 表示学习器的<strong>近似成功</strong>。</li></ul><p>令我们感兴趣的是，在由 <span class="math inline">\(m\)</span>个实例构成的 <span class="math inline">\(m\)</span>元组采样，会导致学习器失败的概率的<strong>上界</strong>。</p><p>规范的，记 <span class="math inline">\(S|_{x} = \lbrace x_1,\ \dots,\x_m\rbrace\)</span> 为训练数据的实例，我们希望找到下式的上界：</p><p><span class="math display">\[\mathcal{D}(\lbrace S|_{x} : L_{(\mathcal{D},f)}(h_{S}) &gt; \epsilon\rbrace)\]</span></p><p>记 <span class="math inline">\(\mathcal{H}_B\)</span>为“坏的”假设，即</p><p><span class="math display">\[\mathcal{H}_B = \lbrace h\in\mathcal{H}: L_{(\mathcal{D},f)}(h) &gt;\epsilon\rbrace\]</span></p><p>再令</p><p><span class="math display">\[M = \lbrace S|_x : \exists h\in \mathcal{H}_B, L_S(h) = 0 \rbrace\]</span></p><p>显然，<span class="math inline">\(M\)</span>表示了误导学习器的样本集合。换句话说，对于每一个 <spanclass="math inline">\(S|_x \in M\)</span> ，存在一个坏的假设，<spanclass="math inline">\(h\in \mathcal{H}_B\)</span> ，但是在 <spanclass="math inline">\(S|_x\)</span> 中它看上去是一个好的假设。</p><p>既然可实现假设表示存在 <span class="math inline">\(L_S(h_S) =0\)</span> ，因此，事件 <spanclass="math inline">\(L_{(\mathcal{D},f)}(h_s)&gt;\epsilon\)</span>只可能在这种情况下发生：<span class="math inline">\(h\in\mathcal{H}_B\)</span> ，但是 <span class="math inline">\(L_S(h) =0\)</span>。也就是说，<strong>如果我们的采样样本在误导集合中，这种事件才会发生</strong>。因此，我们有：</p><p><span class="math display">\[\lbrace S|_{x} : L_{(\mathcal{D},f)}(h_S) &gt; \epsilon\rbrace \subseteqM\]</span></p><p>进一步的，<span class="math inline">\(M\)</span> 可改写成：</p><p><span class="math display">\[M = \underset{h\in \mathcal{H}_B}{\bigcup} \lbrace S|_x : L_S(h) =0\rbrace \tag{2.5}\]</span></p><p>因此，</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_{(\mathcal{D},f)}(h_S) &gt;\epsilon\rbrace) \le \mathcal{D}^m(M) = \mathcal{D}^m({\cup}_{h\in\mathcal{H}_B} \lbrace S|_x : L_S(h) = 0\rbrace) \tag{2.6}\]</span></p><p>利用 <code>Union Bound</code> 定理，可得：</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_{(\mathcal{D},f)}(h_S) &gt;\epsilon\rbrace) \le \underset{h\in\mathcal{H}_B}{\sum}\mathcal{D}^m(\lbrace S|_x : L_S(h) =0\rbrace)\tag{2.7}\]</span></p><div class="note info"><p><strong>定理（Union Bound）</strong></p><ul><li>对于两个集合 <span class="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span> 和分布 <spanclass="math inline">\(\mathcal{D}\)</span> ，有 <spanclass="math display">\[\mathcal{D}(A\cup B) \le \mathcal{D}(A) + \mathcal{D}(B)\]</span></li></ul></div><p>由于事件 <span class="math inline">\(L_S(h) = 0\)</span> 等价于 <spanclass="math inline">\(\forall i, h(x_i) = f(x_i)\)</span> ，所以，</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_S(h) = 0\rbrace) = \mathcal{D}^m(\lbraceS|_x : \forall i, h(x_i) = f(x_i) \rbrace)\]</span></p><p>又因为采样训练样本相互独立，且服从同一个分布 <spanclass="math inline">\(\mathcal{D}\)</span> ，因此，</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : \forall i, h(x_i) = f(x_i) \rbrace) =\prod_{i=1}^{m}\mathcal{D}(\lbrace x_i : h(x_i) = f(x_i) \rbrace)\]</span></p><p>故有</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_S(h) = 0\rbrace) =\prod_{i=1}^{m}\mathcal{D}(\lbrace x_i : h(x_i) = f(x_i) \rbrace)\tag{2.8}\]</span></p><p>对于训练集中每一个独立的元素，有</p><p><span class="math display">\[{D}(\lbrace x_i : h(x_i) = y_i \rbrace) = 1 - L_{(\mathcal{D},f)}\]</span></p><p>由于 <spanclass="math inline">\(L_{(\mathcal{D},f)}(h_s)&gt;\epsilon\)</span>，故</p><p><span class="math display">\[{D}(\lbrace x_i : h(x_i) = y_i \rbrace) = 1 - L_{(\mathcal{D},f)} \le 1- \epsilon\]</span></p><p>利用 <span class="math inline">\(1-\epsilon \lee^{-\epsilon}\)</span> 不等式对上式放缩，有</p><p><span class="math display">\[{D}(\lbrace x_i : h(x_i) = y_i \rbrace) = 1 - L_{(\mathcal{D},f)} \le 1- \epsilon \le e^{- \epsilon}\]</span></p><p>将上式带入式（2.8），有</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_S(h) = 0\rbrace)\le (1 - \epsilon)^m \lee^{- m\epsilon} \tag{2.9}\]</span></p><p>结合式（2.7），有</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_{(\mathcal{D},f)}(h_S) &gt;\epsilon\rbrace) \le |\mathcal{H}_B|e^{- m\epsilon} \le|\mathcal{H}|e^{- m\epsilon}\]</span></p><p>设 <span class="math inline">\(\mathcal{D}^m(\lbrace S|_x :L_{(\mathcal{D},f)}(h_S) &gt; \epsilon\rbrace) \le |\mathcal{H}|e^{-m\epsilon}&lt; \delta\)</span> ，则有</p><p><span class="math display">\[m &gt; \frac{log(\frac{|\mathcal{H}|}{\delta})}{\epsilon}\]</span></p><div class="note info"><p><strong>推导过程</strong></p><p><span class="math display">\[\delta &gt; |\mathcal{H}|e^{-m\epsilon}\]</span></p><p><span class="math display">\[log\delta &gt; log|\mathcal{H}|-m\epsilon\]</span></p><p><span class="math display">\[m\epsilon &gt; log|\mathcal{H}| - log\delta\]</span></p><p><span class="math display">\[m&gt; \frac{log(\frac{|\mathcal{H}|}{\delta})}{\epsilon}\]</span></p></div><p>综上所述，有如下重要结论：</p><div class="note info"><p>设 <span class="math inline">\(\mathcal{H}\)</span>为一个有限的假设类，令 <span class="math inline">\(\delta \in(0,1)\)</span> ，<span class="math inline">\(\epsilon &gt; 0\)</span>，<span class="math inline">\(m\)</span> 为一个满足以下条件的整数：<span class="math display">\[m&gt; \frac{log(\frac{|\mathcal{H}|}{\delta})}{\epsilon}\]</span> 那么，对于任意的标记函数 <spanclass="math inline">\(f\)</span> ，任意的分布 <spanclass="math inline">\(\mathcal{D}\)</span>，如果满足可实现假设（即，存在 <span class="math inline">\(h\in\mathcal{H}\)</span> ，使得 <spanclass="math inline">\(L_{(\mathcal{D},f)}(h) = 0\)</span>），则至少有<span class="math inline">\(1-\delta\)</span> 的可能性，在 <spanclass="math inline">\(S\)</span> 上独立采样 <spanclass="math inline">\(m\)</span> 个点，对于每一个 <spanclass="math inline">\(ERM\)</span> 假设，满足如下式子： <spanclass="math display">\[L_{(\mathcal{D},f)}(h_S) \le \epsilon\]</span></p></div><p>这个结论意味着，只要有足够的训练数据（<spanclass="math inline">\(m&gt;\frac{log(\frac{|\mathcal{H}|}{\delta})}{\epsilon}\)</span>），在有限假设类上的<span class="math inline">\(ERM_{\mathcal{H}}\)</span>会尽可能近似正确（其置信参数为 <spanclass="math inline">\(1-\delta\)</span> ，最大的误差为 <spanclass="math inline">\(\epsilon\)</span>）。</p><h1 id="reference">Reference</h1><p>Shai Shalev-Shwartz, Shai Ben-David. <ahref="https://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/index.html">UnderstandingMachine Learning: From Theory to Algorithms</a></p>]]></content>
    
    <summary type="html">
    
      机器学习中有一个形式化的模型——统计学习框架，它是如何定义的？经验风险最小化（ERM）是一个十分基础的学习范式，它的学习目标是什么？为什么它是有效的？
    
    </summary>
    
    
      <category term="从理论到算法理解机器学习" scheme="https://cosmosning.github.io/categories/%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Statistical learning framework" scheme="https://cosmosning.github.io/tags/Statistical-learning-framework/"/>
    
      <category term="Empirical risk minimization" scheme="https://cosmosning.github.io/tags/Empirical-risk-minimization/"/>
    
  </entry>
  
  <entry>
    <title>《从理论到算法理解机器学习》引言</title>
    <link href="https://cosmosning.github.io/2020/09/13/intro-to-ml/"/>
    <id>https://cosmosning.github.io/2020/09/13/intro-to-ml/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-09-13T06:51:46.000Z</published>
    <updated>2023-06-02T11:13:14.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近上了一门课，叫做“智能信息检索”。老师推荐了一本教材《Understanding Machine Learning: From Theory toAlgorithms》（文末提供官方下载链接），来解释<strong>智能</strong>的含义。本文基于我对教材的理解，对其引言部分做了一些要点概括，供读者参考。</p></blockquote><h1 id="what-is-learning">What Is Learning？</h1><p>粗略地讲，<strong>学习是一个将经历（<em>experience</em>）转换为技能（<em>expertise</em>）或知识（<em>knowledge</em>）的过程</strong>。一般地，一个学习算法的<strong>输入</strong>是<strong>训练数据</strong>（代表经历），<strong>输出</strong>是<strong>技能</strong>。</p><p>一种常见的学习方法是 “记忆学习”（<em>learning bymemorization</em>）。类似人类学习的“死记硬背”，这种学习方法有时候十分有效，但是它却缺失了学习系统中一个十分重要的能力，即<strong>泛化能力</strong>（<em>generalization</em>）。换句话讲，一个成功的学习系统理应能够依据已知知识，正确处理未知的情况。</p><div class="note info"><p><strong>泛化能力</strong> （<em>generalization</em>）有时也被称作<strong>归纳推理</strong> （<em>inductive reasoning /inductive inference</em>）</p></div><p>然而，<strong>归纳推理可能会导致错误结论</strong>。那么怎样才能减少犯错呢？</p><p>答案是：在学习系统中<strong>引入先验知识</strong>（<em>priorknowledge</em>）！</p><div class="note info"><p><strong>先验知识</strong>（<em>prior knowledge</em>）有时也被称作<strong>归纳偏好</strong> （<em>inductive bias</em>）</p></div><p>从书中举得几个例子来看，<strong>引入先验知识，使整个学习过程带有偏好，是一个成功的学习算法必然发生的事情</strong>（这种现象是<strong>No-Free-Lunch Theorem</strong>的具体表现）。粗略来说，学习算法开始训练时所引入的先验知识越强，从训练样本中学习就越简单。但是，先验知识越强，学习的灵活性也就越低，因为整个学习过程被这些预定假设束缚住了。</p><h1 id="when-we-need-machine-learning">When We Need MachineLearning？</h1><p>那么，在哪些情况下，我们需要利用机器学习解决问题呢？主要有以下两个方面：</p><ul><li>问题的复杂性（<em>complexity</em>）</li><li>任务的适应性需求（<em>adaptivity</em>）</li></ul><h2 id="tasks-that-are-to-complex-to-program">Tasks That Are to Complexto Program</h2><ul><li><em>Tasks Performed by Animals /Humans</em>：我们暂时无法理解一些我们能够处理的日常任务，例如驾驶汽车、语音识别、图像理解。以现有的知识，难以抽象出一个良好的程序去执行这些任务。然而，先进的机器学习程序，只要接受足够的训练样本训练，就可以从中学习经验，并在这些任务中达到不错的效果。</li><li><em>Tasks beyond HumanCapabilities</em>：另一类适合用机器学习解决的问题是对巨大的且复杂的数据（例如宇宙空间数据、医疗数据、天气数据等）进行分析。这些数据的处理和分析通常超越了我们自身的分析能力。使用机器学习，可以充分利用计算机的能力，找到数据中有价值的信息。</li></ul><h2 id="adaptivity">Adaptivity</h2><ul><li>预先编程的程序有一个缺陷，即死板性（<em>rigidity</em>）。也就是说，一旦程序写好了，安装到系统中后，程序就不会变化了。然而，现实中许多任务都是在不断变化的。</li><li>而机器学习（其天生可以适应不同的输入数据）提供了一种解决此类任务的方案。</li></ul><h1 id="types-of-learning">Types of Learning</h1><h2 id="supervised-versus-unsupervised">Supervised versusUnsupervised</h2><p>如果将学习看作是一个“利用经历来获取技能”的过程，那么监督学习和非监督学习可以描述如下：</p><ul><li><strong>监督（<em>Supervised</em>）学习</strong>：在该场景中，“经历”（亦可称作训练样本）包含了十分重要的信息；而这些信息却在测试样本中丢失了。从监督学习中学习到的技能的目标是，预测测试数据中的确实信息。这就好像环境作为一名老师通过提供额外的信息（通常称作<strong>“标签”</strong><em>label</em>）"监督"学生（学习算法）的学习。</li><li><strong>非监督（<em>Unsupervised</em>）学习</strong>：对于非监督学习来说，训练数据和测试数据几乎没什么区别。通常，这种学习方法通过处理输入数据，来达到<strong>总结数据</strong>、<strong>压缩数据</strong>的目标。<strong>聚类</strong>——将一个数据集分成几个子集，同一子集具有相似性——是非监督学习中一个典型的例子。</li><li>在监督与非监督之间，还存在一种不同的方法——<strong>强化学习</strong>。</li></ul><h2 id="active-versus-passive">Active versus Passive</h2><ul><li><strong>主动（<em>Active</em>）学习</strong>：主动学习在在训练过程中将会与环境交互。</li><li><strong>被动（<em>Passive</em>）学习</strong>：被动学习只会观测环境所提供的信息，而不会影响（influence）或指导（direct）它。</li></ul><div class="note info"><p><strong>例子</strong></p><ul><li>垃圾邮件识别通常是被动学习，因为它等着用户为它标记收到的邮件是否是垃圾邮件。</li><li>在主动学习的场景下，学习算法会在训练过程中要求用户标记它指定的邮件，或者甚至是由学习算法生成的邮件，来增强它对什么是垃圾邮件的理解。</li></ul></div><h2 id="helpful-of-the-teacher">Helpful of the Teacher</h2><ul><li>主动提供信息<ul><li>训练信息<strong>正相关</strong>——普通学习：例如，教师会不断尝试为学生提供最有用的信息，来达到某种学习目标。</li><li>训练信息<strong>负相关</strong>——<strong>对抗（<em>Adversarial</em>）学习</strong>：例如垃圾邮件生成器将会努力误导垃圾邮件识别器。</li></ul></li><li>被动提供信息<ul><li><strong>统计学习（<em>StatisticalLearning</em>）</strong>：有时候，信息并不是他人主动提供的。例如科学家在认识自然时，环境，作为一位老师，并不会根据学生的需求主动的提供信息，因此是被动的提供信息。这种情况下，输入数据常常被认为是由某种随机过程（<em>randomprocess</em>）产生。这样，就可以使用统计学习解决问题</li></ul></li></ul><h2 id="online-versus-batch-learning-protocol">Online versus BatchLearning Protocol</h2><ul><li><strong>在线学习（<em>OnlineLearning</em>）</strong>：学习算法必须在训练过程中，在线反馈。例如，股票交易员需要基于目前位置积累的经验，做出每日决策。虽说随着时间推移，他会称为一名专家，但是也可能在此过程中犯下代价高昂的错误。</li><li><strong>批处理学习（<em>BatchLearning</em>）</strong>：只有在处理大量的数据后，该算法才能获得所需的技能。在数据挖掘场景下，数据挖掘算法会处理大量的数据之后，才会得出相关的结论。</li></ul><h1 id="relations-to-other-fields">Relations to Other Fields</h1><h2 id="with-ai">With AI</h2><ul><li>机器学习是 AI 的一个分支。</li><li>机器学习更关注<strong>利用计算机的优势和独特的能力</strong>来<strong>补充</strong>人类的智能，因此常常处理一些远超人类能力的任务。</li><li>AI 更关注创造一个能够自动<strong>模仿</strong>智能行为的机器。</li></ul><h2 id="with-statistics">With Statistics</h2><ul><li>统计学：提出假设（专业人员） <spanclass="math inline">\(\rightarrow\)</span><strong>验证假设</strong>（统计学）</li><li>机器学习：利用数据，<strong>挖掘规律</strong>，解释原因。</li><li>机器学习对<strong>算法</strong>层面的考虑更多</li><li>统计学常常关注数据的<strong>渐进性</strong>（<strong>无穷</strong>情况下的特性），机器学习则关注<strong>有限</strong>的样本空间</li><li>统计学通常<strong>预先假设数据分布</strong>，而机器学习是<strong>分布无关</strong>的（<em>distribution-free</em>）</li></ul><h1 id="reference">Reference</h1><p>Shai Shalev-Shwartz, Shai Ben-David. <ahref="https://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/index.html">UnderstandingMachine Learning: From Theory to Algorithms</a></p>]]></content>
    
    <summary type="html">
    
      学习是什么？什么情况下我们需要机器学习？学习分为哪几种？机器学习和其他领域有什么样的关系？
    
    </summary>
    
    
      <category term="从理论到算法理解机器学习" scheme="https://cosmosning.github.io/categories/%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Learning" scheme="https://cosmosning.github.io/tags/Learning/"/>
    
      <category term="Generalization" scheme="https://cosmosning.github.io/tags/Generalization/"/>
    
      <category term="Inductive reasoning" scheme="https://cosmosning.github.io/tags/Inductive-reasoning/"/>
    
      <category term="Inductive inference" scheme="https://cosmosning.github.io/tags/Inductive-inference/"/>
    
      <category term="Prior knowledge" scheme="https://cosmosning.github.io/tags/Prior-knowledge/"/>
    
      <category term="Inductive bias" scheme="https://cosmosning.github.io/tags/Inductive-bias/"/>
    
      <category term="No-Free-Lunch Theorem" scheme="https://cosmosning.github.io/tags/No-Free-Lunch-Theorem/"/>
    
  </entry>
  
  <entry>
    <title>KAT: Keywords-to-SPARQL Translation Over RDF Graphs 阅读笔记</title>
    <link href="https://cosmosning.github.io/2020/09/12/notes-of-kat-keywords-to-sparql-translation-2018/"/>
    <id>https://cosmosning.github.io/2020/09/12/notes-of-kat-keywords-to-sparql-translation-2018/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-09-12T00:04:23.000Z</published>
    <updated>2023-06-02T11:13:14.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="highlights">Highlights</h1><ul><li><strong>Two-FacetIndexing</strong>：这篇文章的关键词索引和图索引看上去比较简单，而且十分高效。</li><li><strong>Context Aware Ranking</strong>：充分利用关键词的上下文信息和RDF 模式的信息，构建了一种十分有效的排序方法。</li></ul><h1 id="what">What？</h1><h2 id="problem">Problem</h2><p>将关键词查询高效的转换为 SPARQL查询（<em>keyword-to-SPARQL</em>）</p><h2 id="contributions">Contributions</h2><p>本文主要构建了一个关键词查询系统 <code>KAT</code>，它能够将<strong>关键词查询转换为 SPARQL查询</strong>。与现存方法不同的是，它考虑了上下文（<em>context</em>）信息和模式（<em>schema</em>）信息。主要的贡献如下：</p><ol type="1"><li>提出了一种新颖的关键词到 SPARQL转换（<em>keywords-to-SPARQL</em>）方法（叫做 <code>KAT</code>）。</li><li>构建了两个索引。一个为关键词索引（<strong>keywordindex</strong>），另一个为图索引（<strong>graph index</strong>）。</li><li>实验表明了 <code>KAT</code>的<strong>有效性</strong>和<strong>高效性</strong>。</li></ol><h1 id="why">Why？</h1><h2 id="necessity-for-a-keyword-query-system-in-rdf-data">Necessity fora Keyword Query System in RDF Data</h2><ul><li>RDF 提供了一种灵活的方式表示知识</li><li>SPARQL 是 RDF 的结构化查询语言。但是对于普通用户，尤其是不了解 RDF内在模式（<em>schema</em>）或者是 SPARQL 语法的用户，使用 SPARQL 查询RDF 数据将会极度困难。</li><li>Keyword-to-SPARQL 通过自动地将关键词转换为 SPARQL查询语句，使得用户可以更加简单地探索 RDF 数据。</li></ul><h2 id="disadvantages-of-existing-approaches">Disadvantages of ExistingApproaches</h2><p>现存的解决方案无法有效并且高效地返回关键词查询的结果，主要原因如下：</p><ul><li>没有考虑输入关键词的上下文信息</li><li>没有利用 RDF 图的模式信息（例如与某个关键词相关的 RDF 类）</li></ul><h2 id="advantages-of-proposed-method">Advantages of ProposedMethod</h2><ul><li><code>KAT</code>利用了关键字之间的上下文关系，提高了查询结果的相关性。</li><li>含有 RDF 类（<em>class</em>）信息的关键词索引（<strong>keywordindex</strong>）将会解决关键词语义的模糊性问题（<em>disambiguation</em>），而图索引（<strong>graphindex</strong>）将会加速图的探索过程（<em>graphexploration</em>）。</li><li>实验表明 <code>KAT</code> 处理更快，并且结果质量更好</li></ul><h1 id="how">How？</h1><p>Keyword-to-SPARQL 方法的<strong>关键</strong>是在 RDF数据中找到一个<strong>子图</strong>，这个子图<strong>包含输入的关键词</strong>并且<strong>满足用户的需求</strong>。</p><h2 id="overview">Overview</h2><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/09/overview-of-kat.PNG"alt="Overview of KAT. Source: &quot;KAT: Keywords-to-SPARQL Translation Over RDF Graphs&quot;" /><figcaption aria-hidden="true">Overview of KAT. Source: "KAT:Keywords-to-SPARQL Translation Over RDF Graphs"</figcaption></figure><ul><li><strong>离线创建索引</strong>（<em>Offline Two-FacetIndexing</em>）：在离线处理流程中，系统将会创建两个索引，包括<strong>关键词索引</strong>和<strong>图索引</strong>。</li><li><strong>创建关键词-元素映射</strong>（<em>Keyword-to-ElementMapping</em>）：当用户提交了一个关键词查询任务后，KAT通过离线生成的关键词索引，将关键词映射到与之相关的顶点和边（这些顶点和边被称为<em>keyword elements</em>）。</li><li><strong>图探索</strong>（<em>GraphExploration</em>）：然后，基于图索引进行图探索阶段，以找到含有关键词的子图。</li><li><strong>排序</strong>（<em>Ranking</em>）：使用考虑上下文关系的评价方法，将子图从大到小排序。</li><li><strong>翻译</strong>（<em>Translation</em>）：将排序前几名的子图翻译成SPARQL 查询语句。</li></ul><h2 id="two-facet-indexing">Two-Facet Indexing</h2><h3 id="keyword-indexing">Keyword Indexing</h3><p><strong>功能</strong></p><p>将关键词映射到与之相关的元素。</p><p><strong>现存方案的不足</strong></p><p>现有方案中，关键词索引仅仅是一个简单的倒排索引（<em>invertedindex</em>）。因此，在构建映射关系时，<strong>所有包含关键词的元素都被当作候选结果，这其中包括大量的无用元素</strong>。为什么会这样呢？这是由于自然语言关键词的<strong>二义性</strong>（<em>ambiguity</em>）导致的。例如，用户输入这样一个查询，<code>{person, movie, lila}</code>。其查询意图为，找到在 “Lila Says” 中演出的演员。但是 “lila”却是一个模棱两可的关键词，她可能是一个人名，也可能是一张专辑名，甚至是一个地铁名。</p><p><strong>解决方案</strong></p><p>为了减少关键词的二义性，这篇文章提出了一种混合索引，作为关键词索引。这个索引<strong>包含了</strong>RDF数据中各个术语（<em>terms</em>）的<strong>类别信息</strong>。其具体结构如下图所示：</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/09/hybird-index.PNG"alt="Hybird Index. Source: &quot;KAT: Keywords-to-SPARQL Translation Over RDF Graphs&quot;" /><figcaption aria-hidden="true">Hybird Index. Source: "KAT:Keywords-to-SPARQL Translation Over RDF Graphs"</figcaption></figure><ul><li>每一个术语（<em>term</em>）都指向一个由与之相关的所有可能的 RDF类构成的 B 树。</li><li>包含术语的元素用 <span class="math inline">\((v_C,\ l_A,\v_L)\)</span> 表示，并且赋给 B 树上的对应结点，其中 <spanclass="math inline">\(v_C\in V_C,\ l_A\in L_A,\ v_L\in V_L\)</span> 。<ul><li><span class="math inline">\(V_C\)</span> 表示 RDF图中的<strong>类顶点</strong>（<em>classvertices</em>）<strong>集合</strong>。</li><li><span class="math inline">\(L_A\)</span> 表示 RDF图中的<strong>实体-字面量边标签</strong>（<em>entity-literal edgelabels</em>）<strong>集合</strong>。</li><li><span class="math inline">\(V_L\)</span> 表示 RDF图中的<strong>字面量顶点</strong>（<em>literalvertices</em>）<strong>集合</strong>。</li></ul></li></ul><p>此外，设关键词 <span class="math inline">\(w\)</span> 的关键词映射为<span class="math inline">\(f:(w,C)\rightarrow K\)</span> ，其中 <spanclass="math inline">\(C\)</span> 为关键词 <spanclass="math inline">\(w\)</span> 可能对应的 RDF类别（<em>class</em>）集合，<span class="math inline">\(K\)</span>是关键词元素集合。特别的，集合 <span class="math inline">\(C\)</span>由以下类（<em>class</em>）组成：</p><ul><li><strong>无二义性</strong>关键词中提及的类（<em>class</em>）（例如<code>person</code> 、<code>movie</code>）。</li><li>在 <strong>summary graph</strong> 中能在 n跳之内到达上述类的类。</li></ul><p><strong>预期效果</strong></p><p>这样，关键词就被映射到一个<strong>较小</strong>的并且<strong>高质量</strong>的关键词元素的集合上了。</p><h3 id="graph-indexing">Graph Indexing</h3><p><strong>功能</strong></p><p>为了更加高效地在图上探索。</p><p><strong>方案</strong></p><p>捕捉<strong>实体类别中的关系</strong>形成一个较小的 summarygraph，并将其当作图索引。一个例子如下图所示：</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/09/summary-graph.PNG"alt="Summary graph. Source: &quot;KAT: Keywords-to-SPARQL Translation Over RDF Graphs&quot;" /><figcaption aria-hidden="true">Summary graph. Source: "KAT:Keywords-to-SPARQL Translation Over RDF Graphs"</figcaption></figure><p><strong>图探索基本过程</strong></p><p>进行图探索常用的方法是后向搜索算法（<em>backward searchalgorithm</em>）。它在图索引上搜索符合条件的子图。该算法从关键词元素开始，然后沿着边进行迭代遍历，直到找到所有的连接点（<em>connectingvertices</em>）。一个例子如下图所示：</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/09/subgraph.PNG"alt="Subgraphs. Source: &quot;KAT: Keywords-to-SPARQL Translation Over RDF Graphs&quot;" /><figcaption aria-hidden="true">Subgraphs. Source: "KAT:Keywords-to-SPARQL Translation Over RDF Graphs"</figcaption></figure><h2 id="context-aware-ranking">Context Aware Ranking</h2><p><strong>现有标准方法及其不足</strong></p><p>现有方法基于子图的结构。具体来说，较小的子图往往是正确的答案。但是最小的子图并不一定满足用户的查询需求。</p><p><strong>Context Aware 方案</strong></p><p>为了克服这个缺陷，这篇文章提出了一种利用上下文信息的排名方法。通过这种方法可以<strong>计算子图和用户查找意图的相关性</strong>。具体的，该方法考虑了三种上下文信息：</p><ul><li>the relevance of a keyword element <spanclass="math inline">\((v_C,\ l_A,\ v_L)\)</span> referring to a<strong>literal vertex</strong> increases if there is a keywordreferring to a <code>class</code> <strong>semantically similar</strong>to <span class="math inline">\(v_C\)</span> .</li><li>the relevance of a keyword element <spanclass="math inline">\((v_C,\ l_A,\ null)\)</span> referring to an<strong>entity-literal edge</strong> increases if there is a keywordreferring to a <code>class</code> <strong>semantically similar</strong>to <span class="math inline">\(v_C\)</span> .</li><li>the relevance of a keyword element <spanclass="math inline">\((v_C,\ l_A,\ v_L)\)</span> referring to a<strong>literal vertex</strong> increases if there is a keywordreferring to an <code>entity-literal edge</code> <spanclass="math inline">\(l_A\)</span> whose related class is<strong>semantically similar</strong> to <spanclass="math inline">\(v_C\)</span> .</li></ul><p><strong>关键词元素打分算法</strong></p><p>下图算法 1 描述了关键词元素打分的流程：</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/09/algorithm-1.PNG"alt="Algorithm 1. Source: &quot;KAT: Keywords-to-SPARQL Translation Over RDF Graphs&quot;" /><figcaption aria-hidden="true">Algorithm 1. Source: "KAT:Keywords-to-SPARQL Translation Over RDF Graphs"</figcaption></figure><p>每个元素的分数都初始化为 <strong>0</strong>，并且基于上述三条规则递增。第 3 - 7 行遵循了第 1、2 条规则，第 8 - 12行遵循了第 3 条规则。下式给出了计算 <spanclass="math inline">\(c_1\)</span> 类和 <spanclass="math inline">\(c_2\)</span> 类的 semantic similarity 的方法：<span class="math display">\[sim(c_1,\ c_2)=\frac{|S(c_1,\ O)\ \cap S(c_2,\ O)|}{|S(c_1,\ O)\ \cupS(c_2,\ O)|}\tag{1}\]</span> 其中，<span class="math inline">\(S(c,\ O)\)</span> 是指在ontology <span class="math inline">\(O\)</span> 中 <spanclass="math inline">\(c\)</span> 的父类集合。</p><div class="note info"><p><strong>为什么这样计算类之间的 semantic similarity？</strong></p><ul><li><p>这是因为，<code>如果两个类拥有更多相同的父类，那么这两个类往往是相似的</code>。</p></li><li><p>式（1）中<strong>分子</strong>表示两个类的父类的交集的元素个数（也就是<strong>两者共有的父类个数</strong>），<strong>分母</strong>表示两个类的父类的并集的元素个数（也就是<strong>两者一共有多少不重复的父类</strong>）。</p></li><li><p>当分子越大，分母越小时，两者的 semantic similarity就越大，这与上述原因是一致的。</p></li></ul></div><p>给出两个关键词元素 <span class="math inline">\(k_1\)</span> 和 <spanclass="math inline">\(k_2\)</span> ，依据 <spanclass="math inline">\(k_1\)</span> ，<spanclass="math inline">\(k_2\)</span> 的相关度增量（<em>relevanceincrement</em>）可由下式得到： <span class="math display">\[rel(k_1,\ k_2) = \frac{sim(k_1.v_C,\ k_2.v_C)}{|pos(k_1) -pos(k_2)|}\tag{2}\]</span> 其中 <span class="math inline">\(pos(k)\)</span> 表示与 <spanclass="math inline">\(k\)</span>对应的关键词在关键词查询序列中的位置。</p><div class="note info"><p><span class="math inline">\(rel(k_1, k_2)\)</span><strong>的简要分析</strong></p><ul><li><p>式（2）<strong>分子</strong>表示关键词元素的<strong>类别之间的相似度</strong>，<strong>分母</strong>表示两个关键词元素所对应的<strong>关键词在关键词查询序列中的距离</strong>。</p></li><li><p>相似度越高，关键词距离越短，相应的 <spanclass="math inline">\(rel\)</span> 就越大。这个公式就巧妙地利用了<code>graph schema</code> 和 <code>关键词 的 context</code>。</p></li></ul></div><p><strong>后续计算流程</strong></p><ul><li><p><strong>子图分数的计算</strong>：将与子图相关的关键词元素的分数相加，并且除以子图中边的个数。即<span class="math display">\[Score_{subgraph} =\frac{\sum{Score_{relvant-keyword-elements}}}{|E_{relevant-in-subgraph}|}\]</span></p></li><li><p><strong>排序</strong></p></li><li><p><strong>翻译</strong></p></li></ul><h1 id="how-much">How much？</h1><ul><li><p>由于 KAT<strong>减少了关键词的模糊性</strong>，并且能够找到<strong>高度相关</strong>的子图，所以KAT 的效果相较于传统方法更好。</p></li><li><p>虽然混合索引的空间占用更大，生成索引时间更长，但是却能够<strong>更快、更好</strong>地返回关键词查询结果。</p></li></ul><h1 id="what-then">What Then？</h1><ul><li>挖掘更多关键词中的<strong>模式信息</strong>（<em>semanticalinformation</em>），来改进此方法。</li><li>可能存在某些方缩短<strong>图探索</strong>阶段的时间。</li></ul><h1 id="problems-to-solve">Problems to Solve</h1><p>阅读这篇文章产生了以下问题，需要未来花时间解决：</p><ul class="task-list"><li><input type="checkbox" disabled="" />倒排索引是什么？？</li><li><input type="checkbox" disabled="" />B 树是什么，怎么创建？</li><li><input type="checkbox" disabled="" />怎样构建 Summary Graph ？？算法流程？？</li><li><input type="checkbox" disabled="" />top graph -&gt; SPARQL Query ？？ 具体怎么处理？</li><li><input type="checkbox" disabled="" />理解 backward search algorithm ：阅读更多文献 [1] <a href="#fn1"class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，[2] <a href="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>， [3] <a href="#fn3"class="footnote-ref" id="fnref3"role="doc-noteref"><sup>3</sup></a></li><li><input type="checkbox" disabled="" />怎么理解文中提出了三种上下文信息规则？</li></ul><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>He, H., Wang, H., Yang, J., Yu, P.S.:BLINKS: ranked keyword searches on graphs. In: Proceedings of the 2007ACM SIGMOD International Conference on Management of Data, pp. 305–316.ACM (2007)<a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>Le, W., Li, F., Kementsietsidis, A.,Duan, S.: Scalable keyword search on large RDF data. IEEE Trans. Knowl.Data Eng. 26(11), 2774–2788 (2014)<a href="#fnref2"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p>Tran, T., Wang, H., Rudolph, S.,Cimiano, P.: Top-k exploration of query candidates for efficient keywordsearch on graph-shaped (RDF) data. In: 2009 IEEE 25th InternationalConference on Data Engineering, ICDE 2009, pp. 405–416. IEEE (2009)<ahref="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      这篇文章解决了一个关键字到 SPARQL 查询（keyword-to-SPARQL）的问题，提出了一个叫做 “KAT” 的解决方案。KAT 考虑了输入关键字的上下文关系，并且通过在 RDF 数据上构建含有关键字类别（class）信息的关键字索引（keyword index），减少了输入关键字的模糊性。为了高效地探索 RDF 数据图，KAT 也构建了一个图索引（graph index）。此外，这篇文章也提出了一种具有上下文意识（context aware）的排序方法，从而可以找到与输入关键字最相关的 SPARQL 查询语句。
    
    </summary>
    
    
      <category term="研究" scheme="https://cosmosning.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Keywords-to-SPARQL" scheme="https://cosmosning.github.io/tags/Keywords-to-SPARQL/"/>
    
      <category term="Two-facet index" scheme="https://cosmosning.github.io/tags/Two-facet-index/"/>
    
      <category term="Context aware" scheme="https://cosmosning.github.io/tags/Context-aware/"/>
    
  </entry>
  
  <entry>
    <title>Sci-Owl Weekly #3：如何阅读更多的书籍</title>
    <link href="https://cosmosning.github.io/2020/08/07/sci-owl-weekly-3/"/>
    <id>https://cosmosning.github.io/2020/08/07/sci-owl-weekly-3/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-08-07T11:01:46.000Z</published>
    <updated>2023-06-02T11:13:14.774Z</updated>
    
    <content type="html"><![CDATA[<p>Sci-Owl Weekly，每周日更新。</p><p>本周刊欢迎读者的建议与投稿，请发送相关信息至 <ahref="mailto:cosmosning@gmail.com">cosmosning@gmail.com</a> 。</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/joel-muniz-XqXJJhK-c08-unsplash.jpg"alt="封面图" /><figcaption aria-hidden="true">封面图</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@jmuniz?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">JoelMuniz</a>.<a href="https://unsplash.com/s/photos/reading?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><h1 id="如何阅读更多的书籍">如何阅读更多的书籍</h1><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/christin-hume-k2Kcwkandwg-unsplash.jpg"alt="读书" /><figcaption aria-hidden="true">读书</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@christinhumephoto?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">ChristinHume</a>.<a href="https://unsplash.com/s/photos/reading?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>人们买书，屯书，却由于其他更加吸引人的消遣品而没有时间在书籍中放飞自己的灵魂。如何在这个特殊的时代中挤出时间阅读更多的书籍？这篇<ahref="https://psyche.co/guides/how-to-make-a-daily-habit-of-reading-more-books">文章</a>在习惯的角度给了我们一些建议：</p><p>一、<strong>你得要思考你为什么想要多读书，你的目的是什么</strong>。有相关理论表明，足够的自我驱动力是习惯养成所需要的基石。比如，找个安静的地方停下来，想一想你为什么要这样做呢？这样做有什么价值呢？思考并回答这些问题，会给你足够的动力去阅读。</p><p>二、<strong>准备好舒适的阅读环境</strong>。无论是阅读纸质书，还是电子书，尽可能让书籍在你阅读环境周围唾手可得。如果你想让某事成为你生活中的一大部分，你可以让它首先成为你周围环境的一大部分。外在环境的暗示，会潜移默化地提醒你，别忘了多读书。</p><p>三、<strong>从你喜欢的书籍开始阅读</strong>。不要不经思考，就拿来别人或者是大V的书单。这些书籍很可能和你的兴趣并不相符，也就会逐渐浇灭你持续阅读的热情。去广泛的尝试，丢弃大部分不喜欢的，留下那些与你灵魂共鸣的少数反复阅读。</p><p>四、<strong>think big，start small</strong>。你并不需要立下多大的flag，这在很大程度上是虚假勤奋的表现。试试这个“两分钟法则”，每天翻看书籍 120秒，并坚持下去，这很有可能会使阅读成为你生活中不可不做的一件事。</p><p>五、<strong>创造一种“行为联系”</strong>。具体的，在同样的时间、同样的地点，拿出书籍阅读。经过足够的时间磨合，那样的情景和阅读就产生了一种“行为联系” 。这将会成为你阅读习惯养成的基础。</p><p>六、<strong>在你的日常活动中加入阅读</strong>。很有可能你的一天被各种日常充斥，无法留下空闲的时间阅读。那么，你可以在将阅读活动附加到某一项日常中，并坚持下去。</p><p>七、<strong>接受在培养阅读习惯中的各种挑战，别为所遇到的挫折太过烦恼</strong>。想要开始做一件事势必会遇到困难，但是这会逐渐变得简单的。只要你持续坚持下去，你会强化阅读的“行为联系”。而当“行为联系”得到强化后，对行为的控制逐渐会从一种花费精力的反射处理系统转交给自动行为系统。你会逐渐进入到一种状态，这种状态会自动触发阅读活动：你甚至不会思考你会去做什么，你就开始阅读了。</p><p>八、<strong>追踪你每天的阅读进度</strong>。这样做，会给你的大脑一个逐渐迈向目标的信号，激励你继续坚持。</p><p>九、<strong>加入有关阅读的社交团体、圈子</strong>。阅读也是一种与他人连接、交流的方式。</p><p>十、<strong>培养你对读者身份的认同</strong>。花些时间思考你想成为什么人，阅读更多书会怎样帮助你实现那样的目标。你阅读的目的可能并不是要读多少本书，而是成为一个读者。</p><hr /><h1 id="聚焦">聚焦</h1><ul><li><ahref="https://www.zdnet.com/article/donald-trump-signs-executive-orders-banning-tiktok-and-wechat/">特朗普签署总统令禁用TikTok（抖音海外版） 和 WeChat（微信）</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/macau-photo-agency-BkBPx42-y24-unsplash.jpg"alt="wechat" /><figcaption aria-hidden="true">wechat</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@macauphotoagency?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">MacauPhoto Agency</a>.<a href="https://unsplash.com/s/photos/wechat?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>据报道，特朗普于本周签署了两条总统令：在 45 天之后，将会制裁任何与TikTok 母公司字节跳动、腾讯旗下的微信开展业务往来的公司。</p><p>事件追踪：<ahref="https://www.pingwest.com/w/215776">白宫：总统令仅限于微信相关公司，不影响腾讯游戏运营</a></p><hr /><ul><li><a href="https://36kr.com/p/824370599451778" target="_blank" rel="noopener">本土 RISC-V企业芯来科技获小米投资，加速产业生态布局</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/harrison-broadbent-nePxBIvqUlU-unsplash.jpg"alt="芯片" /><figcaption aria-hidden="true">芯片</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@harrisonbroadbent?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">HarrisonBroadbent</a>.<a href="https://unsplash.com/s/photos/computer-chip?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>芯来科技，一家 RISC-V处理器内核IP和生态平台公司企业，获得了新一轮融资，由小米长江产业基金领投。据悉，芯来科技本轮融资资金将用于加速技术研发和商业落地，促进RISC-V 处理器、专用算法、操作系统等核心技术的深度融合，同时在 AIoT领域提供软硬一体化优质解决方案。</p><hr /><ul><li><ahref="https://www.engadget.com/sony-financial-earnings-ps4-game-sales-pandemic-074353666.html">PS4疫情期间游戏销量几乎翻倍</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/fabian-albert-ePJUCF48vgo-unsplash.jpg"alt="PS4" /><figcaption aria-hidden="true">PS4</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@fabiraw?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">FabianAlbert</a>.<a href="https://unsplash.com/s/photos/playstation?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>据索尼 20 年 Q1 财报显示，截止到 6 月 30 日，PS4 游戏销售额达到了9,100 万，同比去年的 4,980 万上涨了 83 %。其中 74 %的销售额由数字版游戏贡献。</p><hr /><h1 id="好奇">好奇</h1><ul><li><ahref="https://www.csail.mit.edu/news/potential-covid-19-vaccines-get-boost-machine-learning">机器学习助力COVID-19 疫苗的研发</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/shutterstock_1703465413.jpg"alt="COVID-19 疫苗概念图" /><figcaption aria-hidden="true">COVID-19 疫苗概念图</figcaption></figure><p class="img-credit">Source：<span>MIT CAAIL Blog</span></p><p>最近，来自 MIT CAAIL（Computer Science and Artificial IntelligenceLaboratory）的一个团队采用了一种全新的方法，让我们更加接近疫苗研制的解决方案：一个融合了机器学习的系统，它能够选取疫苗所需的多肽，这些多肽据系统预测将会令大多数人产生免疫作用。</p><p><strong>原理</strong></p><p>被称作 "OptiVax"疫苗设计系统，向我们展示了设计新疫苗、评估现有疫苗、增强现有疫苗设计的许多方法。在这个系统中，机器学习算法为不同多肽所显示的免疫效果分别打分，并且在不断迭代中寻找能够最大化疫苗有效覆盖人口范围的多肽。</p><p><strong>未来工作</strong></p><p>一旦疫苗的动物试验证实有效，团队声称他们会在临床许可的条件下，在人体上做实验。目前，研究者们正在与国家健康所（NationalInstitute of Health，NIH）合作，试图观察他们的方法通过使用 COVID-19的病人数据，是否能用在其风险预测上。此外，该团队提及道，他们所提出解决方案的框架也能被用于更广泛的传染病疫苗研究，并且他们希望未来能够将其应用到其他病毒感染的研究上。</p><p><strong>更多</strong></p><p>你可以在<ahref="https://www.cell.com/cell-systems/fulltext/S2405-4712(20)30238-6">这里</a>找到论文的全文</p><hr /><ul><li><ahref="https://spectrum.ieee.org/automaton/robotics/robotics-hardware/robotic-third-arm-can-smash-through-walls">强大的腰间机械臂</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/robo-third-arm.jpeg"alt="腰间机械臂" /><figcaption aria-hidden="true">腰间机械臂</figcaption></figure><p class="img-credit">Credit：<span>Université de Sherbrooke</span></p><p>在过去，当我们希望实际在人身体上增加一些机器部分时，这些机器通常受限于缓慢的运动和轻量级的任务。这些累赘也许并不是我们真正想要的。在2020 年 的 ICRA （IEEE International Conference on Robotics andAutomation）中，来自加拿大舍布鲁克大学（Université deSherbrooke）的研究者给我们带来了一款强大的腰间机械臂。</p><p><strong>参数</strong></p><p>这款机械臂总重仅 4公斤多一些，几乎和人类的手臂重量相同。它能够举起至多 5公斤的物体，并且最大能以 3.4 m/s 的速度挥动。</p><p><strong>功能</strong></p><p>你可以将它想象成一个你的同事。无论是与你一起同时做相同的工作，以提高自己的生产力；还是去做其他繁杂重复的工作，从而可以解放自己的时间，并投入到需要创造力和判断力的工作中去。</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/robo-third-arm-applications.jpeg"alt="机械臂的应用场景" /><figcaption aria-hidden="true">机械臂的应用场景</figcaption></figure><p class="img-credit">Credit：<span>Université de Sherbrooke</span></p><hr /><ul><li><ahref="https://www.wired.com/story/what-can-ants-and-bees-teach-us-about-containing-disease/">从蚂蚁和蜜蜂身上我们能学到什么应对传染病的知识</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/salmen-bejaoui-pTWNamiyDkQ-unsplash.jpg"alt="蚂蚁" /><figcaption aria-hidden="true">蚂蚁</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@slmnbj?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">SalmenBejaoui</a>.<a href="https://unsplash.com/s/photos/ants?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>许多具有“社会性”的昆虫（例如蚂蚁、蜜蜂等）通常生活在一个封闭的环境中。这些环境中包含了许多种微生物，其中就有很多能引发瘟疫的病原体。然而，在实际情况下，类似的病毒大流行却很少在昆虫中发生。似乎这些生物能够以某种方式限制病毒的传染。</p><p><strong>以往的理论观点</strong></p><p>这些昆虫通常保持他们自己和居住地的干净。工蚁会把废物和尸体从巢穴中搬走。此外，它们经常互相清洗，保持自己的整洁。</p><p>一些蚂蚁会从树上采集具有抗生素作用的树脂，并且将它们传播到巢穴的周围。某些昆虫也会分泌一些用于杀死微生物的物质。这些物质包裹在它们的身体上，也留在了地面上。</p><p>当蚂蚁巢穴遭遇到某种病毒的侵袭时，它们会改变它们的接触策略，从而使得病毒难以传播——这种现象通常被称作组织性免疫（organizationalimmunity）。许多“社会性”昆虫拥有分配任务的复杂的社会系统。一些工蚁倾尽一生只会照顾蚁后，或是喂养幼虫，或是保卫巢穴。有数学模型表明，这样的社会分化可能也会延缓感染的发生。例如，只是和很少所指派的工蚁接触，蚁后可能更不容易生病。</p><p><strong>验证理论的方法</strong></p><p>以往的条件下，要实验验证这些理论十分困难。然而，自动化的昆虫追踪系统的出现，使得研究者可以为昆虫应对疫情的策略做更加细致的刻画。</p><p>为了制作一个蚂蚁社会网络，研究者们为蚂蚁贴上了十分小的二维码标记。一旦整个蚂蚁群落被标记完成，就将它们放在一个观察箱中。箱子上的高速摄像机，将会读取相应的二维码，并每秒两次，记录下每一个蚂蚁的位置。之后，通过高性能计算机处理这些数据，就可以刻画出一个蚂蚁群落的社交网络图。</p><p><strong>实验发现</strong></p><p>在一项实验中，研究者们发现，在引入病原体后，蚂蚁之间的接触更加分化。一些蚂蚁之间的接触比它和另一些蚂蚁的接触要更多。至少在理论上，这种模块化的网络能够减缓感染的蔓延。毕竟，相比于将其分为20 组（每组 5 人）相互隔离的情况，人类病毒会在 100个相互接触的人中更快的传播。</p><p>在另一项实验中，研究者放入了蚂蚁十分容易感染的真菌。结果表明，一旦蚂蚁侦测到病原体，这些网络也发生了变化：它们的模块度（modularity）增加了，并且群落中不同的任务组之间相互接触的更少。接触过病毒的采集者开始更少的和其他蚂蚁接触。甚至未接触的蚂蚁也产生了不同的行为，这使得大部分的接触行为限制在较小的蚂蚁圈子中。</p><hr /><h1 id="百味">百味</h1><ul><li><ahref="https://www.boredpanda.com/tattoo-artist-turns-scars-art-ngocliketattoo/">化腐朽为神奇：伤疤纹身艺术</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/Tattoo-artist-makes-real-works-of-art-covering-sad-scars-5f227e9182f98__700.jpg"alt="伤疤纹身" /><figcaption aria-hidden="true">伤疤纹身</figcaption></figure><p class="img-credit">Credit：<span>ngocliketattoo</span> from<a href="https://www.boredpanda.com/" target="_blank" rel="noopener">Boredpanda</a></p><p>伤疤是人们希望隐藏起来的东西。然而一个纹身艺术家另辟蹊径，以伤疤为基础，设计出惊艳的纹身艺术。</p><hr /><ul><li><ahref="https://www.ted.com/talks/lucy_hone_3_secrets_of_resilient_people">成为坚韧的人的三个秘诀</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/LucyHone_2019X-embed.jpg"alt="Lucy Hone" /><figcaption aria-hidden="true">Lucy Hone</figcaption></figure><p class="img-credit">演讲者：<a href="https://www.ted.com/speakers/lucy_hone" target="_blank" rel="noopener">Lucy Hone</a>.<a href="www.ted.com">TED</a></p><p>要想内心强大其实十分简单。Lucy Hone，一位 Resilience expert 、researcher，向我们介绍了三个实用的技巧。</p><hr /><ul><li><ahref="https://mp.weixin.qq.com/s/wRcq37sXnNT_JJ0PvFvNoQ">今天你内卷了吗</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/alexandru-goman-CM-qccHaQ04-unsplash.jpg"alt="思考" /><figcaption aria-hidden="true">思考</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@alexgoman?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">AlexandruGoman</a>.<a href="https://unsplash.com/s/photos/thought?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>内卷，作为一个人类文化学家很早提出的概念，在近期又得到人们的广泛关注。那么什么是内卷呢？怎样应对内卷呢？这篇文章也许能解答你的困惑。</p><hr /><h1 id="器术">器术</h1><ul><li><ahref="https://dev.to/devmount/10-awesome-pythonic-one-liners-explained-3doc">英文· 一行代码实现一个功能！10 个 Python 风格的代码解释</a></li></ul><p>这篇文章介绍了 10行代码，每行代码实现一个简单的功能，并附有解释，任何基础的人都可以阅读。</p><hr /><ul><li><a href="https://github.com/elyase/awesome-gpt3" target="_blank" rel="noopener">资源 · AwesomeGPT-3</a></li></ul><p>近期，OpenAI 商业化了其设计的 <ahref="https://arxiv.org/abs/2005.14165">GPT-3</a>模型，并开放了申请测试。一些开发者拿到了 OpenAI 提供的测试接口，并惊叹于GPT-3 的强大。有网友将这些应用场景和相关资料做了一个整理放在了 GitHub上。感兴趣的读者可以访问上面所示的链接。</p><hr /><ul><li><a href="https://github.com/Delta2Force/MCVmComputers" target="_blank" rel="noopener">工具 ·Minecraft 虚拟电脑 Mod</a></li></ul><p>Minecraft作为自由度最高的游戏，为玩家提供了一个发挥创意的平台。近期，有 Mod制作者开源了一个虚拟电脑 Mod。这使得你甚至可以在 Minecraft 中启动Windows 95 虚拟机<ahref="https://www.theverge.com/2020/7/25/21338092/minecraft-windows-95-pc-doom-vm-computers-mod">玩DOOM</a></p><hr /><ul><li><a href="https://mp.weixin.qq.com/s/jhgH-tY7wIkcaA7s7WpOCA" target="_blank" rel="noopener">中文 ·谈谈职场中的决策与试错</a></li></ul><p>这篇有关职场思维的文章写的十分好，建议反复阅读。</p><hr /><ul><li><ahref="https://xie.infoq.cn/article/495e11547cc63794f693c1e73">中文 ·两万字长文 50+ 张趣图带你领悟网络编程的内功心法</a></li></ul><p>有关计算机网络的常见知识的整理和讲解，建议收藏。</p><hr /><h1 id="拾贝">拾贝</h1><ul><li><ahref="https://www.technologyreview.com/2020/08/06/1006079/instagram-reels-byte-triller-clash-tiktok-ban/">对标TikTok 的竞品有哪些</a></li></ul><p>自上周特朗普对 TikTok发出禁令和强制收购言论后，许多以往不被人注意的短视频应用重新获得了关注。这里简单的介绍4 个可能影响 TikTok 统治地位的 App。</p><p><strong>Byte</strong></p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/ByteApp.jpg"alt="Byte App" /><figcaption aria-hidden="true">Byte App</figcaption></figure><p class="img-credit">Credit：<span>Byte</span></p><p>在 Vine 类应用的复兴的形势下，Byte 于今年早些时间发布了。Vine ，由Twitter 联合拥有，是一个 6秒短视频平台，几乎是最早的短视频应用，并且启发了包括 TikTok 等 App的流行。然而不幸的是，Vine 在 2016 年被 Twitter 关闭了。作为 Vine的创建者之一，Dom Hofmann 制作了Byte，并且戏称这款应用是人们所钟爱的应用的精神续作。</p><p>当 TikTok 遭受美国政府仔细检查之前，Byte十分死寂。“那里没有那么多的人。最受欢迎的视频不过收到了 300个点赞”。然而，现在情况有些变化。在大量 TikTok用户蜂拥而至后，仅仅几天时间内，人们在平台上有了更多的互动，并且受欢迎的视频内容也发生了明显的变化。</p><p><strong>Reels</strong></p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/Instagram-Reels_-Facebook-launches-a-new-TikTok-clone-lailasnews.jpg"alt="Reels" /><figcaption aria-hidden="true">Reels</figcaption></figure><p class="img-credit">Source：<a href="https://lailasnews.com/instagram-reels-facebook-launches-a-new-tiktok-clone/" target="_blank" rel="noopener">LailasNews</a></p><p>Facebook，Instagram的拥有者，在抄袭其他社交媒体平台成功特性并将其融入自己的产品中有一段悠久的历史。Reels则是其最新的尝试。Reels 内嵌于 Instagram ，允许用户发布 15秒可循环的视频。</p><p>Reels 上的视频内容直接对标 TikTok，你甚至会觉得这是 TikTok的一部分，你会看到许多 20多岁年轻人跳舞的视频。然而，对于其推荐算法你却不能抱有太多期待。</p><p>由于 Reels 是 Instagram的一部分，所以它拥有一个强大的潜在用户基础。“我觉得它十分像TikTok。”尽管它缺失了部分特性，但是那些东西很容易复制。有分析人士认为，如果Reels 能够试图将 Z 世代拉回Instagram，而不是宣传之前为了吸引视频观众而制作的 IGTV，Reels有望成为一个可与 TikTok 匹敌的对手。</p><p>Instagram 也有一些与 TikTok 不同的巨大的文化差异。“TikTok更加激进，并且存在多种不同的声音。”而 Instagram上的作者更加专业，他们在自我展示上更加谨慎。</p><p>对于中老年用户来说，在 Instagram 上尝试短视频可能会有更舒适的体验。而TikTok ，对于 25 岁以上的人也许就会是一个怪异的地方。</p><p><strong>Triller</strong></p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/triller-app-store-ranking.jpeg"alt="Triller App" /><figcaption aria-hidden="true">Triller App</figcaption></figure><p class="img-credit">Credit：<span>Solen Feyissa</span></p><p>自从 2015 年开始，就有了 Triller的身影。作为一款音视频简易剪辑的工具，你不需要许多专业知识，就能够通过这个应用创建你自己的音乐视频。在近几周TikTok 风波的传播下，Triller 冲上了 App Store榜首，成为了可能是最具攻击性的 TikTok 统治地位的挑战者。它从 TikTok挖走了很多大咖，他们目前在 Triller 发布他们的跳舞视频。近期，它甚至控告TikTok 侵犯了它的专利。</p><p>Triller 更像是一个改进版的 TikTok 。部分原因是其对 TikTok名人的引流宣传。这还因为，Triller 更加关注于其 AI 剪辑特性，而不是造就TikTok 的推荐算法。此外，受其起源的影响，Triller中的视频更加聚焦于音乐领域。</p><p>Triller 更加适合乐队作者的创作，因为 Triller本身和许多大型唱片公司已经有了许多业务往来。除此以外，Triller也可能会成为 TikTok 大 V 转移平台的一个选择。</p><p>TikTok 面对这个挑战者，并没有坐以待毙。上周，TikTok宣称它将会在未来三年内投入 10 亿美元支持美国创作者。</p><p><strong>Clash</strong></p><p>和 Byte 一样， Clash 拥有 Vine 的内核文化，因为它由前 Vine超级管理员联合制作。然而，Clash 似乎更加关注于创作者的内容变现。</p><p>因此，Clash十分适合于那些想要将自己的内容变现的名人和那些喜欢支持他们的粉丝。</p><p>“Clash 并不是为了成为 TikTok的竞争者而成立的，而是为了迎合一种未被满足的需求，即内容创作者如何从他们所做的东西中赚到钱，并能够维持生活”。</p><p>目前 Clash 仅在 IOS 系统上提供测试，暂时没有 Android 端。</p><hr /><ul><li><ahref="https://arstechnica.com/science/2020/08/what-we-know-about-the-massive-chemical-explosion-in-beirut/">从黎巴嫩爆炸事件我们能了解到什么</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/stephen-radford-hLUTRzcVkqg-unsplash.jpg"alt="爆炸" /><figcaption aria-hidden="true">爆炸</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@steve228uk?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">StephenRadford</a>.<a href="https://unsplash.com/s/photos/explosion?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>于 8 月 4 日下午 6时许（当地时间）黎巴嫩的一个港口发生了重大的化学爆炸事件。这场爆炸至少导致135 人死亡，数千人受伤，并且 30万当地居民将因此无家可归。先前报道将其归咎于不合理的烟火存放，但是真相很快浮出水面：2750吨硝酸铵（<span class="math inline">\(NH_4NO_3\)</span>）在 2013年被当地官员从货船上扣押，并且之后就一直存放在该港口的一个仓库中。</p><p><strong>硝酸铵是一个十分危险的物质</strong></p><p>当这种化学原料受到足够的热量时，它会分解为其他物质：一氧化二氮（<spanclass="math inline">\(N_2O\)</span>）和水；或者，氮气、氧气和水（在更高的温度下）。这两种情况下，化学反应都会释放大量热量和能量。此外，该反应还会产生一种深橘红色的剧毒烟雾。</p><p><strong>比核爆炸小得多</strong></p><p>在理想情况下，一吨硝酸铵的爆炸力相当于 0.45 吨TNT。然而，对于本次爆炸的评估，许多学者给出了不同的估算。依据地图数据和产生这种破坏所需的超压力，一个研究认为这场爆炸相当于240 吨TNT。另一个分析测量了爆炸所产生的火球，并以此为证据提出一个不同的估计——这相当于300 吨 TNT。其中最高的估计为 3, 000 吨TNT，他们将爆炸的大小和气体浓度作为参数分析得出了这个结论。</p><p>要知道，75 年前广岛核爆炸相当于 15, 000 吨TNT。与核爆炸相比，此次爆炸要小得多。</p><hr /><h1 id="火花">火花</h1><blockquote class="blockquote-center"><p>知识的敌人不是无知，而是已经掌握知识的幻觉。</p><p>—— 斯蒂芬·威廉·霍金</p></blockquote><hr /><blockquote class="blockquote-center"><p>Every action you take，is a vote for the type of person you want tobecome.</p><p>—— James Clear，《Atomic Habits》</p></blockquote><hr />]]></content>
    
    <summary type="html">
    
      Sci-Owl Weekly 第 3 期
    
    </summary>
    
    
      <category term="周刊" scheme="https://cosmosning.github.io/categories/%E5%91%A8%E5%88%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>Sci-Owl Weekly #2：别让骗子利用你的声音</title>
    <link href="https://cosmosning.github.io/2020/08/02/sci-owl-weekly-2/"/>
    <id>https://cosmosning.github.io/2020/08/02/sci-owl-weekly-2/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-08-02T01:04:25.000Z</published>
    <updated>2023-06-02T11:13:14.774Z</updated>
    
    <content type="html"><![CDATA[<p>Sci-Owl Weekly，每周日更新。</p><p>本周刊欢迎读者的建议与投稿，请发送相关信息至 <ahref="mailto:cosmosning@gmail.com">cosmosning@gmail.com</a> 。</p><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/james-toose-zWA7Obpb4R4-unsplash.jpg"alt="封面图" /><figcaption aria-hidden="true">封面图</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@portablepeopleproductions?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">JamesToose</a>.<a href="https://unsplash.com/s/photos/owl?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><h1 id="别让骗子利用你的声音">别让骗子利用你的声音</h1><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/bermix-studio-F7DAQIDSk98-unsplash.jpg"alt="骗子" /><figcaption aria-hidden="true">骗子</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@bermixstudio?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">BermixStudio</a>.<a href="https://unsplash.com/s/photos/fraud?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>据<ahref="https://www.vice.com/en_us/article/pkyqvb/deepfake-audio-impersonating-ceo-fraud-attempt">报道</a>，6月，一位科技公司的雇员收到一封语音邮件。该邮件声称，自己是这家公司的 CEO，发这封邮件的目的是要求他“立刻提供帮助”，以完成一项紧急的公司交易。之后，一家安全公司调查此事发现，虽然语音邮件中的声音与CEO十分相似，但这是由电脑软件生成的。这也就是近几年来常常提到的假冒音频（deepfakeaudio）。</p><p>Deepfake audio 在近几年随着 AI技术的发展，只需要你声音的几个样本，便可克隆你声音，并令普通人难辨真假。虽说技术无罪，但是仍有骗子企图利用这项技术，去欺骗他人，谋求金钱或其他东西。所谓“防人之心不可无”，我们能做的便是凡事留一个心眼，保护好自己。比如说，我接到陌生电话时，通常打开免提和录音，不先出声，等对方先说。大部分情况下，来电都是推销产品；当然，也会遇到一些互相沉默的情况（可能骗子此时就在录音采样你的声音。这种情况下，不要犹豫，直接挂掉）。也许有人会认为这太神经质了，万一是重要电话怎么办？我认为，重要电话的话，对方一定会千方百计地试图联系到你，无论是通过先说话还是多次呼叫等方式。这样，你就有了多种证据证明对方并无行骗之意，从而可以放心大胆地对话。</p><p>希望各位读者，保护好自己的声音，别让骗子利用了！</p><h1 id="聚焦">聚焦</h1><ul><li><ahref="https://www.donews.com/news/detail/2/3105457.html">Canalys：二季度华为全球智能手机市场首超三星夺冠</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/Canalys_Report.jpg"alt="Canalys 报告" /><figcaption aria-hidden="true">Canalys 报告</figcaption></figure><p class="img-credit">Source：<span>Canalys 报告</span></p><p>据 Canalys 近期的一份报告指出，2020年第二季度华为首次在全球智能手机市场上超越了三星，成为全球智能手机出货量第一的公司。</p><hr /><ul><li><ahref="https://tech.163.com/20/0729/19/FINQ7D4M00097U7R.html">字节跳动部分投资者对TikTok 收购估值约 500 亿美元</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/kon-karampelas-12TzzNLc2QM-unsplash.jpg"alt="TikTok" /><figcaption aria-hidden="true">TikTok</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@konkarampelas?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">KonKarampelas</a>.<a href="https://unsplash.com/s/photos/tiktok?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>路透社消息，在美国要求字节跳动放弃对 TikTok控制权的压力下，该公司正在考虑处理TikTok的一系列选择。其中一些投资者寻求收购 TikTok，并对其估值约 500亿美元。</p><p>事件发展：<a href="https://readhub.cn/topic/7YzhOh8jzHc" target="_blank" rel="noopener">美国政府强迫TikTok 出售，微软接洽字节跳动有意收购</a></p><hr /><ul><li><ahref="https://www.technologyreview.com/2020/07/29/1005770/nasas-new-mars-rover-perseverance-bristling-tech-find-signs-alien-life/">NASA的火星外星生命探索</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/brian-mcgowan-5_Z3YVosrCw-unsplash.jpg"alt="探测器" /><figcaption aria-hidden="true">探测器</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@sushioutlaw?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">BrianMcGowan</a>.<a href="https://unsplash.com/s/photos/mars-planet?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>在上周中国天问一号发生成功之后，美国 NASA 于当地时间 7 月 30日向火星发射了“毅力”号探测器。该探测器试图找到外星生命迹象，并采集相关样本，返回地球。</p><h1 id="好奇">好奇</h1><ul><li><ahref="https://www.theverge.com/21317052/mobile-autonomous-robot-lab-assistant-research-speed">化学实验助理机器人</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/robo-lab-assistant.png"alt="化学实验助理机器人" /><figcaption aria-hidden="true">化学实验助理机器人</figcaption></figure><p class="img-credit">Credit：University of Liverpool</p><p>在普通人，做化学实验看来是专属于学生和研究员的工作。因为繁杂的反应原料，多样的仪器设备，需要人手精密地控制。</p><p>然而，由英国利物浦大学设计开发的机器人也能胜任做化学实验的工作了！</p><p><strong>亮点</strong></p><p>每周七天，每天 22小时（2小时用来充电），这位机器人助理能够持续地进行化学实验。该<ahref="https://www.nature.com/articles/s41586-020-2442-2">论文</a>指出，由于不间断地运作，该助理进行实验的速度比人类助理快1000倍。这使得研究人员从以往的耗时实验解放出来，能够留下更多的时间设计方案等。</p><p><strong>工作原理</strong></p><p>该机器人并不是完全自动的，它需要人工编程控制，其中包括许多化学实验的基本变量，并且控制算法会根据实验结果改变10 多个变量，以达到最佳的实验效果。</p><p><strong>价值</strong></p><p>解放研究员的时间，帮助他们提高科研效率。</p><p>雷达赋予的夜间移动性，机械臂赋予的灵活性是一项巨大的进步。</p><p><strong>劣势</strong></p><p>贵！机器人的基本硬件花费在 125,000 美元 ～150,000美元之间，之后又花了三年时间开发控制软件。</p><p><strong>评论</strong></p><p>设计者对该技术的未来持乐观态度，因此他们创办了一家公司，试图商业化这项技术，做出更商品化的产品，预计18个月能够完成。</p><p>起初十分怀疑，当人们看到它的工作状态时，他们震惊了，并开始相信如果没有这个助理，他们会有多低效。</p><hr /><ul><li><ahref="https://www.janklingler.com/">美的令人窒息！色彩绚丽的细菌灯</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/bacteria-lamp.jpg"alt="细菌灯" /><figcaption aria-hidden="true">细菌灯</figcaption></figure><p class="img-credit">Credit：trendnomad.com</p><p><strong>亮点</strong></p><p>居住在瑞典的德国工业设计艺术家 <strong>Jan Klingler</strong>融合了生物学、艺术和工业设计，推出了一款细菌灯产品。该产品可以为用户提供高质量的定制服务：从细菌的来源到灯的颜色，都可以满足客户个性化的需求。</p><p><strong>制作流程</strong></p><p>首先，依据用户需求，采取所需的细菌，并放入容器中培养；经过 24～48小时的培养阶段之后，用树脂将其封存，凝固这一刻的美好；将 LED灯插入容器，一个细菌灯就制作好了。</p><hr /><ul><li><ahref="https://aeon.co/essays/if-language-began-in-the-hands-why-did-it-ever-leave">从手到口：如果语言起源于手势，为什么口语成为目前语言的主要交流方式</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/kristina-flour-BcjdbyKWquw-unsplash.jpg"alt="从手语到口语" /><figcaption aria-hidden="true">从手语到口语</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@tinaflour?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">KristinaFlour</a>.<a href="https://unsplash.com/s/photos/mouth?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>有很多语言学习研究者支持语言起源于手势。例如在孩子发育成长时，他将首先学会手势，再学会说话。也有相关实验证明，对于猿类来说，口语是难以触及的，但是手语却相对轻松习得。那么，是什么原因导致语言从手势转移到口语呢？</p><p><strong>关键要点</strong></p><p>对于这个原因的解释，很多学者从口语的优势角度给出了答案：</p><p>第一，口语是抽象的，而手势难以表达任意东西。如果不转移，那么这将严重阻碍抽象思维的诞生和发展。</p><p>第二，口语在黑暗中的表达效果更好。相对的，手语每天平均 12小时能达到相同的效果，但是剩下的 12 小时，将会略显逊色。</p><p>第三，口语相对于手语，更加节省能量，这符合进化的规律。</p><h1 id="百味">百味</h1><ul><li><a href="http://music.163.com/program/2068129904/56704863/" target="_blank" rel="noopener">播客·《高考前后的日子【VG聊天室347】》</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/ivan-aleksic-PDRFeeDniCk-unsplash.jpg"alt="考场" /><figcaption aria-hidden="true">考场</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@ivalex?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">IvanAleksic</a>.<a href="https://unsplash.com/s/photos/classroom?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>近几天，2020年高考进入了志愿填报的阶段。高考前后你是怎么度过的呢？听一听来自游戏时光VGtime 的编辑们对高考的回忆，以及他们学习和游戏之间的故事。</p><hr /><ul><li><ahref="https://www.ted.com/talks/dean_furness_to_overcome_challenges_stop_comparing_yourself_to_others">TED· 要克服挑战，请先停下与他人的比较</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/DeanFurness_2020S-embed.jpg"alt="Dean Furness" /><figcaption aria-hidden="true">Dean Furness</figcaption></figure><p class="img-credit">演讲人：<a href="https://www.ted.com/speakers/dean_furness" target="_blank" rel="noopener">DeanFurness</a>. TED</p><p>Dean Furness 曾经是一位数据分析员。 2011年的一次事故使他下身瘫痪，无法行走。但经过数年的康复，辛勤工作和物理治疗师的鼓励，他开始作为轮椅运动员参加了芝加哥和波士顿马拉松比赛。现在，他谈论自己的经历以及面对困难挑战所需要采取的措施。</p><hr /><ul><li><ahref="https://www.boredpanda.com/i-spend-days-on-bridges-to-take-images-of-roaming-vendors/">图片· 我在桥上花了几天时间拍摄小贩的图片</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/LoesHeerinkHanoi.png"alt="小商贩" /><figcaption aria-hidden="true">小商贩</figcaption></figure><p class="img-credit">Credit：<a href="https://loesheerink.com/" target="_blank" rel="noopener">Loes Heerink</a>.<a href="https://www.boredpanda.com/i-spend-days-on-bridges-to-take-images-of-roaming-vendors/" target="_blank" rel="noopener">Bored Panda</a></p><p>Loes Heerink从独特的视角捕捉了小商贩们的剪影。也许你从未关注她们：生活原来是如此多彩，却又饱含艰辛。</p><h1 id="器术">器术</h1><ul><li><ahref="https://laconicml.com/free-artificial-intelligence-courses/">英文· 10 个最佳的人工智能公开课，来自哈佛、麻省和斯坦福</a></li></ul><p>该文章整理了 10个最佳的来自世界名校的人工智能公开课。建议收藏起来学（吃）习（灰）。</p><hr /><ul><li><ahref="https://www.ted.com/talks/yann_lecun_deep_learning_neural_networks_and_the_future_of_ai">视频· 对话 Yann LeCun：深度学习、神经网络和 AI 的未来</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/YannLeCun_2020S-embed.jpg"alt="Yann LeCun" /><figcaption aria-hidden="true">Yann LeCun</figcaption></figure><p class="img-credit">Yann LeCun. TED</p><p>2020 年 6 月，TED 的策展人 Chris Anderson 与深度学习大师 Yann LeCun进行了一次视频连线。Yann LeCun在连线中聊了聊他目前正在从事的自监督机器学习研究，他是如何尝试构建像人类一样具有常识的机器，以及他对下一个在AI 领域概念性突破的展望。</p><p>如果原站访问速度太慢，欢迎到 B 站观看<ahref="https://www.bilibili.com/video/BV1TZ4y1M7nw/">我的搬运</a></p><hr /><ul><li><ahref="https://realpython.com/generative-adversarial-networks/">英文 ·手把手教你实现你的第一个生成对抗网络</a></li></ul><p>生成对抗网络在图片生成、高清化中有非常丰富应用。如何实现一个生成对抗网络？这篇文章会手把手的教你。</p><hr /><ul><li><a href="https://mp.weixin.qq.com/s/UOt7ijpDGrguxP8dpmua-w" target="_blank" rel="noopener">中文 ·工程师如何如何培养数据思维</a></li></ul><blockquote><p>“If you can’t measure it, you can’t improve it.”</p></blockquote><p>数据思维在研究和工业生产中是非常基础的一种思维。从数据中，我们能发现目前的优势和劣势。与此同时，定义关键的监控指标，会让我们的研究和工作获得更大的提升。</p><p>该文章的作者是硅谷的工程师，带领过许多团队。从这篇文章中，你认识到数据思维的价值和工程实践。</p><hr /><ul><li><ahref="https://xie.infoq.cn/article/8e66fa7ebe4d310db95b39c31">中文 ·图解进程、线程</a></li></ul><p>通过多图、类比的手法解释进程、线程的概念，建议反复阅读。</p><h1 id="拾贝">拾贝</h1><ul><li><ahref="https://www.wired.com/story/looking-for-gravitons-check-for-the-buzz/">探测引力子</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/aron-visuals-R49cUgaQ0mk-unsplash.jpg"alt="粒子" /><figcaption aria-hidden="true">粒子</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@aronvisuals?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">AronVisuals</a>.<a href="https://unsplash.com/s/photos/particle?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>很多物理学家认为引力子是存在的，但是他们中很少人认为我们能够探测到它们。引力子的世界只有当以尽可能小的比例放大时空结构时才会显现。这需要一种能够真正利用极端能量的设备。很不幸，任何能够直接探测到这种粒子的测量设备的“普朗克长度” 必然太大，以至于会塌陷成一个黑洞。然而，近期发表的一篇<ahref="https://arxiv.org/abs/2005.07211">论文</a>通过理论计算，改变了这个观点：引力子可能会在引力波探测器中制造出可观测的“噪音”。</p><p>引力波探测器，简单的可以看作两个间隔一定距离的物体。当有引力波通过时，它们之间的距离会随着引力波拉伸、压缩两者之间的空间而增加和减少。此时，如果将引力子混入其中，就会在时空的常见波动之上添加了新的运动。当探测器吸收和释放引力子时，两个物体就会随机抖动。这就是引力子的“噪音” 。</p><p>Parikh（论文一作）表示：“我们总是有这样的预感，引力子会以某种方式轰击探测器，并且因此存在一些抖动现象。”“但是，” Zahariade（论文三作）补充道，“当我们从数学角度理解引力子产生噪音的原理时，那真是一个美妙的时刻。”</p><p>尽管将会面对很多挑战，Wilczek（论文二作）“谨慎乐观”地认为他们的工作提出了一个可通过实验探测验证的预测。无论如何，他都希望该论文能够激励其他理论物理研究者去研究引力子噪声。</p><p>“基础物理学的研究是一项十分困难的工作。试想一下，你在一件 T恤衫上写满了东西，之后你就很难再向衣服上增加或修改东西了。” Wilczek说道，“我无法预料到这项贡献会引导研究者走向哪里，但我知道它为这个世界打开了一扇新的窗户。”</p><hr /><ul><li><ahref="https://www.npr.org/sections/health-shots/2020/07/27/893289171/a-boy-with-muscular-dystrophy-was-headed-for-a-wheelchair-then-gene-therapy-arri">一个男孩、一位科学家和一个从未失去希望的家庭</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/08/marianne-bos-eDOYvF6pM1I-unsplash.jpg"alt="残疾人" /><figcaption aria-hidden="true">残疾人</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@mariannebos?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">mariannebos</a>.<a href="https://unsplash.com/s/photos/wheelchair?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>在 Conner Curran 4 岁的时候，他被诊断出患有Duchenne型肌营养不良症。这是一个由基因缺陷引起的疾病，并且会逐渐导致患者肌肉萎缩，最终难以靠自己行走。据当时的医嘱，这个疾病难以治愈。然而，5年后，Conner不仅仅能够走路，并且还能够跑的更快。这要归功于一项研究发展了近 30年的实验性的基因疗法。</p><p>据 Samulski（开创这项基因治疗的科学家）介绍，该病是由于缺少某些基因所致，因此只需将缺失的基因放回去，就能治愈。然而，这个十分简单的概念，却花了Samulski 长达 30多年的时间。面对技术上的挑战、研究资金的停供等阻碍，Samulski以一个医者的坚持，最终开发出在动物身上试验成功的基因疗法。</p><p>在听到医生对于 Conner 的建议后，Conner 的父母 Jessica 和 ChristopherCurran 不相信医生的预测。但是，在他们的儿子上一年级时，Conner远远地落后于他的兄弟 Kyle，并且连在家的周围走动都十分吃力。</p><p>Curran一家了解到，科学家们正在研究攻关，试图找到治愈的办法。在诊断后的一年，他们了解到了“基因疗法”。</p><p>“他和他的父母自愿成为第一个使用这项基因疗法的人。” Samulski说道。</p><p>随后，有更多的志愿者接受的同样的治疗。</p><p>然而，他们中的很多人，包括 Conner，会产生例如发烧、恶心和肝、肾脏问题。并且有两个在医院走完了他们人生中的最后一刻。</p><p>Samulski解释道，这样基因疗法试验由于技术方面的原因存在副作用，通常会影响肝脏。他坚信，自己能够解决这个问题。像往常一样，他产生了一个想法：“我们得在这里建立一个停止标记”。他告诉团队制作一个类似的样本。</p><p>在随后的采访中，他告诉我他的团队已经在原有基础上像他所要求的那样加上了停止标记。并且，实验室正在动物身上做试验，观察这种改进是否有效。</p><h1 id="火花">火花</h1><blockquote class="blockquote-center"><p>人生・事业的结果=思维方式×热情×能力</p><p>—— <ahref="https://www.kyocera.com.cn/inamori/philosophy/words43.html">稻盛和夫</a></p></blockquote><hr /><blockquote class="blockquote-center"><p>Context, not Control</p><p>—— <ahref="https://www.sanjieke.cn/youzhao/article/24025165">字节跳动管理理念</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Sci-Owl Weekly 第 2 期
    
    </summary>
    
    
      <category term="周刊" scheme="https://cosmosning.github.io/categories/%E5%91%A8%E5%88%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>Sci-Owl Weekly #1：科技探索者周刊创刊词</title>
    <link href="https://cosmosning.github.io/2020/07/25/sci-owl-weekly-1/"/>
    <id>https://cosmosning.github.io/2020/07/25/sci-owl-weekly-1/</id>
    
    
    <author>
    <name>CosmosNing</name>
    <uri>https://cosmosning.github.io/about</uri>
    </author>
    
    
    <published>2020-07-25T16:09:19.000Z</published>
    <updated>2023-06-02T11:13:14.774Z</updated>
    
    <content type="html"><![CDATA[<figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/true-agency-Q8otix2SVko-unsplash.jpg"alt="封面图" /><figcaption aria-hidden="true">封面图</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@trueagency?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">TrueAgency</a>.<a href="https://unsplash.com/s/photos/magazine?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><h1 id="创刊词">创刊词</h1><p>Sci-Owl Weekly —— 科技探索者周刊就这么开始了。本周刊刊名<code>Sci</code> 取自 <code>Science</code>缩写，意味着本周刊主要关注科学、科技领域；<code>Owl</code>意为猫头鹰，在西方的理解是智慧的象征。我希望我能够有猫头鹰的鹰一般的洞察力，并且以本周刊抛砖引玉，给读者带来探索智慧的享受。</p><p>目前预计每周日（我也不知道我能坚持多久，先看着吧），我会为你精选几篇文章或者视频，包括但不限于新鲜的科技资讯、有趣的科学现象。希望这些能够激起你的<strong>好奇心</strong>，并开启你的知识<strong>探索</strong>之旅。</p><p>本周刊主要有以下几个栏目：</p><ul><li>聚焦：每天都有新鲜事发生！本栏目将选取本周值得关注的科技新闻，供你了解科技行业动向。</li><li>好奇：世界很奇妙，总有些东西会激发你的好奇心！在这部分内容中，你会了解到一些有趣的原理、科技故事和更多。</li><li>百味：不妨给生活加点料！这部分的内容会关注人与生活，在理性之中点缀一些感性。</li><li>器术：别忘了学习！教程、书籍、工具都会在这部分推荐给你。</li><li>拾贝：留下文章的精华！我会摘录一些文章中的观点、现象，直接供你参考。</li><li>火花：总有那么几句话，令你醍醐灌顶！无论是思维碰撞，还是灵感迸发，这些火花也许能帮到你。</li></ul><p>那么，开始吧！</p><h1 id="聚焦">聚焦</h1><ul><li><ahref="https://www.zdnet.com/article/alibabas-ant-financial-plans-shanghai-hong-kong-ipos/">蚂蚁金服拟计划在上海和香港上市</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/markus-winkler-A-F_TIyWClU-unsplash.jpg"alt="AliPay" /><figcaption aria-hidden="true">AliPay</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@markuswinkler?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">MarkusWinkler</a>.<a href="https://unsplash.com/s/photos/ant-financial?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>近期，阿里巴巴蚂蚁金服开启了其在上海和香港上市的上市程序。据报道，此次上市估值约2000亿美金，将会推动其对中国服务业的数字化升级，并加大技术研发的投入力度。</p><ul><li><ahref="http://www.xinhuanet.com/tech/2020-07/23/c_1126275764.htm">天问一号，目标火星！</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/1126275764_15954824662821n.jpg"alt="天问一号发射升空" /><figcaption aria-hidden="true">天问一号发射升空</figcaption></figure><p class="img-credit">Credit：才扬.<a href="http://www.xinhuanet.com/tech/2020-07/23/c_1126275764.htm" target="_blank" rel="noopener">新华网</a></p><p>7 月 23 日，中国文昌航天发射场发射了中国第一颗火星探测器"天问一号"。这一刻，我们又见证了历史！</p><ul><li><a href="https://www.pingwest.com/w/214565" target="_blank" rel="noopener">苹果承诺 2030 年实现100% 碳中和</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/appleEnv.PNG"alt="苹果碳中和宣言" /><figcaption aria-hidden="true">苹果碳中和宣言</figcaption></figure><p class="img-credit">Source：<a href="https://www.apple.com.cn/environment/" target="_blank" rel="noopener">苹果环境保护宣传网站</a></p><p>苹果在其<ahref="https://www.apple.com.cn/environment/">网站</a>上公布了 2030年实现 100% 碳中和的计划。该<ahref="https://www.apple.com.cn/environment/pdf/Apple_Environmental_Progress_Report_2020.pdf">报告</a>指出，苹果将在运营100 % 使用可再生电力，在设计中 100 %使用再生稀土，使用更高明的化学工艺减少产品对人的伤害。</p><h1 id="好奇">好奇</h1><ul><li><ahref="https://www.wired.com/story/will-the-hydrogen-revolution-start-in-a-garbage-dump/">氢气革命会从垃圾开始吗</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/hermes-rivera-R1_ibA4oXiI-unsplash.jpg"alt="垃圾填埋场" /><figcaption aria-hidden="true">垃圾填埋场</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@hermez777?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">HermesRivera</a>.<a href="https://unsplash.com/s/photos/garbage?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>氢气在燃烧时，并不会产生有害气体，因此被人们认为是未来能源。</p><p>目前，许多美国企业正竞相将垃圾转换为氢气燃料技术商业化。那么，氢气革命会从垃圾开始吗？</p><ul><li><ahref="https://www.knowablemagazine.org/article/health-disease/2020/how-viruses-evolve">病毒是如何进化的</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/virus-evolution-1600x600_0.png"alt="病毒是如何进化的" /><figcaption aria-hidden="true">病毒是如何进化的</figcaption></figure><p class="img-credit">Credit：<a href="https://www.knowablemagazine.org/article/health-disease/2020/how-viruses-evolve" target="_blank" rel="noopener">KNOWABLEMAGAZINE</a></p><p>新冠病毒疫情在全球范围内已经持续了半年之久。据目前的全球数据来看，疫情并没有在全球范围内得到控制。</p><p>病原体在感染新宿主时，需要适应新环境。这种特性是如何影响疫情的传播？接下来会怎么样？也许通过了解病毒是如何进化的，可以帮助我们更好的采取正确的措施。</p><ul><li><ahref="https://primer.ai/blog/maverick-goose-begin-romantic-relationship/">AI如何生成新闻标题</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/kedar-dhond-4Jr97hj-fn8-unsplash.jpg"alt="新闻标题" /><figcaption aria-hidden="true">新闻标题</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@kedard?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">KedarDhond 📷</a>.<a href="https://unsplash.com/s/photos/headlines?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>如何为新闻起一个合适的标题？现在 AI也能胜任这份工作了，并且可能会比人类表现的更为出色！如果你对此有兴趣，可以参看这篇<ahref="https://arxiv.org/abs/1904.08455">论文</a> 。</p><p>拓展阅读：<ahref="https://www.technologyreview.com/2020/07/20/1005454/openai-machine-learning-language-generator-gpt-3-nlp/">太强大了！OpenAI的 GPT-3 语言生成器</a></p><h1 id="百味">百味</h1><ul><li><ahref="https://mp.weixin.qq.com/s/4noztbORY8YGRBrN4E0obw">挣扎</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/christopher-lemercier-12yvdCiLaVE-unsplash.jpg"alt="挣扎" /><figcaption aria-hidden="true">挣扎</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@elevantarts?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">christopherlemercier</a>.<a href="https://unsplash.com/s/photos/struggle?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>Redis 的作者 Antirez是一位光鲜亮丽的艺术家，但他也免不了承受来自现实的压力：他既希望通过代码表达自我，但又受困于Redis 维护过程中永无止尽的 PR 评审、用户吐槽。在这样一个状态下，他选择近期辞去 Redis 项目维护者职务，将Redis 交给 Redis 社区。</p><ul><li><a href="https://mp.weixin.qq.com/s/81ONcA1ViqpnfqB7-jfwAQ" target="_blank" rel="noopener">王信文 |情绪作为一种操作系统</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/tengyart-auEPahZjT40-unsplash.jpg"alt="情绪" /><figcaption aria-hidden="true">情绪</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@tengyart?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Tengyart</a>.<a href="https://unsplash.com/s/photos/emotion?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>情绪作为我们与生俱来的能力，并不能够应付越来越复杂的现实社会，我们要做的便是以升级的视角看待情绪，让它像操作系统一样更新换代。</p><ul><li><ahref="https://www.douban.com/gallery/topic/152992/">你童年时代的夏天</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/edceee-G35D9jK1Bf0-unsplash.jpg"alt="夏天" /><figcaption aria-hidden="true">夏天</figcaption></figure><p class="img-credit">Credit：<a href="https://unsplash.com/@edceee?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">煜翔肖</a>.<a href="https://unsplash.com/s/photos/summer?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p><p>夏天，总会留下美好的回忆。你记忆中的夏天是什么样的？我想从陌生人的动态能窥见端倪。</p><h1 id="器术">器术</h1><ul><li><a href="https://poloclub.github.io/cnn-explainer/" target="_blank" rel="noopener">英文 · CNN交互式教程</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/CNN-Explainer.PNG"alt="CNN-Explainer" /><figcaption aria-hidden="true">CNN-Explainer</figcaption></figure><p>一个可交互的 CNN 入门教程，可以自己上传图片，观察处理过程。</p><ul><li><ahref="https://pytorch.org/assets/deep-learning/Deep-Learning-with-PyTorch.pdf">英文· PyTorch 深度学习.pdf</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/DL-with-PyTorch.PNG"alt="DL-with-PyTorch" /><figcaption aria-hidden="true">DL-with-PyTorch</figcaption></figure><p>PyTorch 最好入门教程《Deep Learning with PyTorch》限时免费下载。</p><ul><li><ahref="https://realpython.com/python3-object-oriented-programming/">英文· Python 3 面向对象编程教程</a></li></ul><p>介绍 Python3 如何定义类、实例化对象、继承等基本语法。</p><ul><li><a href="https://coolshell.cn/articles/20793.html" target="_blank" rel="noopener">中文 ·与程序员相关的CPU缓存知识</a></li></ul><p>缓存思想在工程应用中经常用到，是时候去操作系统 CPU 那里取取经了！</p><ul><li><a href="https://www.bilibili.com/video/BV12t411u726" target="_blank" rel="noopener">视频 ·jvm内存模型全面解析</a></li></ul><p>有关 jvm 内存模型，一个视频就理解了！</p><h1 id="拾贝">拾贝</h1><ul><li><ahref="http://www.ruanyifeng.com/blog/2020/07/apple-abandon-Intel-chips-hit-the-us-computer-industry.html">苹果放弃英特尔芯片，为什么会打击美国计算机产业？</a></li></ul><figure><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/bg2020071804.jpg"alt="Apple Silicon" /><figcaption aria-hidden="true">Apple Silicon</figcaption></figure><p>关于中国的电子制造业，普遍的观念是那里劳动力成本低，所以才选择在那里建立外包工厂。我不确定他们去的是中国哪个地区，但事实是，中国早在多年前就不再是劳动力成本低的国家。从供应链的角度来看，劳动力成本并不是选择中国的原因，主要原因是中国能够提供的技能。</p><p>我们的产品需要非常先进的工具，这意味着整个配套技术都必须是最先进的。这需要很深的工具技能。在美国，你召开一次工具方面的工程师会议，我不知道能不能坐满一个会议室，但在中国，可以坐满多个足球场。</p><ul><li><ahref="https://type.cyhsu.xyz/2020/03/on-the-popularity-of-newsletters/">从邮件通讯的流行谈起</a></li></ul><p><imgsrc="https://raw.githubusercontent.com/CosmosNing/MyPicGo/master/images/2020/07/nyt_nl.png" /></p><p>放眼科技行业，近年无数新技术和平台都以「赋能」（empower）为使命，声称自己为用户和创作者提供了亟需的获取和传播信息的能力。然而，支撑着这种赋能叙事的，是一种「无能」的假定：用户没有能力自主找到需要的信息，而是需要算法来推荐和投喂；创作者没有能力自主和受众建立关系，而是需要平台和竞价「优化」来牵线搭桥。</p><p>邮件通讯和 RSS等古旧技术的复苏有力地证伪了这种假定。它们表明，只要保障信息的自由流动、组合、处理——各种早期技术的普遍特征——用户就有能力搭配出符合兴趣且优质的信息「食谱」，创作者也有能力和用户建立直接、亲密的联系。相比于「赋能」，用户和创作者更需要的或许是「还能」，夺回他们被复杂技术以「赋能」名义攫取的独立获取或传播信息的能力。</p><p>但也正因如此，在使用和推广邮件通讯这样的「复古」技术时，应当避免对于其外在形式、渠道的过度强调。邮件通讯没有什么特殊的形式，而是抛开了各种不必要的形式，把信息不加包装、直截了当地送达读者；不是什么特殊的渠道，而是开辟了一个替代渠道，让用户在信息轰炸中获得自主掌控的空间。把握了这一点，不用拘泥于电子邮件的形式，也可以实现对信息区隔和分流的效果。反之，邮件通讯也可能被异化和商品化，为用户本就饱和的信息摄入徒增另一重负担。</p><h1 id="火花">火花</h1><ul><li><a href="https://www.v2ex.com/t/692079" target="_blank" rel="noopener">你要悄悄学 Python，然后惊艳所有人</a></li></ul><blockquote class="blockquote-center"><p>如果不打算投入程序员这个职业，建议学习掌握好 Office 三件套，受益终身尤其是 Excel 。</p><p>—— V2EX 网友</p></blockquote><ul><li><a href="https://www.v2ex.com/t/692187" target="_blank" rel="noopener">搞软件架构，是不是绕不开Java ？</a></li></ul><blockquote class="blockquote-center"><p>架构和语言有什么关系？架构是方法论，语言只是工具。</p><p>楼主你需要跳出编程的层面去看问题，这样才能找到问题的核心。</p><p>—— V2EX 网友</p></blockquote>]]></content>
    
    <summary type="html">
    
      Sci-Owl Weekly 第 1 期
    
    </summary>
    
    
      <category term="周刊" scheme="https://cosmosning.github.io/categories/%E5%91%A8%E5%88%8A/"/>
    
    
  </entry>
  
</feed>
