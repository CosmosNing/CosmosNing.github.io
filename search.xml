<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Sci-Owl Weekly #1：科技探索者周刊创刊词</title>
    <url>/2020/07/25/sci-owl-weekly-1//</url>
    <content><![CDATA[<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/true-agency-Q8otix2SVko-unsplash.jpg" alt="封面图"></p>
<p class="img-credit">Credit：<a href="https://unsplash.com/@trueagency?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">True Agency</a>. <a href="https://unsplash.com/s/photos/magazine?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>

<h1 id="创刊词"><a href="#创刊词" class="headerlink" title="创刊词"></a>创刊词</h1><p>Sci-Owl Weekly —— 科技探索者周刊就这么开始了。本周刊刊名 <code>Sci</code> 取自 <code>Science</code> 缩写，意味着本周刊主要关注科学、科技领域；<code>Owl</code> 意为猫头鹰，在西方的理解是智慧的象征。我希望我能够有猫头鹰的鹰一般的洞察力，并且以本周刊抛砖引玉，给读者带来探索智慧的享受。</p>
<p>目前预计每周日（我也不知道我能坚持多久，先看着吧），我会为你精选几篇文章或者视频，包括但不限于新鲜的科技资讯、有趣的科学现象。希望这些能够激起你的<strong>好奇心</strong>，并开启你的知识<strong>探索</strong>之旅。</p>
<p>本周刊主要有以下几个栏目：</p>
<ul>
<li>聚焦：每天都有新鲜事发生！本栏目将选取本周值得关注的科技新闻，供你了解科技行业动向。</li>
<li>好奇：世界很奇妙，总有些东西会激发你的好奇心！在这部分内容中，你会了解到一些有趣的原理、科技故事和更多。</li>
<li>百味：不妨给生活加点料！这部分的内容会关注人与生活，在理性之中点缀一些感性。</li>
<li>器术：别忘了学习！教程、书籍、工具都会在这部分推荐给你。</li>
<li>拾贝：留下文章的精华！我会摘录一些文章中的观点、现象，直接供你参考。</li>
<li>火花：总有那么几句话，令你醍醐灌顶！无论是思维碰撞，还是灵感迸发，这些火花也许能帮到你。</li>
</ul>
<p>那么，开始吧！</p>
<h1 id="聚焦"><a href="#聚焦" class="headerlink" title="聚焦"></a>聚焦</h1><ul>
<li><a href="https://www.zdnet.com/article/alibabas-ant-financial-plans-shanghai-hong-kong-ipos/" target="_blank" rel="noopener">蚂蚁金服拟计划在上海和香港上市</a></li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/markus-winkler-A-F_TIyWClU-unsplash.jpg" alt="AliPay"></p>
<p class="img-credit">Credit：<a href="https://unsplash.com/@markuswinkler?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Markus Winkler</a>. <a href="https://unsplash.com/s/photos/ant-financial?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>

<p>近期，阿里巴巴蚂蚁金服开启了其在上海和香港上市的上市程序。据报道，此次上市估值约 2000 亿美金，将会推动其对中国服务业的数字化升级，并加大技术研发的投入力度。</p>
<ul>
<li><a href="http://www.xinhuanet.com/tech/2020-07/23/c_1126275764.htm" target="_blank" rel="noopener">天问一号，目标火星！</a></li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/1126275764_15954824662821n.jpg" alt="天问一号发射升空"></p>
<p class="img-credit">Credit：才扬. <a href="http://www.xinhuanet.com/tech/2020-07/23/c_1126275764.htm" target="_blank" rel="noopener">新华网</a></p>

<p>7 月 23 日，中国文昌航天发射场发射了中国第一颗火星探测器 “天问一号”。这一刻，我们又见证了历史！</p>
<ul>
<li><a href="https://www.pingwest.com/w/214565" target="_blank" rel="noopener">苹果承诺 2030 年实现 100% 碳中和</a></li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/appleEnv.PNG" alt="苹果碳中和宣言"></p>
<p class="img-credit">Source：<a href="https://www.apple.com.cn/environment/" target="_blank" rel="noopener">苹果环境保护宣传网站</a></p>

<p>苹果在其<a href="https://www.apple.com.cn/environment/" target="_blank" rel="noopener">网站</a>上公布了 2030 年实现 100% 碳中和的计划。该<a href="https://www.apple.com.cn/environment/pdf/Apple_Environmental_Progress_Report_2020.pdf" target="_blank" rel="noopener">报告</a>指出，苹果将在运营 100 % 使用可再生电力，在设计中 100 % 使用再生稀土，使用更高明的化学工艺减少产品对人的伤害。</p>
<h1 id="好奇"><a href="#好奇" class="headerlink" title="好奇"></a>好奇</h1><ul>
<li><a href="https://www.wired.com/story/will-the-hydrogen-revolution-start-in-a-garbage-dump/" target="_blank" rel="noopener">氢气革命会从垃圾开始吗</a></li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/hermes-rivera-R1_ibA4oXiI-unsplash.jpg" alt="垃圾填埋场"></p>
<p class="img-credit">Credit：<a href="https://unsplash.com/@hermez777?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Hermes Rivera</a>. <a href="https://unsplash.com/s/photos/garbage?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>

<p>氢气在燃烧时，并不会产生有害气体，因此被人们认为是未来能源。</p>
<p>目前，许多美国企业正竞相将垃圾转换为氢气燃料技术商业化。那么，氢气革命会从垃圾开始吗？</p>
<ul>
<li><a href="https://www.knowablemagazine.org/article/health-disease/2020/how-viruses-evolve" target="_blank" rel="noopener">病毒是如何进化的</a></li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/virus-evolution-1600x600_0.png" alt="病毒是如何进化的"></p>
<p class="img-credit">Credit：<a href="https://www.knowablemagazine.org/article/health-disease/2020/how-viruses-evolve" target="_blank" rel="noopener">KNOWABLE MAGAZINE</a></p>

<p>新冠病毒疫情在全球范围内已经持续了半年之久。据目前的全球数据来看，疫情并没有在全球范围内得到控制。</p>
<p>病原体在感染新宿主时，需要适应新环境。这种特性是如何影响疫情的传播？接下来会怎么样？也许通过了解病毒是如何进化的，可以帮助我们更好的采取正确的措施。</p>
<ul>
<li><a href="https://primer.ai/blog/maverick-goose-begin-romantic-relationship/" target="_blank" rel="noopener">AI 如何生成新闻标题</a></li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/kedar-dhond-4Jr97hj-fn8-unsplash.jpg" alt="新闻标题"></p>
<p class="img-credit">Credit：<a href="https://unsplash.com/@kedard?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Kedar Dhond 📷</a>. <a href="https://unsplash.com/s/photos/headlines?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>

<p>如何为新闻起一个合适的标题？现在 AI 也能胜任这份工作了，并且可能会比人类表现的更为出色！如果你对此有兴趣，可以参看这篇<a href="https://arxiv.org/abs/1904.08455" target="_blank" rel="noopener">论文</a> 。</p>
<p>拓展阅读：<a href="https://www.technologyreview.com/2020/07/20/1005454/openai-machine-learning-language-generator-gpt-3-nlp/" target="_blank" rel="noopener">太强大了！OpenAI 的 GPT-3 语言生成器</a></p>
<h1 id="百味"><a href="#百味" class="headerlink" title="百味"></a>百味</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/4noztbORY8YGRBrN4E0obw" target="_blank" rel="noopener">挣扎</a></li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/christopher-lemercier-12yvdCiLaVE-unsplash.jpg" alt="挣扎"></p>
<p class="img-credit">Credit：<a href="https://unsplash.com/@elevantarts?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">christopher lemercier</a>. <a href="https://unsplash.com/s/photos/struggle?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>

<p>Redis 的作者 Antirez 是一位光鲜亮丽的艺术家，但他也免不了承受来自现实的压力：他既希望通过代码表达自我，但又受困于 Redis 维护过程中永无止尽的 PR 评审 、用户吐槽。在这样一个状态下，他选择近期辞去 Redis 项目维护者职务，将 Redis 交给 Redis 社区。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/81ONcA1ViqpnfqB7-jfwAQ" target="_blank" rel="noopener">王信文 | 情绪作为一种操作系统</a></li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/tengyart-auEPahZjT40-unsplash.jpg" alt="情绪"></p>
<p class="img-credit">Credit：<a href="https://unsplash.com/@tengyart?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Tengyart</a>. <a href="https://unsplash.com/s/photos/emotion?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>

<p>情绪作为我们与生俱来的能力，并不能够应付越来越复杂的现实社会，我们要做的便是以升级的视角看待情绪，让它像操作系统一样更新换代。</p>
<ul>
<li><a href="https://www.douban.com/gallery/topic/152992/" target="_blank" rel="noopener">你童年时代的夏天</a></li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/edceee-G35D9jK1Bf0-unsplash.jpg" alt="夏天"></p>
<p class="img-credit">Credit：<a href="https://unsplash.com/@edceee?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">煜翔 肖</a>. <a href="https://unsplash.com/s/photos/summer?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>

<p>夏天，总会留下美好的回忆。你记忆中的夏天是什么样的？我想从陌生人的动态能窥见端倪。</p>
<h1 id="器术"><a href="#器术" class="headerlink" title="器术"></a>器术</h1><ul>
<li><a href="https://poloclub.github.io/cnn-explainer/" target="_blank" rel="noopener">英文 · CNN 交互式教程</a></li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/CNN-Explainer.PNG" alt="CNN-Explainer"></p>
<p>一个可交互的 CNN 入门教程，可以自己上传图片，观察处理过程。</p>
<ul>
<li><a href="https://pytorch.org/assets/deep-learning/Deep-Learning-with-PyTorch.pdf" target="_blank" rel="noopener">英文 · PyTorch 深度学习.pdf</a></li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/DL-with-PyTorch.PNG" alt="DL-with-PyTorch"></p>
<p>PyTorch 最好入门教程《Deep Learning with PyTorch》限时免费下载。</p>
<ul>
<li><a href="https://realpython.com/python3-object-oriented-programming/" target="_blank" rel="noopener">英文 · Python 3 面向对象编程教程</a></li>
</ul>
<p>介绍 Python3 如何定义类、实例化对象、继承等基本语法。</p>
<ul>
<li><a href="https://coolshell.cn/articles/20793.html" target="_blank" rel="noopener">中文 · 与程序员相关的CPU缓存知识</a></li>
</ul>
<p>缓存思想在工程应用中经常用到，是时候去操作系统 CPU 那里取取经了！</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV12t411u726" target="_blank" rel="noopener">视频 · jvm内存模型全面解析</a></li>
</ul>
<p>有关 jvm 内存模型，一个视频就理解了！</p>
<h1 id="拾贝"><a href="#拾贝" class="headerlink" title="拾贝"></a>拾贝</h1><ul>
<li><a href="http://www.ruanyifeng.com/blog/2020/07/apple-abandon-Intel-chips-hit-the-us-computer-industry.html" target="_blank" rel="noopener">苹果放弃英特尔芯片，为什么会打击美国计算机产业？</a></li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/bg2020071804.jpg" alt="Apple Silicon"></p>
<p>关于中国的电子制造业，普遍的观念是那里劳动力成本低，所以才选择在那里建立外包工厂。我不确定他们去的是中国哪个地区，但事实是，中国早在多年前就不再是劳动力成本低的国家。从供应链的角度来看，劳动力成本并不是选择中国的原因，主要原因是中国能够提供的技能。</p>
<p>我们的产品需要非常先进的工具，这意味着整个配套技术都必须是最先进的。这需要很深的工具技能。在美国，你召开一次工具方面的工程师会议，我不知道能不能坐满一个会议室，但在中国，可以坐满多个足球场。</p>
<ul>
<li><a href="https://type.cyhsu.xyz/2020/03/on-the-popularity-of-newsletters/" target="_blank" rel="noopener">从邮件通讯的流行谈起</a></li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/nyt_nl.png" alt=""></p>
<p>放眼科技行业，近年无数新技术和平台都以「赋能」（empower）为使命，声称自己为用户和创作者提供了亟需的获取和传播信息的能力。然而，支撑着这种赋能叙事的，是一种「无能」的假定：用户没有能力自主找到需要的信息，而是需要算法来推荐和投喂；创作者没有能力自主和受众建立关系，而是需要平台和竞价「优化」来牵线搭桥。</p>
<p>邮件通讯和 RSS 等古旧技术的复苏有力地证伪了这种假定。它们表明，只要保障信息的自由流动、组合、处理——各种早期技术的普遍特征——用户就有能力搭配出符合兴趣且优质的信息「食谱」，创作者也有能力和用户建立直接、亲密的联系。相比于「赋能」，用户和创作者更需要的或许是「还能」，夺回他们被复杂技术以「赋能」名义攫取的独立获取或传播信息的能力。</p>
<p>但也正因如此，在使用和推广邮件通讯这样的「复古」技术时，应当避免对于其外在形式、渠道的过度强调。邮件通讯没有什么特殊的形式，而是抛开了各种不必要的形式，把信息不加包装、直截了当地送达读者；不是什么特殊的渠道，而是开辟了一个替代渠道，让用户在信息轰炸中获得自主掌控的空间。把握了这一点，不用拘泥于电子邮件的形式，也可以实现对信息区隔和分流的效果。反之，邮件通讯也可能被异化和商品化，为用户本就饱和的信息摄入徒增另一重负担。</p>
<h1 id="火花"><a href="#火花" class="headerlink" title="火花"></a>火花</h1><ul>
<li><a href="https://www.v2ex.com/t/692079" target="_blank" rel="noopener">你要悄悄学 Python ，然后惊艳所有人</a></li>
</ul>
<blockquote class="blockquote-center">
            <p>如果不打算投入程序员这个职业，建议学习掌握好 Office 三件套，受益终身<br>尤其是 Excel 。</p>
<p>—— V2EX 网友</p>

          </blockquote>

<ul>
<li><a href="https://www.v2ex.com/t/692187" target="_blank" rel="noopener">搞软件架构，是不是绕不开 Java ？</a></li>
</ul>
<blockquote class="blockquote-center">
            <p>架构和语言有什么关系？架构是方法论，语言只是工具。</p>
<p>楼主你需要跳出编程的层面去看问题，这样才能找到问题的核心。</p>
<p>—— V2EX 网友</p>

          </blockquote>
]]></content>
      <categories>
        <category>周刊</category>
      </categories>
  </entry>
  <entry>
    <title>SPARQL简易入门</title>
    <url>/2020/07/22/sparql-grammar-tutorial//</url>
    <content><![CDATA[<blockquote>
<p>最近在学习图数据库的基础知识。本文将参考 《<a href="http://learningsparql.com/" target="_blank" rel="noopener">Learning SPARQL: querying and updating with SPARQL 1.1</a>》这本书，简单介绍 RDF 数据查询语言 SPARQL。主要内容如下：</p>
<ol>
<li>SPARQL简介</li>
<li>SPARQL 基本语法</li>
<li>SPARQL 常见关键字</li>
<li>SPARQL 常见函数</li>
</ol>
</blockquote>
<h1 id="SPARQL-简介"><a href="#SPARQL-简介" class="headerlink" title="SPARQL 简介"></a>SPARQL 简介</h1><p>SPARQL（SPARQL Protocol and RDF Query Language）是一种数据查询语言。它不仅仅支持查询 RDF 数据，也可以在部分关系型数据库中对数据库进行数据操作。</p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>SPARQL 的语法与 SQL 很类似，也有许多不同之处。下面将简要介绍 SPARQL 的基本语法。</p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="变量和常量（字符串、数字及URI）"><a href="#变量和常量（字符串、数字及URI）" class="headerlink" title="变量和常量（字符串、数字及URI）"></a>变量和常量（字符串、数字及URI）</h3><p>在 SPARQL 语句中，通常以 <code>？变量名</code> 表示变量；而常量一般为字符串、数字及 URI，其中 URI 由尖括号（&lt; &gt;）包裹。</p>
<h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><ul>
<li>逗号（,）与分号（;）</li>
</ul>
<p>与 RDF Turtle 序列化格式类似，<code>;</code> 代表下一个三元组与当前三元组拥有<strong>相同的主语</strong>，<code>,</code> 代表下一个三元组与当前三元组拥有<strong>相同的主语和谓语</strong>。</p>
<ul>
<li>井号（#）</li>
</ul>
<p>在 SPARQL 脚本文件中（文件后缀名为 <code>.rq</code>），<strong><code>#</code> 为注释标记</strong>。</p>
<ul>
<li>尖括号（&lt; &gt;）</li>
</ul>
<p>尖括号常用来<strong>包裹 URI</strong>。</p>
<ul>
<li>星号（*）与加号（+）</li>
</ul>
<p>星号和加号常用于<strong>查询的正则匹配</strong>。在正则匹配中，<strong>星号</strong>代表<strong>零个或多个</strong>，<strong>加号</strong>代表<strong>一个或多个</strong>。例如，假设有一个论文相互引用的关系图，那么 <code>?s c:cites :paperA</code> 中的 <code>？s</code> 则代表所有一次直接引用 <code>:paperA</code> 的论文；而 <code>?s c:cites+ :paperA</code> 中的 <code>?s</code>则在前者的基础之上，进一步包含了间接引用 <code>:paperA</code> 的论文。</p>
<p>此外，与 SQL 相同，查询子句 <code>SELECT *</code> 中的星号代表所有数据。</p>
<ul>
<li>叹号（!）</li>
</ul>
<p>叹号用于布尔条件判断中的<strong>否定词</strong>。</p>
<ul>
<li>脱字符（^）</li>
</ul>
<p>脱字符在 SPARQL 中可用来修饰谓语，用来反转主语与宾语之间的关系。例如，假设有一个三元组 <code>s p o;</code> ，那么  <code>o ^p s;</code> 将与之等价（<strong>主宾颠倒</strong>）。 </p>
<ul>
<li>斜杠（/）</li>
</ul>
<p>斜杠用来分隔几个连续的谓语，例如，<code>?s c:cites/c:cites/c:cites :paperA</code> 中 <code>?s</code> 代表与 <code>:paperA</code> 引用属性距离为 3 的所有论文。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>SPARQL 支持多种关键词查询数据。这些关键词包括 <code>SELECT</code> 、<code>CONSTRUCT</code> 、<code>DESCRIBE</code> 、 <code>ASK</code> 。</p>
<ul>
<li><code>SELECT</code> 查询结果返回一个二维表（与 SQL 中 <code>SELECT</code> 类似），其语句一般格式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT [DISTINCT] &lt;variable1&gt; [&lt;variable2&gt; ...]</span><br><span class="line">[FROM ...]</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">    triple pattern 1.</span><br><span class="line">    [triple pattern 2.]</span><br><span class="line">    ...</span><br><span class="line">    [附加条件...]</span><br><span class="line">&#125;</span><br><span class="line">[OFFSET 数字]</span><br><span class="line">[LIMIT 数字]</span><br><span class="line">[ORDER BY | GROUP BY ...]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CONSTRUCT</code> 查询结果返回一个 RDF 图，其语句一般格式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONSTRUCT </span><br><span class="line">&#123; </span><br><span class="line">    triple pattern .</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line">WHERE </span><br><span class="line">&#123; </span><br><span class="line">    triple pattern . </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>关于 <code>CONSTRUCT</code> 更多用法请参看 <a href="https://www.w3.org/TR/sparql11-query/#construct" target="_blank" rel="noopener">W3C Recommendation</a></p>
          </div>

<ul>
<li><code>ASK</code> 查询结果返回真或者假，表示 RDF 数据中是否存在指定模式的三元组，其语句一般格式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ASK  </span><br><span class="line">&#123; </span><br><span class="line">    triple pattern .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>DESCRIBE</code> 查询结果返回对指定数据的资源描述（以 RDF 图的形式存储），该图的结果由 SPARQL 处理器决定（也就是说，不同 SPARQL 处理器运行同一条 <code>DESCRIBE</code> 查询语句，可能会有不同的结果），其语句一般格式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESCRIBE &lt;variable1&gt;|&lt;IRI1&gt; [&lt;variable2&gt;|&lt;IRI2&gt; ...]</span><br><span class="line">WHERE </span><br><span class="line">&#123;</span><br><span class="line">    triple pattern .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>关于 <code>DESCRIBE</code> 更多用法请参看 <a href="https://www.w3.org/TR/sparql11-query/#describe" target="_blank" rel="noopener">W3C Recommendation</a></p>
          </div>

<div class="note info">
            <p class="note-title">URLs, URN，URIs，IRIs</p><ul><li>URL（Uniform Resource Locator）：用于指明网络资源的位置。</li><li>URN（Universal Resource Name）：用于指明网络资源的名称。</li><li>URI（Universal Resource Identifier）：用于唯一指定资源，包含 URL 和 URN（很少在用）。</li><li>IRI（Internationalized Resource Identifier）：IRI 是 URI，但是可包含更广泛的字符（如中文等）</li></ul>
          </div>

<h3 id="增加（TBD）"><a href="#增加（TBD）" class="headerlink" title="增加（TBD）"></a>增加（TBD）</h3><h3 id="更新（TBD）"><a href="#更新（TBD）" class="headerlink" title="更新（TBD）"></a>更新（TBD）</h3><h3 id="删除（TBD）"><a href="#删除（TBD）" class="headerlink" title="删除（TBD）"></a>删除（TBD）</h3><h1 id="常见关键字"><a href="#常见关键字" class="headerlink" title="常见关键字"></a>常见关键字</h1><h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h2><p><code>WHERE</code> 用于指明查询条件，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex003.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?craigEmail</span><br><span class="line">WHERE</span><br><span class="line">&#123; ab:craig ab:email ?craigEmail . &#125;</span><br></pre></td></tr></table></figure>

<h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>和 SQL 一样，<code>DISTINCT</code> 用于消去查询结果中重复的数据项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex092.rq</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT ?p </span><br><span class="line">WHERE</span><br><span class="line">&#123; ?s ?p ?o . &#125;</span><br></pre></td></tr></table></figure>

<p>上述查询将会返回<strong>数据集中所有不重复的属性名称</strong>。当遇到一个新的数据集时，建议执行该脚本，从而初步认识该数据集。</p>
<h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p><code>FROM</code> 关键字常用于指明数据集所在位置，有以下两种形式：</p>
<ul>
<li><code>FROM &lt;URI&gt;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex123.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?email </span><br><span class="line">FROM &lt;ex069.ttl&gt;</span><br><span class="line">FROM &lt;ex122.ttl&gt;</span><br><span class="line">WHERE</span><br><span class="line">&#123; ?s ab:email ?email . &#125;</span><br></pre></td></tr></table></figure>

<p>例如，上述 SPARQL 脚本文件从 <code>&lt;ex069.ttl&gt;</code> 和 <code>&lt;ex122.ttl&gt;</code> 文件中查询数据</p>
<ul>
<li><code>FROM NAMED</code></li>
</ul>
<p><code>FROM NAMED</code> 为提供了在 Named Graph 中查询数据的功能。下面是一个具体的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex126.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?lname ?courseName </span><br><span class="line">FROM &lt;ex069.ttl&gt; </span><br><span class="line">FROM NAMED &lt;ex125.ttl&gt;</span><br><span class="line">FROM NAMED &lt;ex122.ttl&gt;   # unnecessary</span><br><span class="line"></span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  &#123; ?student ab:lastName ?lname &#125;</span><br><span class="line">  UNION</span><br><span class="line">  &#123; GRAPH &lt;ex125.ttl&gt; &#123; ?course ab:courseTitle ?courseName &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该查询包含三个数据集，一个是通过 <code>FROM &lt;URI&gt;</code> 指定，另外两个以 <code>FORM NAMED</code> 指定。在 <code>WHERE</code> 查询条件中，<code>GRAPH &lt;ex125.ttl&gt;</code> 说明下面一条三元组模式将仅在 <code>&lt;ex125.ttl&gt;</code> 中查找；如不指定 <code>GRAPH &lt;URI&gt;</code> ，则从 <code>FROM &lt;URI&gt;</code> 中查找。</p>
<div class="note info">
            <p class="note-title"><code>FROM &lt;URI&gt;</code> V.S. <code>FROM NAMED</code></p><ul><li><p>在使用 <code>FROM &lt;URI&gt;</code> 的方式指明数据集时，这些数据都会添加到一个默认的 RDF 图（default graph）中以供查询；</p></li><li><p>而 <code>FROM NAMED</code> 则不会将数据集加入到默认的 RDF 图中，需要在 <code>WHERE</code> 额外声明 <code>GRAPH &lt;URI&gt;</code> 才能仅在该 Named Graph 中查询数据。</p></li></ul>
          </div>

<h2 id="GRAPH"><a href="#GRAPH" class="headerlink" title="GRAPH"></a>GRAPH</h2><p><code>GRAPH</code> 常与 <code>FROM NAMED</code> 配合使用，用于指明下一个模式只在 <code>GRAPH</code> 指定的数据集中查询（例子见本文 <code>FROM NAMED</code> 部分）。</p>
<h2 id="OPTIONAL"><a href="#OPTIONAL" class="headerlink" title="OPTIONAL"></a>OPTIONAL</h2><p>关键词 <code>OPTIONAL</code> 的含义是，<strong>如果存在的话，请返回该值，否则返回为空</strong>。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex057.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?first ?last ?workTel</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?s ab:firstName ?first ;</span><br><span class="line">     ab:lastName ?last .</span><br><span class="line">  OPTIONAL </span><br><span class="line">  &#123; ?s ab:workTel ?workTel . &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述脚本查询了一个通讯录，无论其是否有工作电话这个属性（如果没有，将该值置空即可），都返回其名、姓和工作电话的值。</p>
<p><strong>一个查询脚本可有多个 <code>OPTIONAL</code> 子句，并且一个 <code>OPTIONAL</code> 子句可有多个匹配模式</strong>。值得注意的是，查询处理将<strong>先后</strong>处理 <code>OPTIONAL</code> 子句中的条件。利用这个特性，我们可以完成下列查询：优先返回每个人的昵称，如果没有则返回其名。查询脚本示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex063.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?first ?last</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?s ab:lastName ?last . </span><br><span class="line">  OPTIONAL &#123; ?s ab:nick ?first . &#125;</span><br><span class="line">  OPTIONAL &#123; ?s ab:firstName ?first . &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FILTER-、-FILTER-NOT-EXISTS-及-MINUS"><a href="#FILTER-、-FILTER-NOT-EXISTS-及-MINUS" class="headerlink" title="FILTER 、 FILTER NOT EXISTS 及 MINUS"></a>FILTER 、 FILTER NOT EXISTS 及 MINUS</h2><ul>
<li><code>FILTER</code></li>
</ul>
<p><code>FILTER</code> 意为筛选，顾名思义，其功能就是筛选出满足某种条件的数据。<code>FILTER</code> 接受一个结果为布尔量的输入：如果该布尔量为真，则选出；否则，不选。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex105.rq</span><br><span class="line"></span><br><span class="line">PREFIX dm: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;demo#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?s ?cost</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?s dm:cost ?cost .</span><br><span class="line">  FILTER (?cost &lt; 10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述查询就筛选出花费小于 10 的项目和具体花费。</p>
<ul>
<li><code>FILTER NOT EXISTS</code></li>
</ul>
<p><code>FILTER NOT EXISTS</code> 是 <code>FILTER</code> 的一种否定表达。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex067.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?first ?last </span><br><span class="line"></span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?s ab:firstName ?first ;</span><br><span class="line">     ab:lastName ?last .</span><br><span class="line">  FILTER NOT EXISTS &#123; ?s ab:workTel ?workNum &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述查询就筛选出没有工作电话的人的名和姓。</p>
<ul>
<li><code>MINUS</code></li>
</ul>
<p><code>MINUS</code> 表示在查询结果中减去满足某种模式的数据。那么，筛选出没有工作电话的人的名和姓也可以通过 <code>MINUS</code>  实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex068.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?first ?last </span><br><span class="line"></span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?s ab:firstName ?first ;</span><br><span class="line">     ab:lastName ?last .</span><br><span class="line">  MINUS &#123; ?s ab:workTel ?workNum &#125;</span><br></pre></td></tr></table></figure>

<h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><p>通过 <code>UNION</code> 关键字，我们可以合并不同模式匹配到的结果。例如下列查询使用了 <code>UNION</code> 得到了会演奏萨克斯或者小号的人的名、姓和能够演奏的乐器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex103.rq</span><br><span class="line"></span><br><span class="line">PREFIX ab: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;addressbook#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?first ?last ?instrument </span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">    ?person ab:firstName ?first ;</span><br><span class="line">            ab:lastName ?last ;</span><br><span class="line">            ab:instrument ?instrument . </span><br><span class="line"></span><br><span class="line">    &#123; ?person ab:instrument &quot;sax&quot; . &#125;</span><br><span class="line"></span><br><span class="line">    UNION</span><br><span class="line"></span><br><span class="line">    &#123; ?person ab:instrument &quot;trumpet&quot; . &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（NOT）IN"><a href="#（NOT）IN" class="headerlink" title="（NOT）IN"></a>（NOT）IN</h2><p><code>IN</code> 关键字用来判断指定变量是否在指定枚举集合中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex109.rq</span><br><span class="line"></span><br><span class="line">PREFIX dm:  &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;demo#&gt;</span><br><span class="line">PREFIX db: &lt;http:&#x2F;&#x2F;dbpedia.org&#x2F;resource&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?s ?cost ?location</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?s dm:location ?location ;</span><br><span class="line">     dm:cost ?cost . </span><br><span class="line">  FILTER (?location IN (db:Montreal, db:Lisbon)) . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述 <code>FILTER</code> 过滤条件为：地点是否在蒙特利尔或者里斯本。如果在，则选出，否则不选。</p>
<p><code>NOT IN</code> 为 <code>IN</code> 的否定形式。</p>
<h2 id="LIMIT-及-OFFSET"><a href="#LIMIT-及-OFFSET" class="headerlink" title="LIMIT 及 OFFSET"></a>LIMIT 及 OFFSET</h2><ul>
<li><code>LIMIT</code></li>
</ul>
<p><code>LIMIT</code> 用于限定返回数据显示的数量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex116.rq</span><br><span class="line"></span><br><span class="line">PREFIX rdfs: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;01&#x2F;rdf-schema#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?label </span><br><span class="line">WHERE</span><br><span class="line">&#123; ?s rdfs:label ?label . &#125;</span><br><span class="line">LIMIT 2</span><br></pre></td></tr></table></figure>

<ul>
<li><code>OFFSET</code></li>
</ul>
<p><code>OFFSET</code> 用于指定数据在返回数据的偏移量（即<strong>显示第几个数据</strong>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex118.rq</span><br><span class="line"></span><br><span class="line">PREFIX rdfs: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;01&#x2F;rdf-schema#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?label </span><br><span class="line">WHERE</span><br><span class="line">&#123; ?s rdfs:label ?label . &#125;</span><br><span class="line">OFFSET 3</span><br></pre></td></tr></table></figure>

<h2 id="ORDER-BY-和-GROUP-BY-HAVING-lt-条件-gt"><a href="#ORDER-BY-和-GROUP-BY-HAVING-lt-条件-gt" class="headerlink" title="ORDER BY 和 GROUP BY [HAVING &lt;条件&gt;]"></a>ORDER BY 和 GROUP BY [HAVING &lt;条件&gt;]</h2><ul>
<li><code>ORDER BY</code></li>
</ul>
<p>关键词 <code>ORDER BY</code> 告诉查询处理器，按照指定变量对返回结果进行排序（默认升序，降序需指明 <code>DESC(?变量名)</code>）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex146.rq</span><br><span class="line"></span><br><span class="line">PREFIX e: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;expenses#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?description ?date ?amount</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?meal e:description ?description ;</span><br><span class="line">        e:date ?date ;</span><br><span class="line">        e:amount ?amount . </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ORDER BY ?amount</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex148.rq</span><br><span class="line"></span><br><span class="line">PREFIX e: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;expenses#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?description ?date ?amount</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?meal e:description ?description ;</span><br><span class="line">        e:date ?date ;</span><br><span class="line">        e:amount ?amount . </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ORDER BY DESC(?amount)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>GROUP BY</code></li>
</ul>
<p><code>GROUP BY</code> 会将返回结果按照指定规则分组，可用 <code>HAVING &lt;条件&gt;</code> 做进一步条件限定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex164.rq</span><br><span class="line"></span><br><span class="line">PREFIX e: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;expenses#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?description (SUM(?amount) AS ?mealTotal)</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?meal e:description ?description ;</span><br><span class="line">        e:amount ?amount . </span><br><span class="line">&#125;</span><br><span class="line">GROUP BY ?description</span><br><span class="line">HAVING (SUM(?amount) &gt; 20)</span><br></pre></td></tr></table></figure>

<h2 id="AS"><a href="#AS" class="headerlink" title="AS"></a>AS</h2><p><code>AS</code> 用于给数据起名字，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex139.rq</span><br><span class="line"></span><br><span class="line">PREFIX e: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;expenses#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?description ?amount ((?amount * .2) AS ?tip) </span><br><span class="line">       ((?amount + ?tip) AS ?total)</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?meal e:description ?description ;</span><br><span class="line">        e:amount ?amount . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BIND"><a href="#BIND" class="headerlink" title="BIND"></a>BIND</h2><p><code>BIND</code> 用于给变量赋值。常见用法为 <code>BIND (数字计算 AS ?变量名)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 来源：https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;sparql11-query&#x2F;#bind</span><br><span class="line"></span><br><span class="line">PREFIX  dc:  &lt;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;elements&#x2F;1.1&#x2F;&gt;</span><br><span class="line">PREFIX  ns:  &lt;http:&#x2F;&#x2F;example.org&#x2F;ns#&gt;</span><br><span class="line"></span><br><span class="line">SELECT  ?title ?price</span><br><span class="line">&#123;  &#123; ?x ns:price ?p .</span><br><span class="line">     ?x ns:discount ?discount</span><br><span class="line">     BIND (?p*(1-?discount) AS ?price)</span><br><span class="line">   &#125;</span><br><span class="line">   &#123;?x dc:title ?title . &#125;</span><br><span class="line">   FILTER(?price &lt; 20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="VALUES"><a href="#VALUES" class="headerlink" title="VALUES"></a>VALUES</h2><p><code>VALUES</code> 提供了更方便的过滤数据的方式。其一般格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VALUES(?变量名1 [?变量名2 ...])</span><br><span class="line">&#123;</span><br><span class="line">    （变量名1应取值 [?变量名2应取值 ...]）</span><br><span class="line">    （变量名1应取值 [?变量名2应取值 ...]）</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"># 当条件仅有一个变量时，小括号可以省略</span><br></pre></td></tr></table></figure>

<p>将 <code>VALUES</code> 子句放在 <code>WHERE</code> 条件中，就可以筛选出变量名满足指定取值的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex498.rq</span><br><span class="line"></span><br><span class="line">PREFIX e: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;expenses#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?description ?date ?amount</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?meal e:description ?description ;</span><br><span class="line">        e:date ?date ;</span><br><span class="line">        e:amount ?amount . </span><br><span class="line"></span><br><span class="line">  VALUES (?date ?description) &#123;</span><br><span class="line">         (&quot;2011-10-15&quot; &quot;lunch&quot;) </span><br><span class="line">         (&quot;2011-10-16&quot; &quot;dinner&quot;)</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述查询则会从返回结果中过滤出 <strong>2011-10-15 的午饭</strong>和 <strong>2011-10-16 的晚饭</strong>的相关数据。</p>
<h2 id="UNDEF"><a href="#UNDEF" class="headerlink" title="UNDEF"></a>UNDEF</h2><p><code>UNDEF</code> 关键词代表任意值。下面一个例子返回结果满足这样的条件：任意时间下满足 <code>?description</code> 为 <code>&quot;lunch&quot;</code>的数据，以及任意 <code>?description</code> 下时间为 <code>&quot;2011-10-16&quot;</code> 的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex500.rq</span><br><span class="line"></span><br><span class="line">PREFIX e: &lt;http:&#x2F;&#x2F;learningsparql.com&#x2F;ns&#x2F;expenses#&gt; </span><br><span class="line"></span><br><span class="line">SELECT ?description ?date ?amount</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  ?meal e:description ?description ;</span><br><span class="line">        e:date ?date ;</span><br><span class="line">        e:amount ?amount . </span><br><span class="line"></span><br><span class="line">  VALUES (?date ?description) &#123;</span><br><span class="line">         (UNDEF &quot;lunch&quot;) </span><br><span class="line">         (&quot;2011-10-16&quot; UNDEF) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SERVICE"><a href="#SERVICE" class="headerlink" title="SERVICE"></a>SERVICE</h2><p>要查询远端的数据，一种方式是直接在 <code>FROM</code> 关键字之后指明 RDF 文件 URI：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex166.rq</span><br><span class="line"></span><br><span class="line">PREFIX dc: &lt;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;elements&#x2F;1.1&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?title</span><br><span class="line">FROM &lt;http:&#x2F;&#x2F;dig.csail.mit.edu&#x2F;2008&#x2F;webdav&#x2F;timbl&#x2F;foaf.rdf&gt;</span><br><span class="line">WHERE &#123; ?s dc:title ?title .&#125;</span><br></pre></td></tr></table></figure>

<p>除了 <code>FROM &lt;URI&gt;</code> 查询远端的 RDF 序列化文件，我们还可以用 <code>SERVICE</code> 关键字访问远端的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex167.rq</span><br><span class="line"></span><br><span class="line">PREFIX cat:     &lt;http:&#x2F;&#x2F;dbpedia.org&#x2F;resource&#x2F;Category:&gt;</span><br><span class="line">PREFIX skos:    &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2004&#x2F;02&#x2F;skos&#x2F;core#&gt;</span><br><span class="line">PREFIX rdfs:    &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;01&#x2F;rdf-schema#&gt;</span><br><span class="line">PREFIX owl:     &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2002&#x2F;07&#x2F;owl#&gt;</span><br><span class="line">PREFIX foaf:    &lt;http:&#x2F;&#x2F;xmlns.com&#x2F;foaf&#x2F;0.1&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?p ?o </span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  SERVICE &lt;http:&#x2F;&#x2F;DBpedia.org&#x2F;sparql&gt;</span><br><span class="line">  &#123; SELECT ?p ?o </span><br><span class="line">    WHERE &#123; &lt;http:&#x2F;&#x2F;dbpedia.org&#x2F;resource&#x2F;Joseph_Hocking&gt; ?p ?o . &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex170.rq</span><br><span class="line"></span><br><span class="line">PREFIX rdf:  &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns#&gt;</span><br><span class="line">PREFIX rdfs: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;01&#x2F;rdf-schema#&gt;</span><br><span class="line">PREFIX gp:   &lt;http:&#x2F;&#x2F;wifo5-04.informatik.uni-mannheim.de&#x2F;gutendata&#x2F;resource&#x2F;people&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?p ?o </span><br><span class="line">WHERE</span><br><span class="line">&#123; </span><br><span class="line">  SERVICE &lt;http:&#x2F;&#x2F;wifo5-04.informatik.uni-mannheim.de&#x2F;gutendata&#x2F;sparql&gt;</span><br><span class="line">  &#123; gp:Hocking_Joseph ?p ?o . &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>亦可从多个远端数据源联合查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filename: ex172.rq</span><br><span class="line"></span><br><span class="line">PREFIX cat:  &lt;http:&#x2F;&#x2F;dbpedia.org&#x2F;resource&#x2F;Category:&gt;</span><br><span class="line">PREFIX foaf: &lt;http:&#x2F;&#x2F;xmlns.com&#x2F;foaf&#x2F;0.1&#x2F;&gt;</span><br><span class="line">PREFIX gp:   &lt;http:&#x2F;&#x2F;wifo5-04.informatik.uni-mannheim.de&#x2F;gutendata&#x2F;resource&#x2F;people&#x2F;&gt;</span><br><span class="line">PREFIX owl:  &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2002&#x2F;07&#x2F;owl#&gt;</span><br><span class="line">PREFIX rdf:  &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns#&gt;</span><br><span class="line">PREFIX rdfs: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;01&#x2F;rdf-schema#&gt;</span><br><span class="line">PREFIX skos: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2004&#x2F;02&#x2F;skos&#x2F;core#&gt;</span><br><span class="line"></span><br><span class="line">SELECT ?dbpProperty ?dbpValue ?gutenProperty ?gutenValue </span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  SERVICE &lt;http:&#x2F;&#x2F;DBpedia.org&#x2F;sparql&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    &lt;http:&#x2F;&#x2F;dbpedia.org&#x2F;resource&#x2F;Joseph_Hocking&gt; ?dbpProperty ?dbpValue .</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SERVICE &lt;http:&#x2F;&#x2F;wifo5-04.informatik.uni-mannheim.de&#x2F;gutendata&#x2F;sparql&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    gp:Hocking_Joseph ?gutenProperty ?gutenValue . </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>注意：由于<code>SERVICE</code> 方式的远端查询在服务器端执行， <code>SERVICE</code> 后的 URI 应是远端 SPARQL 执行入口。</p>
          </div>

<h1 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h1><h2 id="MAX-、MIN-、AVG-、SUM-、COUNT"><a href="#MAX-、MIN-、AVG-、SUM-、COUNT" class="headerlink" title="MAX()、MIN()、AVG()、SUM()、COUNT()"></a>MAX()、MIN()、AVG()、SUM()、COUNT()</h2><p>这些聚集函数与 SQL 中类似，不再赘述。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要介绍了 SPARQL 语言的功能和基本语法，要点如下：</p>
<ul>
<li>在 SPARQL 语句中，通常以 <code>？变量名</code> 表示变量；而常量一般为字符串、数字及 URI，其中 URI 由尖括号（&lt; &gt;）包裹。</li>
<li>SPARQL 中使用了多种标点符号，具有丰富的含义。</li>
<li>SPARQL 支持多种关键词查询数据。这些关键词包括 <code>SELECT</code> 、<code>CONSTRUCT</code> 、<code>DESCRIBE</code> 、 <code>ASK</code> 。</li>
<li>SPARQL 提供了很多关键字，能够表达复杂的查询任务。</li>
<li>SPARQL 支持许多强大的函数，提高了其易用性。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>Bob DuCharme. <a href="http://learningsparql.com/" target="_blank" rel="noopener">Learning SPARQL: querying and updating with SPARQL 1.1</a></li>
<li><a href="https://www.w3.org/TR/sparql11-query/" target="_blank" rel="noopener">SPARQL 1.1 Query Language W3C Recommendation</a>.</li>
</ul>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><a href="https://www.dataversity.net/introduction-to-sparql/" target="_blank" rel="noopener">Introduction to: SPARQL</a></li>
</ul>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>SPARQL</tag>
        <tag>图数据库查询语言</tag>
      </tags>
  </entry>
  <entry>
    <title>RDF简介</title>
    <url>/2020/07/21/intro-to-rdf//</url>
    <content><![CDATA[<blockquote>
<p>最近在学习图数据库的基础知识。本文将参考 《<a href="http://learningsparql.com/" target="_blank" rel="noopener">Learning SPARQL: querying and updating with SPARQL 1.1</a>》这本书，简单介绍图数据的数据模型 RDF。主要内容如下：</p>
<ol>
<li>RDF 简介</li>
<li>RDF 三元组</li>
<li>RDF 存储格式</li>
<li>RDF 其他概念</li>
</ol>
</blockquote>
<h1 id="RDF-简介"><a href="#RDF-简介" class="headerlink" title="RDF 简介"></a>RDF 简介</h1><p>RDF 全称 Resource Description Framework（资源描述框架），是一种数据模型，它提供了一种独特的结构来存储数据文件。RDF 独特的结构使其在 Semantic Web、图数据库等领域应用十分广泛。</p>
<h1 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h1><p>在 RDF 中，每一个基本单元可由一个三元组 $(s,\ p,\ o)$ 构成，其中 $s$ 代表 subject（主语），$p$ 代表 predicate（谓语）， $o$ 代表 object（宾语）。每一个三元组都可以陈述这样一个事实：一个由 $s$ 唯一标记的资源实体拥有 $p$ 属性，其属性值为 $o$ 。</p>
<p>每一个三元组都可以通过图（graph）来表示，具体如下图：</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/triple.png" alt="三元组图示"></p>
<h1 id="存储方式及其结构"><a href="#存储方式及其结构" class="headerlink" title="存储方式及其结构"></a>存储方式及其结构</h1><h2 id="文件存储（序列化）"><a href="#文件存储（序列化）" class="headerlink" title="文件存储（序列化）"></a>文件存储（序列化）</h2><p>当数据以文件的形式存储时，RDF 有如下几种序列化格式</p>
<h3 id="RDF-XML"><a href="#RDF-XML" class="headerlink" title="RDF/XML"></a>RDF/XML</h3><p>RDF/XML 是最古老的格式，最初出现在 1999 年 RDF 规格说明中。顾名思义，这种方式采取了与 XML 类似的结构存储数据单元（也就是一个三元组）。一个简单的例子如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 本例来自书籍《Learning SPARQL》，详见参考资料（下同） --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Being XML, RDF/XML uses regular XML comment delimiters. --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- filename: ex029.rdf --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rdf:RDF</span> <span class="attr">xmlns:rdf</span>=<span class="string">"http://www.w3.org/1999/02/22-rdf-syntax-ns#"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:dc</span>=<span class="string">"http://purl.org/dc/elements/1.1/"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:v</span>=<span class="string">"http://www.w3.org/2006/vcard/"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">rdf:Description</span> <span class="attr">rdf:about</span>=<span class="string">"urn:isbn:006251587X"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dc:title</span>&gt;</span>Weaving the Web<span class="tag">&lt;/<span class="name">dc:title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dc:creator</span> <span class="attr">rdf:resource</span>=<span class="string">"http://www.w3.org/People/Berners-Lee/card#i"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rdf:Description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">rdf:Description</span> <span class="attr">rdf:about</span>=<span class="string">"http://www.w3.org/People/Berners-Lee/card#i"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">v:title</span>&gt;</span>Director<span class="tag">&lt;/<span class="name">v:title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rdf:Description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">rdf:RDF</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过 RDF/XML 格式存储时，其文件后缀名为 <code>.rdf</code>。文件中，所有数据由<code>&lt;rdf:RDF&gt;</code> 和 <code>&lt;/rdf:RDF&gt;</code> 包裹，并且在 <code>&lt;rdf:RDF&gt;</code> 属性中定义了前缀（prefix）。</p>
<div class="note info">
            <p class="note-title">前缀 prefix</p><p>RDF 是在 Semantic Web 的背景下提出的，而 Semantic Web 要求在全网下能够唯一标识一个资源，故其采用了 <code>URI</code> 作为资源的唯一标记。<code>URI</code> 一般较为冗长，而定义前缀 ，可以减少数据单元中冗长的书写，从而突出数据的重点；当处于不同的前缀中时，数据资源也不会因同名而相互冲突。由于第二点的优势， 前缀又被称作名称空间（namespace）。</p>
          </div>

<p>每一个数据单元的主语为 <code>rdf:Description</code> 中 <code>rdf:about</code> 属性的值；<code>rdf:Description</code> 子结点标签则代表了数据单元的谓语；宾语可以是 <code>rdf:Description</code> 子结点标签中的纯文字，也可以是子结点标签 <code>rdf:resource</code> 属性所设定的 URI 值。</p>
<p>由于 XML 受限的表达性、RDF/XML 数据文件解析困难等原因，RDF/XML 并没有流行开来。</p>
<h3 id="N3"><a href="#N3" class="headerlink" title="N3"></a>N3</h3><p>N3 是 Notation 3 的缩写，它是 RDF 序列化的另一种格式。这种格式继承了 RDF/XML 的优势，尝试改进并弥补了 RDF/XML 部分不足。下面是一个用 N3 格式存储的 RDF 数据：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># The hash symbol is the comment delimiter in n3. </span><br><span class="line"># filename: ex031.n3</span><br><span class="line"></span><br><span class="line">@prefix dc: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">purl.org</span>/<span class="attr">dc</span>/<span class="attr">elements</span>/<span class="attr">1.1</span>/&gt;</span> .</span><br><span class="line">@prefix v:  <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2006</span>/<span class="attr">vcard</span>/&gt;</span> .</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">People</span>/<span class="attr">Berners-Lee</span>/<span class="attr">card</span>#<span class="attr">i</span>&gt;</span></span><br><span class="line">      v:title "Director" .</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">urn:isbn:006251587X</span>&gt;</span></span><br><span class="line">      dc:creator <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">People</span>/<span class="attr">Berners-Lee</span>/<span class="attr">card</span>#<span class="attr">i</span>&gt;</span> ;</span><br><span class="line">      dc:title "Weaving the Web" .</span><br></pre></td></tr></table></figure>

<p>通过 N3 格式存储时，其文件后缀名为 <code>.n3</code>。与 RDF/XML 格式类似，N3 使用三元组来声明前缀。这个三元组中， <code>@prefix</code> 为主语，<code>&lt;prefix name&gt;:</code> 为谓语，<code>&lt;uri&gt;</code> 则为宾语，并且用英文句号作为三元组的结束标记。在声明完前缀之后，便可以接着以三元组的形式存储数据。例如，第 8 至 9 行为一个三元组，其主语为 <code>&lt;http://www.w3.org/People/Berners-Lee/card#i&gt;</code>，谓语为 <code>v:title</code>，宾语为 <code>&quot;Director&quot;</code>。该三元组说明，由主语标识的资源（此例为人）的头衔为 Director。第 11 至 13 行为第 2 、3 个三元组，分别表示由 <code>&lt;urn:isbn:006251587X&gt;</code> 所标识的书籍的作者是 <code>&lt;http://www.w3.org/People/Berners-Lee/card#i&gt;</code> 这个人；这本书的书名为 <code>&quot;Weaving the Web&quot;</code> 。</p>
<div class="note info">
            <p class="note-title">N3中的 <code>.</code>、<code>;</code>、<code>,</code></p><ul><li><code>.</code> 代表三元组的结束</li><li><code>;</code> 代表下一个三元组与当前三元组拥有<strong>相同的主语</strong></li><li><code>,</code> 代表下一个三元组与当前三元组拥有<strong>相同的主语和谓语</strong></li></ul>
          </div>

<h3 id="Turtle"><a href="#Turtle" class="headerlink" title="Turtle"></a>Turtle</h3><p>Turtle 是另一种 RDF 序列化的格式，并且使用十分广泛。下面是一个例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># filename: ex002.ttl</span><br><span class="line"></span><br><span class="line">@prefix ab: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">addressbook</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">ab:richard ab:homeTel "(229) 276-5135" . </span><br><span class="line">ab:richard ab:email   "richard49@hotmail.com" . </span><br><span class="line"></span><br><span class="line">ab:cindy ab:homeTel "(245) 646-5488" . </span><br><span class="line">ab:cindy ab:email   "cindym@gmail.com" . </span><br><span class="line"></span><br><span class="line">ab:craig ab:homeTel "(194) 966-1505" . </span><br><span class="line">ab:craig ab:email   "craigellis@yahoo.com" . </span><br><span class="line">ab:craig ab:email   "c.ellis@usairwaysgroup.com" .</span><br></pre></td></tr></table></figure>

<p>Turtle 格式与 N3 很类似，这里不再介绍。</p>
<h3 id="RDFa"><a href="#RDFa" class="headerlink" title="RDFa"></a>RDFa</h3><p>RDFa 是另一个受到用户们喜爱的 RDF 序列化格式。RDFa 不仅仅能以 XML 的格式存储，更强大的是其也能嵌入到 HTML 文件中。这使得 SPARQL 等查询工具能够轻松地从中获得以三元组形式存储的数据。下面展示了一个具体的<a href="https://www.dataversity.net/introduction-to-rdfa-2/" target="_blank" rel="noopener">例子</a>：</p>
<p>如果你有一个 HTML 文件，其中有下面一段代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">My name is Juan Sequeda. Please visit my homepage!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果将 RDFa 嵌入其中，那么可以这么写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">vocab</span>=<span class="string">"http://schema.org/"</span> <span class="attr">typeof</span>=<span class="string">"Person"</span>&gt;</span></span><br><span class="line">My name is</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">property</span>=<span class="string">"name"</span>&gt;</span>Juan Sequeda<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.</span><br><span class="line">Please visit</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">property</span>=<span class="string">"url"</span> <span class="attr">href</span>=<span class="string">"http://www.juansequeda.org/"</span>&gt;</span>my homepage<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h2><p>除了文件序列化存储方式，RDF 数据亦可存储在数据库中。数据库中 RDF 的存储结构通常由数据库管理系统决定。这里先搁置一边。</p>
<h1 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>根据上一节的例子，我们发现 RDF 中主要有两类数据，一类为 URI ，另一类为字符串。尽管很多处理 RDF 数据的工具能够根据字符串数据推测数据类型，但仍然建议你在数据中指明各个数据的类型。</p>
<div class="note info">
            <p class="note-title">没有双引号的字符串的类型推断</p><p>当你省略了字符串的双引号，那么处理 RDF 数据的工具将认为该数据类型要么是布尔量（真或假），要么是数字。</p>
          </div>

<p>在 Turtle 格式中，在数据后面加上两个脱字符（<code>^</code>），并指明标定数据类型的 URI（可使用前缀缩写表示，也可以使用完整的 URI 表示），就可以手动指定数据类型。具体的例子如下（第 7 至 10 行）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># filename: ex033.ttl</span><br><span class="line"></span><br><span class="line">@prefix xsd: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2001</span>/<span class="attr">XMLSchema</span>#&gt;</span> .</span><br><span class="line">@prefix d:   <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">data</span>#&gt;</span> .</span><br><span class="line">@prefix dm:  <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">demo</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">d:item342 dm:shipped     "2011-02-14"^^<span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2001</span>/<span class="attr">XMLSchema</span>#<span class="attr">date</span>&gt;</span> . </span><br><span class="line">d:item342 dm:quantity    "4"^^xsd:integer . </span><br><span class="line">d:item342 dm:invoiced    "false"^^xsd:boolean . </span><br><span class="line">d:item342 dm:costPerItem "3.50"^^xsd:decimal .</span><br></pre></td></tr></table></figure>

<p>在 RDF/XML 格式中，数据类型由数据标签中 <code>rdf:datatype</code> 属性值所确定（第 8 至 15 行）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- filename: ex035.rdf --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rdf:RDF</span> <span class="attr">xmlns:rdf</span>=<span class="string">"http://www.w3.org/1999/02/22-rdf-syntax-ns#"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:dm</span>=<span class="string">"http://learningsparql.com/ns/demo#"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema#"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">rdf:Description</span> <span class="attr">rdf:about</span>=<span class="string">"http://learningsparql.com/ns/demo#item342"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dm:shipped</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">rdf:datatype</span>=<span class="string">"http://www.w3.org/2001/XMLSchema#date"</span>&gt;</span>2011-02-14<span class="tag">&lt;/<span class="name">dm:shipped</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dm:quantity</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">rdf:datatype</span>=<span class="string">"http://www.w3.org/2001/XMLSchema#integer"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">dm:quantity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dm:invoiced</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">rdf:datatype</span>=<span class="string">"http://www.w3.org/2001/XMLSchema#boolean"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">dm:invoiced</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dm:costPerItem</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">rdf:datatype</span>=<span class="string">"http://www.w3.org/2001/XMLSchema#decimal"</span>&gt;</span>3.50<span class="tag">&lt;/<span class="name">dm:costPerItem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rdf:Description</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">rdf:RDF</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="语言标记、标签"><a href="#语言标记、标签" class="headerlink" title="语言标记、标签"></a>语言标记、标签</h2><h3 id="lang"><a href="#lang" class="headerlink" title="@lang"></a>@lang</h3><p>RDF 支持国际化，即对于同一个数据，有针对不同语言的不同表示。其一般格式为<code>数据@语言缩写</code>（语言缩写参考了 ISO 639 以及 ISO 3166-1）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># filename: ex037.ttl</span><br><span class="line"></span><br><span class="line">@prefix :     <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">demo</span>#&gt;</span> . </span><br><span class="line">@prefix rdfs: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2000</span>/<span class="attr">01</span>/<span class="attr">rdf-schema</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">:sideDish42 rdfs:label "french fries"@en-US . </span><br><span class="line">:sideDish42 rdfs:label "chips"@en-GB . </span><br><span class="line"></span><br><span class="line">:sideDish43 rdfs:label "chips"@en-US . </span><br><span class="line">:sideDish43 rdfs:label "crisps"@en-GB .</span><br></pre></td></tr></table></figure>

<h3 id="rdfs-label、rdfs-comment"><a href="#rdfs-label、rdfs-comment" class="headerlink" title="rdfs:label、rdfs:comment"></a>rdfs:label、rdfs:comment</h3><p><code>rdfs:label</code>、<code>rdfs:comment</code> 是 RDF 中非常重要的两个属性名。<code>rdfs:label</code> 通常用来以方便人阅读的名称指代资源，<code>rdfs:comment</code> 通常用来更细节地描述资源。这两个属性值会加深我们对相关资源的理解。</p>
<div class="note info">
            <p>P.S. 在 W3C SKOS 标准下，有两个相关的属性，分别是 <code>skos:prefLabel</code>（代表偏好标签） 和 <code>skos:altLabel</code>（代表替代标签）。</p>
          </div>

<h2 id="空结点及其作用"><a href="#空结点及其作用" class="headerlink" title="空结点及其作用"></a>空结点及其作用</h2><p>在实际情况下，有很多数据是复合数据，即该数据可以分解为更小的数据项（小数据项并不可再分）。例如，地址信息就可以分解为国家、省份、城市、区县、街道、邮编等数据项。那么，如何在 RDF 中表示这样的数据呢？这就需要引入一个独特的结点——空结点。</p>
<p>具体的，空结点将作为联系复合数据属性与各个小数据项之间的桥梁：一是作为复合数据属性（谓语）的属性值（宾语），二是作为小数据项谓语的主语。举个书上的例子你就能理解了（其中 <code>_:b1</code> 为空结点）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># filename: ex041.ttl</span><br><span class="line"></span><br><span class="line">@prefix ab: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">addressbook</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">ab:i0432 ab:firstName    "Richard" ;</span><br><span class="line">        ab:lastName      "Mutt" ;</span><br><span class="line">        ab:homeTel       "(229) 276-5135" ;</span><br><span class="line">        ab:email         "richard49@hotmail.com" ;</span><br><span class="line">        ab:address       _:b1 .</span><br><span class="line"></span><br><span class="line">_:b1    ab:postalCode    "49345" ;</span><br><span class="line">        ab:city          "Springfield" ;</span><br><span class="line">        ab:streetAddress "32 Main St." ;</span><br><span class="line">        ab:region        "Connecticut" .</span><br></pre></td></tr></table></figure>

<p>由此可知，空结点的一般格式为 <code>_:&lt;空结点名称&gt;</code></p>
<div class="note info">
            <p>有时，Turtle 和 SPARQL 也使用方括号（<code>[]</code>）代表空结点。</p>
          </div>

<h2 id="Named-Graphs"><a href="#Named-Graphs" class="headerlink" title="Named Graphs"></a>Named Graphs</h2><p>和空结点类似，Named Graphs 也可以用来将一些相关的三元组组合在一起。而与之不同的是，Named Graphs 更加强大——可进一步赋予其元数据（metadata）。这种特性使得 Named Graphs 在某些应用场景下有着独特的优势。</p>
<h2 id="RDF-模式和-OWL"><a href="#RDF-模式和-OWL" class="headerlink" title="RDF 模式和 OWL"></a>RDF 模式和 OWL</h2><p>在程序设计中，经常会考虑复用问题，因为复用可以有效提高软件开发效率。十分幸运，RDF 也提供了复用方案，即 RDF 模式和 OWL（Web Ontological Language）。</p>
<p>RDF 模式使用一系列三元组描述了有关该类资源的事实（如指明 <code>rdf:type</code>、 <code>rdfs:label</code> 、<code>rdf:comment</code> 等）。这些事实也被称为该类资源的元数据。</p>
<p>下面是两个具体的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># filename: ex042.ttl</span><br><span class="line"></span><br><span class="line">@prefix dc:   <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">purl.org</span>/<span class="attr">dc</span>/<span class="attr">elements</span>/<span class="attr">1.1</span>/&gt;</span> .</span><br><span class="line">@prefix rdf:  <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">1999</span>/<span class="attr">02</span>/<span class="attr">22-rdf-syntax-ns</span>#&gt;</span> .</span><br><span class="line">@prefix rdfs: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2000</span>/<span class="attr">01</span>/<span class="attr">rdf-schema</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">dc:creator</span><br><span class="line">      rdf:type rdf:Property ;     </span><br><span class="line">      # a rdf:Property ;</span><br><span class="line">      rdfs:comment "An entity primarily responsible for making the resource."@en-US ;</span><br><span class="line">      rdfs:label "Creator"@en-US .</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># filename: ex043.ttl</span><br><span class="line"></span><br><span class="line">@prefix ab:   <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">addressbook</span>#&gt;</span> .</span><br><span class="line">@prefix rdf:  <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">1999</span>/<span class="attr">02</span>/<span class="attr">22-rdf-syntax-ns</span>#&gt;</span> .</span><br><span class="line">@prefix rdfs: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2000</span>/<span class="attr">01</span>/<span class="attr">rdf-schema</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">ab:Musician</span><br><span class="line">      rdf:type rdfs:Class ;</span><br><span class="line">      rdfs:label "Musician" ;</span><br><span class="line">      rdfs:comment "Someone who plays a musical instrument" .</span><br><span class="line"></span><br><span class="line">ab:MusicalInstrument</span><br><span class="line">      a rdfs:Class ;</span><br><span class="line">      rdfs:label "musical instrument" .</span><br></pre></td></tr></table></figure>

<p>在元数据中，有两个非常特殊的属性 <code>rdfs:domain</code> 和 <code>rdfs:range</code> ：</p>
<ul>
<li><code>rdfs:domain</code> ：<strong>该属性的值是 <code>rdfs:domain</code> 所在三元组主语的类别</strong></li>
<li><code>rdfs:range</code>  ：<strong>该属性的值是 <code>rdfs:range</code> 所在三元组宾语的类别</strong></li>
</ul>
<p>依照这样的关系，在 RDF 中，我们能推理出很多隐藏在图中的结论。</p>
<div class="note info no-icon">
            <p class="note-title">面向对象 V.S. RDF 模式</p><ul><li>在面向对象系统中，需要实例化一个类，生成一个对象，并将具体的值赋给这个对象。</li><li>在基于 RDF 的标准下，为资源的元数据添加一个属性，就有可能使得该资源属于某一个之前未属于的类别。</li></ul>
          </div>

<p>然而，RDF 模式还是有限的，它无法描述类之间的联系。要解决这个问题，便引入了 OWL。</p>
<p>下面，我将结合书上的例子说明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># filename: ex046.ttl</span><br><span class="line"></span><br><span class="line">@prefix ab:   <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">learningsparql.com</span>/<span class="attr">ns</span>/<span class="attr">addressbook</span>#&gt;</span> .</span><br><span class="line">@prefix rdf:  <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">1999</span>/<span class="attr">02</span>/<span class="attr">22-rdf-syntax-ns</span>#&gt;</span> .</span><br><span class="line">@prefix rdfs: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2000</span>/<span class="attr">01</span>/<span class="attr">rdf-schema</span>#&gt;</span> .</span><br><span class="line">@prefix owl:  <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.w3.org</span>/<span class="attr">2002</span>/<span class="attr">07</span>/<span class="attr">owl</span>#&gt;</span> .</span><br><span class="line"></span><br><span class="line">ab:i0432  </span><br><span class="line">   ab:firstName "Richard" ;</span><br><span class="line">   ab:lastName  "Mutt" ;</span><br><span class="line">   ab:spouse    ab:i9771 . </span><br><span class="line"></span><br><span class="line">ab:i8301  </span><br><span class="line">   ab:firstName "Craig" ;</span><br><span class="line">   ab:lastName  "Ellis" ;</span><br><span class="line">   ab:patient   ab:i9771 . </span><br><span class="line"></span><br><span class="line">ab:i9771</span><br><span class="line">   ab:firstName "Cindy" ; </span><br><span class="line">   ab:lastName  "Marshall" .  </span><br><span class="line"></span><br><span class="line">ab:spouse</span><br><span class="line">   rdf:type owl:SymmetricProperty ; </span><br><span class="line">   rdfs:comment "Identifies someone's spouse" .</span><br><span class="line"></span><br><span class="line">ab:patient </span><br><span class="line">   rdf:type rdf:Property ;</span><br><span class="line">   rdfs:comment "Identifies a doctor's patient" . </span><br><span class="line"></span><br><span class="line">ab:doctor </span><br><span class="line">   rdf:type rdf:Property ;</span><br><span class="line">   rdfs:comment "Identifies a doctor treating the named resource" ;</span><br><span class="line">   owl:inverseOf ab:patient .</span><br></pre></td></tr></table></figure>

<p>其中，<code>ab:spouse</code> 的 <code>rdf:type</code> 为 <code>SymmetricProperty</code> ，表示这个属性是对称的。在本例中，ab:i0432 的配偶是 ab:i9771 ，那么根据对称属性的性质推理，我们可以得到，ab:i9771 的配偶则是 ab:i0432 。又如，<code>ab:doctor</code> 的 <code>owl:inverseOf</code> 的值为 <code>ab:patient</code>，则在本例中，由于 ab:i8301 有一位病人 ab:i9771，则 ab:i9771 有一位医生 ab:i8301。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要介绍了有关 RDF 的基本概念、格式、存储结构和其他一些细节。最后，对全文做一个简单的总结。</p>
<ul>
<li>RDF 全称 Resource Description Framework（资源描述框架），是一种数据模型，它提供了一种独特的结构来存储数据文件。</li>
<li>RDF 数据单元是一个三元组 $(s,\ p,\ o)$ ，其中 $s$ 代表 subject（主语），$p$ 代表 predicate（谓语）， $o$ 代表 object（宾语）。每一个三元组都可以陈述这样一个事实：一个由 $s$ 唯一标记的资源实体拥有 $p$ 属性，其属性值为 $o$ 。</li>
<li>RDF 数据的存储主要有两种：文件序列化存储（包括 RDF/XML、Turtle、RDFa 等格式）、数据库存储。</li>
<li>RDF 中的数据类型指定一般可表示为 <code>数据^^&lt;数据类型URI&gt;</code> 。</li>
<li>RDF 支持国际化，一般格式为<code>数据@语言缩写</code>。</li>
<li><code>rdfs:label</code>、<code>rdfs:comment</code> 是 RDF 中非常重要的两个属性名。<code>rdfs:label</code> 通常用来以方便人阅读的名称指代资源，<code>rdfs:comment</code> 通常用来更细节地描述资源。</li>
<li>RDF 中，空结点可用来连接数据。</li>
<li>Named Graphs 可用于组合三元组数据，并可赋予一些元数据。</li>
<li>RDF 模式和 OWL 可用于 RDF 资源、属性的复用。RDF 模式中可定义类、属性的事实元数据，并提供给外界使用，达到复用的目的；OWL 则扩展了 RDF 模式的表达性，从而支持描述类之间的关系。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>Bob DuCharme. <a href="http://learningsparql.com/" target="_blank" rel="noopener">Learning SPARQL: querying and updating with SPARQL 1.1</a></li>
<li>Juan Sequeda. <a href="https://www.dataversity.net/introduction-to-rdfa-2/" target="_blank" rel="noopener">Introduction to: RDFa</a>.</li>
<li>Juan Sequeda. <a href="https://www.dataversity.net/introduction-to-ontologies/" target="_blank" rel="noopener">Introduction to: Ontologies</a>.</li>
</ul>
<h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><ul>
<li><a href="https://www.w3.org/TR/rdf-primer/" target="_blank" rel="noopener">W3C RDF Primer</a></li>
<li><a href="https://www.dataversity.net/introduction-to-rdf-vs-xml/" target="_blank" rel="noopener">Introduction to: RDF vs XML</a></li>
</ul>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>RDF</tag>
        <tag>数据模型</tag>
      </tags>
  </entry>
  <entry>
    <title>考研备考之我见</title>
    <url>/2020/07/02/kao-yan-bei-kao-zhi-wo-jian/</url>
    <content><![CDATA[<blockquote>
<p> 2020 的上半年不知不觉已经过去，不知各位读者在这魔幻的半年过得如何。随之而来的暑假，对于 21 届考研 er 来说，是十分重要的一个复习阶段。如何把握好这一黄金时段，我想每一个考研学子都对此十分关心。本文带着答疑解惑的目的，从我自身的角度出发，分（tu）析（cao）一下过去一年的考研情况，并给出我的复习建议。希望对各位读者有所帮助。本文的主要内容如下：</p>
<ol>
<li>考情分析</li>
<li>各科目复习建议</li>
<li>时间安排</li>
<li>心态调整</li>
</ol>
</blockquote>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/07/aaron-burden-QJDzYT_K8Xg-unsplash.jpg" alt="题图"></p>
<p>Photo by <a href="https://unsplash.com/@aaronburden?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Aaron Burden</a> on <a href="https://unsplash.com/s/photos/study?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
<h1 id="考情分析"><a href="#考情分析" class="headerlink" title="考情分析"></a>考情分析</h1><p><strong>肖老政治翻车，考生一片哀嚎！</strong>考研政治界有句名言，“政治考得怎么样，全靠肖老发挥得好不好”。作为前命题组组长，肖老在前几年押题技术一流。基本坐实考研政治界的一把交椅。面对每次的 “考前质疑，考后真香” 的评价，在大题部分，我从徐涛换到了肖老。于是，大题只是背了肖四。今年情况怎样？我主观感觉，肖老确实牛，大部分材料都押中了，只不过出题角度、解题思路有些偏差，我给五星好评！据今年考生评价（来源于网络，可信度自行甄别），可能徐涛的 “小黄书” 更切题一些。估计，今后肖老的热度可能会减少。</p>
<p><strong>英一十年未考，Notice 又来了！</strong>对于今年的英一，大部分吐槽在小作文。十年未考的 Notice，今年英一把考生打了个措手不及。与往常的信件不同， Notice 有其独有的格式和写法。大部分人因不清楚格式而焦虑。从结果看来，格式并不会成为拉分的关键一项，英语的重点还是在阅读。不排除考试中紧张的因素，我认为完型难度略有提高，阅读难度一般，新题型难度提升，翻译和作文难度下降。总的来说，英语难度中等。如果英语基础较好，只需掌握命题人的套路，一般能拿到不错的分数。</p>
<p><strong>数一难度经典再现，与 18 年难度持平！</strong>在第一天接受到政治和英语的双重打击，大部分考生心态出现了较大的波动。我第一天考完的晚上也是挺焦虑的。听了宇哥的“最后一聊”，才逐渐缓过神来：“第一天政治和英语是过关性考试，才 200 分，基本拉不开差距；…… 而明天的两门才是重头戏，有 300 分 ……”。平复了自己的心情，又重新背了一遍公式，我就睡了。第二天拿到试卷，我前后翻了翻：嗯，题不难，挺常规的。做着做着发现，这题目上手简单，做着做着就发现做不下去了。特别是高数部分后面几题，看似简单，实则有不少硬骨头，压轴的我更是没有什么思路。今年的线代部分，考得也颇具新意，对于我这种基础不扎实的人来说，有些力不从心。概率部分比较常规，思路和计算都很传统。据宇哥分析，近几年数学呈现 “多样化” “特色化” 发展。以前，可能数一和数二靠的近一些，经常抽查公共考点。而近几年，三种数学开始分叉，将考察重点放在了专供的考点上（比如数一会重点考察无穷级数、曲线面积分等；数二重点考察物理应用等；数三重点考察经济应用等）。这种趋势，可能需要后续的学子多多关注自己数学的专供部分，做好充分的准备。</p>
<p>我的专业课是自命题，不好做宏观分析，就此略过。</p>
<h1 id="各科目复习建议"><a href="#各科目复习建议" class="headerlink" title="各科目复习建议"></a>各科目复习建议</h1><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="我的复习过程"><a href="#我的复习过程" class="headerlink" title="我的复习过程"></a>我的复习过程</h3><p>数学我开始的挺早，寒假开始复习。利用寒假时间，我看完了张宇高数基础班。在这个阶段，我拿着习题集很难有解题思路，于是我听了别人的建议，在每次视频看完一讲后，把视频课上的例题重新做一遍，配合基础班划的题目，基本了解了高数的公共知识点。</p>
<p>3 、4 月份开学，实验室那边抓我去处理大创结题的工作，写结题报告，交论文初稿，让我基本很难空出大块的时间复习数学。在这段时间，数学基本是荒废了。</p>
<p>4 月下旬，我才重新捡起数学的复习。用了几天调整，回到了复习的状态。视频都能听懂，一到做题就傻眼了，习题答案中总有些知识点我不知道。这时我才意识到<strong>光看视频是不够的</strong>！我拿出张宇的 18 讲，开始数一专供知识点补完计划。计划执行到中旬，我越来越感到吃力，张宇的难度不是吹的。想过中途换书，可是都看了一半了，存在适应时间成本，我还是咬牙坚持了下来。这部分知识，说实话，我挺模糊的。尤其是曲线面积分，在没有本科学习的情况下，尤为吃力。</p>
<p>结束了高数数一专供补完计划，时间大概到了 5 月中旬。这时候，我开始准备线代。看了几节张宇线代的基础班，还是不会做题。听说别人已经把 660 刷完了，我有点慌（后来才知道，人家是二战，才有这样的进度。别轻易被别人的进度影响，做好自己就行）。于是，开始看张宇的线代 9 讲。做了几讲，发现我太菜了，根本肝不动（这本参考书挺有水平的，基础不好的人慎选）。然后，我赶紧换了汤神复习全书，开始肝其中的线代和概率部分，做这书上的课后题（这块还是比较基础的，如果基础不扎实，强推）。大概到 7 月初完成了第一轮数一复习。</p>
<p>七月初，我用张宇的闭关修炼开始跟宇哥的数学强化班。强化班确实讲得通透，而且比较全面。其中总结的出题思路，解题方法对我启发很大。虽说张宇的闭关修炼将高数浓缩成了 8 讲，但由于数一的内容实在太多，我基本按照一周一讲的进度推进，暑假结束后，才忙完了高数强化。我每讲的复习流程如下：</p>
<ol>
<li><strong>看视频，做笔记，划重点，写例题思路</strong></li>
<li><strong>重新做一遍例题（完整解题过程），特别是视频课中提到的同类问题</strong></li>
<li><strong>做汤神 1800 基础部分对应章节</strong></li>
<li><strong>总结提炼重要错题、公式、结论</strong></li>
</ol>
<p>9 月开始线代和概率强化，和高数复习一样的流程。由于线代和概率套路固定，掌握起来比高数简单不少，我花了一个月，并在国庆前完成了第二轮数一复习。</p>
<p>10 月开始肝数学一真题。2000 年以前的真题每天 2 套（因为简单），2000 以后的真题每周 1 到 2 套（周日同一时间，掐表模拟）。在这段时间，各个名师的模拟卷也出版了。我每周也挑了一天空闲的上午，做模拟卷。此外也花了些时间补 1800 强化部分的习题。总的来说，<strong>小段空余时间就刷题。有大块空闲时间就刷一套真题或者模拟卷。</strong></p>
<p>刷题、刷卷的阶段，一直持续到最后。期间也会复习遗忘的知识点，进一步总结做题思路，形成自己的知识框架。</p>
<h3 id="建议及推荐材料"><a href="#建议及推荐材料" class="headerlink" title="建议及推荐材料"></a>建议及推荐材料</h3><p>对各位考生，我的建议是：</p>
<ol>
<li><strong>视频不是终点，会做题才是王道！</strong>视频可以作为了解知识点的起点，如要完整的掌握，还需与配套的参考书和习题一起食用。视频无论讲的多好，或多或少有知识点的遗漏。这时一定要回归参考书，利用参考书补全遗漏的知识，做到考研知识点的全覆盖。</li>
<li><strong>注意细节，养成良好的做题习惯！</strong>无论大题、小题在练习时，都要写出每一步计算过程；每步推导做到有理有据，不要敷衍了事。具体怎么做，你可以看看汤神的真题解析是如何解题的。我认为主要要做到，就算是打草稿，也要注意细节，把推导过程、计算过程写明白。这样，你到最后上场答题时，凭借习惯也能做到写出来的东西都能拿到过程分。</li>
<li><strong>形成自己的复习闭环，做到高效复习！</strong>从理解基础知识，到会做题，再到总结，这三步缺一不可（当然，你可在此基础增添个性化的内容）。制定良好的复习流程，反复执行，形成习惯，就会使得你快速进入复习状态，同时也不会轻易被外界因素扰乱了阵脚。</li>
<li><strong>反复练习，熟能生巧；多做模拟，见见世面！</strong>数学复习一看做题的熟练程度，二看做题的广度。做题的熟练程度要靠习题，有时间尽量多刷几遍；做题的广度要靠模拟卷，建议最后冲刺阶段，各类名师的模拟卷都买来试试。张宇、李林、汤家凤等都是不错的选择。</li>
</ol>
<p>我在复习数一时所用的材料主要是张宇系列和汤家凤系列。</p>
<p>基础阶段：张宇基础班 + 汤家凤复习全书（打基础） + 张宇 36 讲（补充提高）</p>
<p>强化阶段：张宇强化班 + 张宇闭关修炼 + 1800（基础部分）</p>
<p>真题阶段：汤家凤真题 + 1800 （提高部分）</p>
<p>冲刺阶段：张宇 8+4（8 套卷史称劝退卷，用来见世面）、李林 6+4（比汤神难，比宇哥简单，受不了张宇可考虑李林） 、汤家凤 8 套卷（难度都在计算量上，普遍解题思路清晰）、合工大森哥 5 套卷（文都出版；部分题目出题角度较偏，用来补充）、张同斌决胜冲刺 4 套卷（文都出版；简单，用来重振士气）</p>
<h2 id="专业课"><a href="#专业课" class="headerlink" title="专业课"></a>专业课</h2><h3 id="我的复习过程-1"><a href="#我的复习过程-1" class="headerlink" title="我的复习过程"></a>我的复习过程</h3><p>花了大量时间复习数学，其实是压缩了我专业课复习的时间。最后结果我挺后悔的，没拿到较好的分数。都怪自己专业课时间花得太少。</p>
<p>我暑假开始复习专业课。从数据结构开始。先过了一遍王道，做了王道对应的的选择题加深记忆。由于暑假数学高数强化部分压力确实很大，导致数据结构的复习断断续续，直到暑假结束才看完数据结构。</p>
<p>9 月份，数学复习压力小了，专业课复习的效率也快了一些。分别用两周时间过了一遍操作系统和计算机组成原理，并做了王道上小节练习的选择题巩固。</p>
<p>之后开始做真题，上手偏难。主要是知识点掌握不牢固，知识点遗忘等原因。对着真题，到王道回顾知识点，做总结笔记。做多了之后，我也发现，自命题的专业课确实有套路，我就重点关注了常考点，并没有再完整的过一遍考纲（作者注：这里我轻敌了，其实专业课并没有那么简单）。到了考场上就现原形了，机组的浮点数 IEEE 标准我忘了，痛失 10 分！</p>
<h3 id="建议及推荐材料-1"><a href="#建议及推荐材料-1" class="headerlink" title="建议及推荐材料"></a>建议及推荐材料</h3><p>对各位考生，我的建议是：</p>
<ol>
<li><strong>参考书、教材为主，视频为辅。</strong>数学的复习占据了大量时间，这意味着可能你并没有足够的时间完整地看完专业课视频（况且部分专业课还没有视频辅导）。这时只能依靠参考书和教材，复习知识点。如果遇到难以理解的知识点，比如数据结构中算法执行流程是怎样的，可以找来对应知识点的视频观看。</li>
<li><strong>对照考纲，复习全面</strong>：考过的可能再考，没考过的也可能出现。每天花些时间，复习几个专业课知识点，保持专业课复习的热度，做到考纲知识，全面不漏。</li>
</ol>
<p>我复习的材料是王道计算机考研辅导，如果大家有考计算机相关的研究生可以参考。</p>
<h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><h3 id="我的复习过程-2"><a href="#我的复习过程-2" class="headerlink" title="我的复习过程"></a>我的复习过程</h3><p>在寒假，我看了一些英语的导学课，并针对自己的英语水平，执行了如下的计划：</p>
<ul>
<li>寒假开学后，到暑假前，我看了唐静的翻译强化（老版；新版出来后我发现，该部分也没更新）、王江涛的写作基础，背了一些单词和作文（用来解闷，数学太难顶了）。</li>
<li>暑假开始，每周一套真题（周六下午同一时间），配合唐迟的阅读强化，学习阅读技巧。</li>
<li>9、10 月看了刘畅的作文强化（这老师好像最近几年不讲了），开始找空闲时间练习作文。</li>
<li>继续练习真题，找题感。</li>
</ul>
<h3 id="建议及推荐材料-2"><a href="#建议及推荐材料-2" class="headerlink" title="建议及推荐材料"></a>建议及推荐材料</h3><p>对于英语的复习，我有几点经验分享给大家。按照重要性排序，我对各部分的复习建议如下：</p>
<ul>
<li>阅读：<strong>跟紧唐迟</strong>，抓住“<strong>阅读的本质是逻辑</strong>”，多做真题体会。</li>
<li>翻译：<ul>
<li>基础好的同学可以完整的跟<strong>唐静的翻译强化</strong>，边听边练习（就是视频中，他会停下来，让你分析做题，一定要听话）；</li>
<li>而对于基础较差的同学（主谓宾装补句子成分都搞不清的同学），我推荐逻汉班中<strong>宋逸轩</strong>老师，几节直播课救命（一般 9 月份以后才出版，想要早点复习的，可以只看老版的翻译部分）。</li>
</ul>
</li>
<li>作文：<strong>除了背，还要写！</strong>小作文有固定格式，一般将题目信息表达到位，基本分都能到手。大作文有固定套路，一般分为三段。<strong>第一段，图画（或图表）描述；第二段，观点论证、原因分析；第三段，解决对策、建议及号召</strong>。我的复习方法是：<ul>
<li><strong>用 00 ~10 年的真题练手，这阶段主要是分段练习</strong>：只练习某一段的写法。如一段时间内，只练习图画描述怎么写。练习流程是先自己写一遍，再自己改一遍（主要改语法错误），接着看范文，积累常见功能词汇和句子，并摘抄下来，供日后复习。</li>
<li><strong>11 ~ 20 年的真题模拟</strong>：有了 10 年的真题训练和词汇、句子积累，就可以将后 10 年的题目，当作模拟，掐表练习（小作文 15 ~ 20分钟，大作文 30 ~ 35 分钟），完整的写出一篇作文。</li>
</ul>
</li>
<li>新题型：听<strong>逻汉班唐迟</strong>讲解。</li>
<li>完型：全靠语感。</li>
</ul>
<h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><h3 id="我的复习过程-3"><a href="#我的复习过程-3" class="headerlink" title="我的复习过程"></a>我的复习过程</h3><p>暑假每天中午饭后一小时，看徐涛强化视频（正好助眠），做对应的真题选择题。</p>
<p>9 月做模拟习题的选择题。等肖八出来，开始做肖八的选择题。徐涛 8 套卷也只做了选择题。随后，就把政治撂倒一边。</p>
<p>肖四出来，还剩大约两周，这段时间开始花时间背肖四。</p>
<h3 id="建议及推荐材料-3"><a href="#建议及推荐材料-3" class="headerlink" title="建议及推荐材料"></a>建议及推荐材料</h3><p>我选择的材料是<strong>徐涛全套及肖八、肖四</strong>。最后大题只是背了肖四。如果你最后时间比较充裕，我建议你跟徐涛 11 月开始在公众号上的背诵计划，这可以全面提升你的政治觉悟；如果没时间，老老实实背肖四，60 分保底总会有的。</p>
<h1 id="时间安排"><a href="#时间安排" class="headerlink" title="时间安排"></a>时间安排</h1><p>从暑假开始，我的复习时间安排大致如下，供你参考。你可以在此基础上根据实际情况，灵活调整。</p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">复习内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">暑假</td>
<td align="center">数学强化、英语强化、专业课基础、政治强化及选择题</td>
</tr>
<tr>
<td align="center">9月 ~ 10 月</td>
<td align="center">数学真题、英语真题、专业课真题、英语大小作文</td>
</tr>
<tr>
<td align="center">11 月 ~ 12 月</td>
<td align="center">数学模拟、英语大小作文、英语真题、专业课真题、政治大题</td>
</tr>
</tbody></table>
<p>此外，也请你关注关键的时间点！到暑假开始后，你最好<strong>确定目标院校</strong>。如果还没确定，学硕还是专硕要确定好（也就是你要准备复习 数一 + 英一，还是 数二 + 英二）。</p>
<p>9 月份，学校的<strong>招生简章</strong>会出来，可能部分专业会换专业课。这个时间，你要充分考虑自己的复习情况，<strong>合理调整自己的目标</strong>。</p>
<p>10 月份会<strong>网上预报名</strong>和<strong>正式报名</strong>。推荐在报名前几周，<strong>拍</strong>好自己的<strong>证件照</strong>（不能带眼镜、头发不要太长，要把耳朵露出来），报名时及时上传。</p>
<p>报名后可以按照往年的考场安排，提前在考点附近<strong>预定宾馆</strong>。</p>
<h1 id="心态调整"><a href="#心态调整" class="headerlink" title="心态调整"></a>心态调整</h1><p>备考期间，请保持良好心态，每周留些时间放松自己，别把自己闷坏了。每天坚持锻炼，健康的身体才是革命的本钱。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>对于复习，我的建议是<strong>复习全面，练习熟练</strong>。尽可能的把考研的<strong>知识点</strong>做到<strong>全覆盖</strong>，使用思维导图等工具加深记忆；各种习题<strong>按类强化训练</strong>，<strong>动手做题</strong>，而非看完了事；知识点和习题要<strong>多遍滚动复习</strong>，熟能生巧，才有足够底气！</p>
<p>另外，准备研究生入学考试是一场马拉松。切忌两天打鱼，三天晒网，只需<strong>以你的速率保持匀速前进</strong>，跟紧大部队，即可战胜大部分人。在此期间，也要<strong>张弛有度</strong>，保持良好心态，每周留下些时间放松自己。这样无论遇到什么困难，你也会满血复活！</p>
<p>最后，祝愿各位<strong>一战成硕，一研为定</strong>！</p>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="https://cosmosning.github.io/2020/06/27/ru-he-xie-yi-feng-yan-jiu-sheng-zi-jian-xin/">如何写一封研究生自荐信</a></p>
]]></content>
      <categories>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>考试复习</tag>
      </tags>
  </entry>
  <entry>
    <title>用数据复盘我的考研初试</title>
    <url>/2020/06/30/yong-shu-ju-fu-pan-wo-de-kao-yan-chu-shi/</url>
    <content><![CDATA[<blockquote>
<p>受今年疫情的影响，2020 届研究生录取阶段到近几周才画上圆满的句号。距离开学还有些空闲时间，这段时间作为终点和起点的交会，是绝好的复盘机会。本文尝试以图表、关键的统计量简单地分析本年度南航官方公布的初试成绩情况，量化我的初试水平，并从这些客观的数据中分析原因，找到自身的不足，做好未来的打算。</p>
<p>此外，本文亦希望读者可从数据分析中窥探出考研趋势，规划好自己的准备工作。</p>
</blockquote>
<h1 id="2020-南航计算机考研初试情况概述"><a href="#2020-南航计算机考研初试情况概述" class="headerlink" title="2020 南航计算机考研初试情况概述"></a>2020 南航计算机考研初试情况概述</h1><p>（数据来源：<a href="http://cs.nuaa.edu.cn/2020/0520/c10851a200876/page.htm" target="_blank" rel="noopener">官方公布的初试成绩（仅包括进入复试的部分）</a>）</p>
<p>我对上述数据，分专业、分科目分别统计了分数情况。</p>
<h2 id="电子信息（专硕）"><a href="#电子信息（专硕）" class="headerlink" title="电子信息（专硕）"></a>电子信息（专硕）</h2><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF-%E6%94%BF%E6%B2%BB%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="电子信息-zhengzhi"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">政治</td>
<td align="center">78</td>
<td align="center">56</td>
<td align="center">66.41</td>
<td align="center">66</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF-%E8%8B%B1%E4%B8%80%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="电子信息-英一"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">英一</td>
<td align="center">85</td>
<td align="center">39</td>
<td align="center">65.70</td>
<td align="center">67</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF-%E6%95%B0%E4%BA%8C%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="电子信息-数二"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数二</td>
<td align="center">134</td>
<td align="center">65</td>
<td align="center">95.34</td>
<td align="center">94.5</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF-829%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="电子信息-829"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">829</td>
<td align="center">134</td>
<td align="center">64</td>
<td align="center">100.69</td>
<td align="center">101</td>
</tr>
</tbody></table>
<h2 id="计算机科学与技术（学硕）"><a href="#计算机科学与技术（学硕）" class="headerlink" title="计算机科学与技术（学硕）"></a>计算机科学与技术（学硕）</h2><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF-%E6%94%BF%E6%B2%BB%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="计算机科学与技术-zhengzhi"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">政治</td>
<td align="center">76</td>
<td align="center">59</td>
<td align="center">68</td>
<td align="center">68.5</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF-%E8%8B%B1%E4%B8%80%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="计算机科学与技术-英一"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">英一</td>
<td align="center">85</td>
<td align="center">43</td>
<td align="center">67.90</td>
<td align="center">70</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF-%E6%95%B0%E4%B8%80%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="计算机科学与技术-数一"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">126</td>
<td align="center">73</td>
<td align="center">95.88</td>
<td align="center">97</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF-829%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="计算机科学与技术-829"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">829</td>
<td align="center">130</td>
<td align="center">87</td>
<td align="center">110.63</td>
<td align="center">110.5</td>
</tr>
</tbody></table>
<h2 id="软件工程（学硕）"><a href="#软件工程（学硕）" class="headerlink" title="软件工程（学硕）"></a>软件工程（学硕）</h2><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E6%94%BF%E6%B2%BB%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="软件工程-zhengzhi"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">政治</td>
<td align="center">76</td>
<td align="center">60</td>
<td align="center">67.93</td>
<td align="center">68</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%8B%B1%E4%B8%80%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="软件工程-英一"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">英一</td>
<td align="center">81</td>
<td align="center">47</td>
<td align="center">65.93</td>
<td align="center">69</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E6%95%B0%E4%B8%80%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="软件工程-数一"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">115</td>
<td align="center">69</td>
<td align="center">89.34</td>
<td align="center">86</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-829%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="软件工程-829"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">829</td>
<td align="center">143</td>
<td align="center">66</td>
<td align="center">102.41</td>
<td align="center">104</td>
</tr>
</tbody></table>
<h2 id="网络空间安全（学硕）"><a href="#网络空间安全（学硕）" class="headerlink" title="网络空间安全（学硕）"></a>网络空间安全（学硕）</h2><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8-%E6%94%BF%E6%B2%BB%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="网络空间安全-zhengzhi"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">政治</td>
<td align="center">76</td>
<td align="center">56</td>
<td align="center">66.94</td>
<td align="center">66.5</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8-%E8%8B%B1%E4%B8%80%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="网络空间安全-英一"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">英一</td>
<td align="center">81</td>
<td align="center">49</td>
<td align="center">65.5</td>
<td align="center">65.5</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8-%E6%95%B0%E4%B8%80%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="网络空间安全-数一"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">119</td>
<td align="center">57</td>
<td align="center">82.66</td>
<td align="center">80.5</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8-829%E5%88%86%E6%95%B0%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5.png" alt="网络空间安全-829"></p>
<table>
<thead>
<tr>
<th align="center">学科</th>
<th align="center">最高</th>
<th align="center">最低</th>
<th align="center">均分</th>
<th align="center">中位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">829</td>
<td align="center">118</td>
<td align="center">82</td>
<td align="center">99.88</td>
<td align="center">100.5</td>
</tr>
</tbody></table>
<h1 id="量化我的水平"><a href="#量化我的水平" class="headerlink" title="量化我的水平"></a>量化我的水平</h1><p>如何量化我的水平呢？这里我使用了如下方法。</p>
<p>首先，拿到本专业分科目的成绩数据。具体的对于我来说，我抽取了软件工程专业的各科分数。然后将单科成绩分别降序排名。从中找到我的分数的位次，并除以总进复试人数，获得一个百分比。针对不同百分比，每一科按照如下要求打分：</p>
<p>当百分比落在</p>
<ul>
<li>0 % ~ 20 %：打 5 分</li>
<li>21% ~ 40%： 打 4 分</li>
<li>41% ~ 60%： 打 3 分</li>
<li>61% ~ 80%： 打 2 分</li>
<li>81% ~ 100%： 打 1 分</li>
</ul>
<p>我以上述方式量化的我的水平，具体如下：</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/%E8%83%BD%E5%8A%9B%E9%9B%B7%E8%BE%BE%E5%9B%BE.png" alt="能力雷达图"></p>
<p>初步分析可以发现，我的技能树有些歪，存在较为严重的偏科现象。英语有非常好的优势，数学处于中等水平，而政治和专业课则严重脱了我的后腿。</p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><ol>
<li>英语一直是我的强势科目，这要感谢初、高中英语的高强度的训练和全面的知识框架，让我不用太多时间，便能适应考研英语的套路。</li>
<li>在准备研究生入学考试时，数学是我重点关注的工作，花了很多时间和精力做题训练。但没料到今年数一难度加大（数一今年全国均分 65 左右，类似 2018 年，具体数据可以参考各个考研老师的分析。我记得宇哥在今年 0 基础 30 讲视频里讲过），让我原形毕露，考的分数十分难看。不过，能够在同专业内排到中等水平，这是出乎我意料的，也是令我比较惊喜的。难的数学也会有好处，会把哪些比你强一点的半吊子也拉下来，和你“平起平坐”。</li>
<li>专业课是我比较后悔的。这种情况完全是我过度轻视，缺少必要的时间投入导致的。</li>
<li>政治不做评价。</li>
</ol>
<h1 id="今后打算"><a href="#今后打算" class="headerlink" title="今后打算"></a>今后打算</h1><p>最近选定了导师，今后会做知识图谱和深度学习的相关工作。希望自己在新的阶段，除了做项目、看文献，也需抽出时间提升自己的专业水平。为此，我制定了如下关键任务：</p>
<ul>
<li><input disabled="" type="checkbox"> 每天至少 1 小时左右的专业知识学习</li>
<li><input disabled="" type="checkbox"> 每周 1 篇博文，总结关键重要的知识点</li>
<li><input disabled="" type="checkbox"> …（待补充）</li>
</ul>
<p>谨以此篇，作为近阶段学习工作的复盘。</p>
]]></content>
      <categories>
        <category>复盘</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>研究生</tag>
        <tag>初试</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写一封研究生自荐信</title>
    <url>/2020/06/27/ru-he-xie-yi-feng-yan-jiu-sheng-zi-jian-xin/</url>
    <content><![CDATA[<blockquote>
<p>投自荐信和简历投了一个多月，经过许多心酸和痛苦，今天终于成功选定中意的导师。谨以此文纪念这段经历。本文希望通过自身复盘，总结一些研究生自荐信的注意点，供读者参考。主要内容包括：</p>
<ol>
<li>如何确定发信对象</li>
<li>如何构思自荐信的内容</li>
<li>如何设置发信邮箱</li>
<li>如何选定自荐信发送的时机</li>
<li>如何回复导师的回信</li>
</ol>
<p>最后，本文也留了一个彩蛋，简单地回顾了期间发生的一些事情。想看故事的，可以直接跳到最后一部分。</p>
</blockquote>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/markus-winkler-Lp4jsVg8gpY-unsplash.jpg" alt="题图"></p>
<p>Photo by <a href="https://unsplash.com/@markuswinkler?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Markus Winkler</a> on <a href="https://unsplash.com/s/photos/email?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
<h1 id="如何确定发信对象"><a href="#如何确定发信对象" class="headerlink" title="如何确定发信对象"></a>如何确定发信对象</h1><p>确定发信对象，也就是要确定自己未来三年的导师。推荐到学院官网上查询相关导师的介绍。一来可以了解导师的研究方向，二来可以查到导师的电子邮件地址。这些都会为后续的工作做好准备。</p>
<p>针对导师的选择，建议结合自己的专业基础和兴趣所在。专业基础相近的（跨考的别打我），导师培养起来也方便；兴趣更是三年研究生生涯的精神支柱之一。建议同方向的导师多关注几位，防止最后在一个树上吊死。</p>
<p>不要害怕给老师发自荐信。学术大牛、副教授、青年优秀学者，都试试。万一哪个大牛看上你的经历，那不是赚发了？当然，也不必盯着几个大咖不放，这些热门的教授也许早就被推免生报满了，留给统考的机会并不多。</p>
<p>也许，你并不想在学术上有多高的造诣。直想 3 年，做做项目，拿到毕业证就行了。这种情况下，你可以选一些偏工程方向的导师，尤其对于专硕而言。</p>
<h1 id="如何构思自荐信的内容"><a href="#如何构思自荐信的内容" class="headerlink" title="如何构思自荐信的内容"></a>如何构思自荐信的内容</h1><p>自荐信内容的构思可以分两步走：</p>
<ol>
<li>构思简历</li>
<li>构思自荐信</li>
</ol>
<p>简历相当于是自荐信的提纲，而自荐信则是简历的扩充与细节描述。接下来，我结合自己的简历和自荐信聊聊这两部分内容。</p>
<h2 id="如何构思简历（附-Markdown-模板）"><a href="#如何构思简历（附-Markdown-模板）" class="headerlink" title="如何构思简历（附 Markdown 模板）"></a>如何构思简历（附 Markdown 模板）</h2><p>简历可以从以下几个方面构思：</p>
<ul>
<li>基本信息：介绍自己的姓名、政治面貌、联系方式等等（可加上自己的证件照）</li>
<li>教育背景：介绍自己的毕业院校，所学专业，成绩、绩点、专业排名等等</li>
<li>科研或项目经历：介绍自己的科研经历或者是项目经历。如果获奖，也可在此列出。未获奖的话，就简单概括一下使用什么技术，解决了什么问题，有什么创新等等。</li>
<li>社会实践：专业相关的实习或者社会实践</li>
<li>获奖情况：按国家级、省级、校级分类，按专业重要性排序</li>
<li>基本技能：英语能力（四六级、托福雅思等）、专业基础能力（软件、编程语言、实验仪器等）</li>
</ul>
<p>Markdown 模板如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">## 基本信息</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"flex:1;max-width:fit-content;margin:5px;"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>姓名&amp;emsp;&amp;emsp;XXX&amp;emsp;&amp;emsp;&amp;emsp;政治面貌&amp;emsp;&amp;emsp;XXX（非(预备)党员删除）<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>手机&amp;emsp;&amp;emsp;XXX&amp;emsp;&amp;emsp;&amp;emsp;电子邮箱&amp;emsp;&amp;emsp;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:XXX@example.com"</span>&gt;</span></span>XXX@example.com<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"flex:1;max-width: 100px;height: 100px;margin-left: 50px;"</span> <span class="attr">src</span>=<span class="string">"XXX.jpg"</span> <span class="attr">alt</span>=<span class="string">"证件照"</span>/&gt;</span></span>证件照部分，使用时请删掉<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">## 教育背景</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>20XX.09 ~ 20XX.06&amp;emsp;XXX大学&amp;emsp;本科&amp;emsp;XXX专业&amp;emsp;平均绩点：<span class="strong">**XXX / 满绩点（排名情况）**</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 科研经历（或项目经历）</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>20XX.XX ~ 20XX.XX&amp;emsp;XX研究或者XX项目（获了什么奖、使用那些技术、有什么创新等等，不展开，简略概括即可）</span><br><span class="line"></span><br><span class="line"><span class="section">## 实践活动（社会实践）</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>20XX.XX ~ 20XX.XX.XX&amp;emsp;参加了什么活动，拿过什么奖，锻炼了什么能力（最好和专业相关，志愿者活动对于一般理工科来说，就不用写了）</span><br><span class="line"></span><br><span class="line"><span class="section">## 获奖情况</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span><span class="strong">**国家级（X 项）**</span></span><br><span class="line"><span class="bullet">  - </span>XXX（如果能查到，建议写上该奖项获奖比例或者奖项排名，下同）</span><br><span class="line"><span class="bullet">  - </span>（专业相关学科竞赛等，下同）</span><br><span class="line"><span class="bullet">- </span><span class="strong">**省级（X 项）**</span></span><br><span class="line"><span class="bullet">  - </span>XXX</span><br><span class="line"><span class="bullet">- </span><span class="strong">**校级（X 项）**</span></span><br><span class="line"><span class="bullet">  - </span>XXX</span><br><span class="line"><span class="bullet">  - </span>（例如奖学金等）</span><br><span class="line"></span><br><span class="line"><span class="section">## 基本技能</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span><span class="strong">**英语**</span>：&amp;emsp;&amp;emsp;&amp;emsp;CET-4：XXX 分&amp;emsp;CET-6：XXX 分（托福、雅思也可列入其中）</span><br><span class="line"><span class="bullet">* </span><span class="strong">**专业技能**</span>：&amp;emsp;（简单列举一些专业相关的技术，不一定要面面俱到，选自己熟悉的即可）</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>将上述 Markdown 模板拷入 <a href="https://typora.io/" target="_blank" rel="noopener">Typora</a> ，即可编辑。编辑完成后，导出成 PDF 文件即可。此外，建议将内容浓缩到一页以内，方便导师查阅。</p>
          </div>

<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/resume_result.PNG" alt="简历效果图"></p>
<p>写完简历后，也可以在简历文件中附上自己的获奖证书、四六级证书、本科成绩单等等。这些可以作为自荐信的附件内容，供导师查看。</p>
<h2 id="如何构思自荐信（附自荐信模板）"><a href="#如何构思自荐信（附自荐信模板）" class="headerlink" title="如何构思自荐信（附自荐信模板）"></a>如何构思自荐信（附自荐信模板）</h2><p>有了简历的提纲挈领，再构思自荐信就会容易一些。推荐从以下几个方面构思</p>
<ul>
<li>自己的基本情况：自己是谁？毕业于哪里？学的什么专业？本科成绩怎么样？初复试成绩怎么样？（如果知道排名，也可以加上）</li>
<li>自己的科研（项目）经历：承担什么责任？使用什么技术？解决了什么问题？效果（最好将此项量化而非模糊地解释）怎么样？（如果觉得技术方面没什么好讲的，可以聊聊项目锻炼了哪些能力或者培养了哪些品质）</li>
<li>简述自己的获奖情况、英语能力、专业能力。</li>
<li>针对老师的方向做简单的夸赞，并表示愿意深入研究。</li>
<li>写明自己期待老师回复的内容（如还有没有名额等等）</li>
<li>寒暄语</li>
<li>署名及日期</li>
</ul>
<p>以下是具体的模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XXX教授&#x2F;博士：</span><br><span class="line"></span><br><span class="line">您好！</span><br><span class="line"></span><br><span class="line">感谢您百忙之中抽出时间查看这封邮件！</span><br><span class="line"></span><br><span class="line">我是XXX，本科就读于XXX，学的是XXX专业，今年 6 月毕业；</span><br><span class="line">本科期间专业综合排名XX名，拿过XX奖学金；</span><br><span class="line">本次报考贵校XX专业（学硕和专硕一定要注明），初试总分 XXX （XX&#x2F;XX&#x2F;XX&#x2F;XX，排名&#x2F;进复试人数），</span><br><span class="line">复试总分 XXX，总成绩 XX（排名&#x2F;录取人数），已被拟录取。</span><br><span class="line"></span><br><span class="line">本科期间，我从XXX(时间)开始跟一位老师做了 XX 的研究(项目)。</span><br><span class="line">···（具体介绍科研经历及项目）。</span><br><span class="line">在此期间，我学到了 XXX，对 XXX 产生了浓厚的兴趣。</span><br><span class="line">这一段研究经历除了引起我的兴趣以外，我觉得更重要的一点是磨练了我的XXX，培养了 XXX 精神。</span><br><span class="line"></span><br><span class="line">在本科阶段，我也积极参加各种校级、省级的学科竞赛，获得了XX、XX、XX奖项。</span><br><span class="line">英语方面，我四六级都已经通过，其中四级 XXX ，六级 XXX 。</span><br><span class="line">专业技能方面，我熟悉 XXX，会使用 XXX。（附件是我的个人简历和主要证书，欢迎您下载查看）</span><br><span class="line"></span><br><span class="line">我在研究生导师介绍中找到您的主页，并且十分佩服您在XXX等方向多年的研究积淀和前瞻性的行业洞察；</span><br><span class="line">我本身对此十分感兴趣。</span><br><span class="line">因此，我希望加入您的组，接受您的任意研究工作安排。（这一块要针对导师的具体介绍，做个性化设计）</span><br><span class="line"></span><br><span class="line">不知道您是否还有研究生名额？您对研究生的要求是怎样的？期待您的回复！</span><br><span class="line"></span><br><span class="line">最后，祝愿老师身体健康，工作顺利！</span><br><span class="line"></span><br><span class="line">此致</span><br><span class="line"></span><br><span class="line">敬礼！</span><br><span class="line"></span><br><span class="line">署名</span><br><span class="line">日期</span><br></pre></td></tr></table></figure>

<p>在自荐信书写过程中，最好加粗邮件中的关键词或关键句子，以提高导师阅读邮件效率。自荐信书写完后，建议先自己阅读一遍，检查是否存在错别字，专业名词及缩写、大小写是否符合规范。保证内容无误后，推荐先给自己其他邮箱发一份，作为测试。看看不同终端（网页端、电脑客户端、平板端、手机端等）的阅读体验，将格式（如字号、缩进、空格等等）调整至一个最佳的阅读状态。这些细节都调整好后，就可以准备发自荐信了。</p>
<h1 id="如何设置发信邮箱"><a href="#如何设置发信邮箱" class="headerlink" title="如何设置发信邮箱"></a>如何设置发信邮箱</h1><p>在发信之前，需要选择合适的邮箱，并进行合理的设置。对于邮箱的选择，国内各大主流邮箱都可以作为发信邮箱。当然，你也可以使用某个 404 网站的邮箱。而在邮箱设置中，最重要的是合理修改自己的发信昵称，一般设置为自己的真实姓名，方便导师辨别。不然的话，使用奇怪的发信昵称，也许就会给导师留下不好的印象。另外，写好邮件的主题，也会方便导师查阅及回复。我是用的邮件主题是 <code>自荐信-姓名-专业（注明学硕、专硕）</code>。</p>
<p>除此以外，邮件也可以设置定时发送。定好合适的时间发送，可能也会有一些价值。具体我将在下一节介绍。</p>
<h1 id="如何选定自荐信发送的时机"><a href="#如何选定自荐信发送的时机" class="headerlink" title="如何选定自荐信发送的时机"></a>如何选定自荐信发送的时机</h1><p>发信的时间其实很重要，这在一定程度上决定了你能否抢到一些导师的名额。这里的时机又分为大时间和小时间。</p>
<p>大时间是指在什么阶段适合发自荐信。通常来说，如果你的初试成绩较高，可在复试之前，提前预定导师名额，抢先一步。这个阶段不建议海投，盯住几个，发送自荐信即可。如果你的初试成绩一般，本科有非常出色的经历，可以考虑发一些自荐信试试。如果初试成绩一般，本科也并不出色，我建议此阶段就不用花费精力打扰导师了，专心准备复试就行。在拟录取名单出来后，如果你被拟录取，那么要抓紧时间联系。这段时间，如果你没有肯定能选上的导师，请不要吝啬你的自荐信。多投！多投！多投！收不到回信也不用怕，不要停止发送，除非已经有你钟意的导师敲定要你。</p>
<p>小时间是指什么时间点投递自荐信。中午休息、下午下班或晚上晚饭后的时间较为合适。这些时间，很可能导师正在查阅邮件，回复所等待的时间也就会短一些。此外，一些导师也有不错的发信礼仪，他也会在与你投递的相同时间给你回信。这就极大地提高了及时回信的概率。我选择的时间是下午 5：00 ，推荐你也试试。</p>
<p>此外，我统计了我自己收到回复的时间情况，希望对你有所帮助。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/time.png" alt="回复时间直方图"></p>
<p>其中，晚上 8 点 到 9 点是回复的高峰期，推荐你此时保持邮件和手机畅通。</p>
<h1 id="如何回复导师的回信"><a href="#如何回复导师的回信" class="headerlink" title="如何回复导师的回信"></a>如何回复导师的回信</h1><p>一般几个星期没动静的邮件，基本都是凉了。而有的可能并不会给肯定答复。除非回复名额已满，否则需要盯紧其他回复的导师。比如发个相关研究的问题咨询，向导师要个微信等等。当导师向你递出橄榄枝，那么恭喜你，已经成功了第一步。如果你觉得这个导师还不错，那么赶紧和他讨论研究课题，询问学习任务，提早进入状态；如果你还想等其他导师的回复，那么可以再等一等。多个导师给你发 offer 后，请多与导师交流，敲定一个。对于其他接受你的导师，请礼貌地发一封邮件拒绝。（具体写法可在网上找到）</p>
<h1 id="彩蛋：一个多月的投信故事"><a href="#彩蛋：一个多月的投信故事" class="headerlink" title="彩蛋：一个多月的投信故事"></a>彩蛋：一个多月的投信故事</h1><div class="note warning">
            <p>（声明：以下内容仅是我的主观回忆和感受，可能与事实存在出入。其中并不包含对任意个人、集体贬低的意思。如有，我对此深表惬意）</p>
          </div>

<p>从拟录取公示之后，我着手开始查阅导师信息。看到感兴趣的，先将网页收藏起来（具体的，我使用新版 Edge 的集锦功能，类似收藏功能但比收藏好用，强推！），之后再细选。之后，我写好了自荐信的模板，在 5 月 22 日发了第一封。这封当晚收到回复！但是很遗憾，这名教授名额满了。经过几天的细选，我又发了一封。石沉大海！出师不利，让我郁闷了好几天，加上毕业设计最后的遗留工作，我不得不暂时停下了发信这件事（作者注：其实这块时间不能松懈，也许很多机会就是在这段时间内溜走了）。</p>
<p>到了 6 月初，忙完了毕设，赶紧重新拾起发自荐信的工作。现在回想起来，这段时间我还是发的太少，两周内平均一周只发了一封。其结果也不尽如人意，一封没动静，一封说今年名额还未分配完成，让我再等等。我还真是天真，就停下开始等待名额正式分配完成！我感觉，大致是辜负了这段时间，导致后期到处吃瘪。</p>
<p>6 月 23 日，考研 QQ 群里传来了名额分配的公示（一张打印的纸），我才突然缓过神来，我好像还没导师确定要我！就像期末考试前几天，复习效率贼高一样，这几天我发了发信总数 60 % 的自荐信，但大部分是失败告终（作者注：到这个时间点，基本大部分导师都报满了，只有少部分有名额，所以当你已经被拟录取了，自荐信一定不要停，别像我一样，弄得灰头土脸）。好不容易，有个确定回复。我一问学长、学姐，心又凉了半解。据不可靠消息，这名导师为什么到双选后期仍然有名额，我想你我都懂。</p>
<p>怎么办？要不等分配吧，我想。</p>
<p>但是，我可不想未来 3 年过的太难受。我重新审视了一遍我的邮件模板。将最后期待老师回复的内容部分中的 <code>您对研究生的要求是怎样的？</code> 替换成了 <code>如果您的名额已满，能否推荐给其他老师？</code> 。再次开始投递自荐信。</p>
<p>6 月 24 日晚上，一封回复重新点燃了我的热情！这位导师看了我的背景，似乎十分激动（我猜的），非常热情的向我推荐另一名非常优秀的导师，并指出他还有名额。回复完了，他又将我的自荐信抄送了一份给他推荐的导师。这还没完，他又电话联系了我，催我赶紧与他推荐的导师联系！已经晚上 10 点了，我赶紧打开电脑，针对这位导师重新改写了模板中的部分内容，随后就发了出去。这简直是我人生的高光时刻之一，被别人赏识的感觉真特么爽！结果就是，大概凌晨 2 点才睡着。</p>
<p>一觉过去，削减了不少激动的心情。不能在一棵树上吊死，万一这名优秀的导师看不上我，我岂不是彻底凉透了？虽然已经步入端午假期，但是我还是开始了又一轮邮件轰炸。名额已满！招满了！请联系其他导师！大概是这几天，我看到的最多的回复。上面提到的仍有名额的导师仍未回复我，也许他在端午休息，并不会处理工作相关的事情。</p>
<p>26 号，终于又有一名导师看上我了！并且，最重要的是，他还有名额！卧槽，没想到最后我还能捡个漏！我立马回复，向导师咨询研究课题。他回复到，第二天通过视频简单交流一下。我以为第二天他还要考核一下我，没想到交流还是比较轻松愉快的。导师介绍了目前的研究方向，项目等信息。我也对此有点兴趣。于是一拍即合，定了，终于定了！</p>
<p>没想到，端午节的最后一天晚上，之前那名有名额的导师打电话来，似乎对我感兴趣。哎，没办法，我已经敲定另一名导师了，只好拒绝。人生最美的遗憾也许就是这样。</p>
<p>总的来说，我在投递自荐信阶段有些懈怠。自己本身有几张不错的牌，差点打得稀巴烂！还好，想要努力的时候什么时候都不会迟，运气可能就会在适当的时间到来。</p>
<p>努力吧，永远不要停下来啊（团长状）！</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/ath7s-kr3ys.jpg" alt="团长状"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>最近看了一些文章、视频和学长们的感受，研究生的三年似乎并不如想象的那么轻松愉快，还是十分紧张和紧凑的。不要有太多期待，也不要完全放弃幻想，一个平常心对待即可。</p>
<p>最后，祝愿正在准备考研的读者一战成硕，一研为定！</p>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="https://cosmosning.github.io/2020/03/02/yi-wen-cheng-xu-yuan-shi-ru-he-pai-ban-jian-li-de/">译文-程序员是如何排版简历的</a></p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>研究生</tag>
        <tag>自荐信</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim简易入门</title>
    <url>/2020/06/15/vim-jian-yi-ru-men/</url>
    <content><![CDATA[<blockquote>
<p>最近，笔者在学习 Linux 中的常见命令。其中 Vim 作为文本编辑命令，是十分基础又非常强大的工具。然而，许多开发者因其命令繁琐，上手难度大，并没有完全发挥出 Vim 的潜力。因此，本文将介绍 Vim 的常见命令及其用法，供读者参考。通过本文，你将获得：</p>
<ol>
<li>了解 Vim 的四种模式。</li>
<li>掌握 Vim 常见文本编辑命令。</li>
</ol>
</blockquote>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/kdwk-leung-nupZCrr61Fg-unsplash.jpg" alt="题图"></p>
<p>Photo by <a href="https://unsplash.com/@kdwk?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Kdwk Leung</a> on <a href="https://unsplash.com/t/nature?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
<h1 id="什么是-Vim？"><a href="#什么是-Vim？" class="headerlink" title="什么是 Vim？"></a>什么是 Vim？</h1><p>Vim 是 <strong>Vi</strong> I<strong>M</strong>proved 的缩写。它是由 Bram Moolenaar 开发的开源免费文本编辑器。顾名思义，Vim 基于 Vi（另一个早期的文本编辑器） 但又不止于 Vi。由于其强大的文本处理功能，在很多类 Unix 系统中，Vim 都成了默认的文本编辑器。尤其在无图形化界面的服务器上，Vim 成为了绝大部分运维人员线上运维的选择。</p>
<p>很多 Linux 发行版都内置了 Vim 命令，只需打开终端，输入如下命令，即可使用 Vim。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/vim.PNG" alt="Vim"></p>
<h1 id="Vim-的四种模式"><a href="#Vim-的四种模式" class="headerlink" title="Vim 的四种模式"></a>Vim 的四种模式</h1><p>Vim 中的四种模式是 Vim 的核心设计理念之一。以四种模式为基础，理解和使用 Vim 的文本编辑命令就会容易许多。</p>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>Vim 中有四种模式，分别是：</p>
<ul>
<li>正常模式（Normal Mode）：用于查看文本和执行复制、粘贴等文本操作命令。</li>
<li>插入模式（Insert Mode）：用于编辑文本。</li>
<li>命令模式（Command Mode）：用于执行指定命令。</li>
<li>可视模式（Visual Mode）：用于选中文本。</li>
</ul>
<h2 id="正常模式（Normal-Mode）"><a href="#正常模式（Normal-Mode）" class="headerlink" title="正常模式（Normal Mode）"></a>正常模式（Normal Mode）</h2><p>在 Vim 打开文件或者新建文件时，默认进入的模式是正常模式。在正常模式下，使用键盘直接输入字母或者数字，可能不会出现类似编辑文本时的结果。也就是说，该模式下，文本无法直接编辑。然而，通过某些特定的指令，可以完成一些常见的文本操作命令。</p>
<h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>光标的位置将决定复制、粘贴等操作的位置，因此光标的操作于文本操作十分重要。不同于当前拥有图形界面的文字处理软件，Vim 中无法使用鼠标指定光标位置，而是使用键盘指令，完成光标的移动。这一设计，使得 Vim 无需鼠标，即可完成文本编辑的任务。这大大提高了文本编辑的效率。</p>
<p>Vim 的光标移动又可以分为两类。分别是<strong>小范围移动</strong>、<strong>大范围移动</strong>。</p>
<p>在<strong>小范围移动</strong>中，只涉及到四个字母 <code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>，分别代表<strong>左、下、上、右</strong>（相当于键盘上的光标键）</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/cursorSD.png" alt="小范围移动光标"></p>
<div class="note info">
            <p>部分 Vim 版本支持<strong>光标键</strong>移动光标，但仍有部分 Vim 不支持（由于相关操作系统会将光标键解释为其他字符），推荐熟练掌握 <code>h</code>、<code>j</code>、<code>k</code>、<code>l</code> 指令，完成小范围移动光标的任务。</p>
          </div>

<p>在<strong>大范围移动</strong>中，可以通过 <code>g</code>、<code>G</code> 快速跳转到<strong>第一行</strong>和<strong>最后一行</strong>；在 <code>G</code> 前加上数字，就可以跳转到指定行；<code>^</code>、<code>$</code> 则可以跳转到光标所在行的行首和行尾。这些移动方式将会极大地提高光标移动效率。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/cursorLD.png" alt="大范围移动光标"></p>
<h3 id="常见文本操作"><a href="#常见文本操作" class="headerlink" title="常见文本操作"></a>常见文本操作</h3><p>在正常模式下，除了可以移动光标，也可以执行一些简单的文本操作命令。具体的如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">指令</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">复制</td>
<td align="center"><code>yy</code></td>
<td align="center">复制整行</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>&lt;数字&gt;yy</code></td>
<td align="center">复制当前光标所在行开始，连续&lt;数字&gt;行的文本</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>y$</code>（y +shift +4）</td>
<td align="center">复制从当前光标所在字符开始，到本行末尾的文本</td>
</tr>
<tr>
<td align="center">粘贴</td>
<td align="center"><code>p</code></td>
<td align="center">粘贴复制结果</td>
</tr>
<tr>
<td align="center">剪切</td>
<td align="center"><code>dd</code></td>
<td align="center">剪切整行</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>d$</code></td>
<td align="center">剪切从当前光标所在字符开始，到本行末尾的文本</td>
</tr>
<tr>
<td align="center">撤销</td>
<td align="center"><code>u</code></td>
<td align="center">撤销命令</td>
</tr>
<tr>
<td align="center">重做</td>
<td align="center"><code>ctrl + r</code></td>
<td align="center">重做命令</td>
</tr>
<tr>
<td align="center">删除单个字符</td>
<td align="center"><code>x</code></td>
<td align="center">将当前光标位置的字符删除</td>
</tr>
<tr>
<td align="center">替换单个字符</td>
<td align="center"><code>r+&lt;指定字符&gt;</code></td>
<td align="center">将当前光标位置的字符替换为指定字符</td>
</tr>
</tbody></table>
<h2 id="插入模式（Insert-Mode）"><a href="#插入模式（Insert-Mode）" class="headerlink" title="插入模式（Insert Mode）"></a>插入模式（Insert Mode）</h2><p>在正常模式中，用户无法直接编辑文本。而如果需要直接编辑文本，则需要进入插入模式。插入模式有多种进入方式。具体如下：</p>
<table>
<thead>
<tr>
<th align="center">进入命令</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">按 <code>i</code> 进入</td>
<td align="center">光标会在原位</td>
</tr>
<tr>
<td align="center">按 <code>I</code>（大写 i：shift + i）进入</td>
<td align="center">光标会在本行开头</td>
</tr>
<tr>
<td align="center">按 <code>a</code> 进入</td>
<td align="center">光标会在原位的下一位</td>
</tr>
<tr>
<td align="center">按 <code>A</code>（shift + a）进入</td>
<td align="center">光标会在本行最后一个字符的下一位</td>
</tr>
<tr>
<td align="center">按 <code>o</code> 进入</td>
<td align="center">光标会在当前行的下面另起一行</td>
</tr>
<tr>
<td align="center">按 <code>O</code> （shift + o）进入</td>
<td align="center">光标会在当前行的上面另起一行</td>
</tr>
</tbody></table>
<p>进入插入模式之后，就可以直接编辑文本了。编辑完成后，可以按 <code>ESC</code> 键返回正常模式。</p>
<h2 id="命令模式（Command-Mode）"><a href="#命令模式（Command-Mode）" class="headerlink" title="命令模式（Command Mode）"></a>命令模式（Command Mode）</h2><p>当处于正常模式时，按 <code>:</code> 键可进入命令模式。在命令模式下，可执行更多丰富的命令。这些命令大致可分为两类，一类命令用于设置 Vim 编辑器的属性，另一类则用来完成文件、文本操作任务。</p>
<h3 id="Vim-设置"><a href="#Vim-设置" class="headerlink" title="Vim 设置"></a>Vim 设置</h3><p>vim 设置的一般格式如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">: <span class="built_in">set</span> &lt;设置项&gt;</span><br></pre></td></tr></table></figure>

<p>如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">: <span class="built_in">set</span> nu</span><br></pre></td></tr></table></figure>

<p>可显示行号。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/setnu.PNG" alt="Vim 显示行号"></p>
<p>然而，上述设置方式仅对当前编辑文本进程有效，如需永久生效，则要修改 <code>/etc/vimrc</code> 文件。</p>
<h3 id="文件、文本操作"><a href="#文件、文本操作" class="headerlink" title="文件、文本操作"></a>文件、文本操作</h3><p>在命令模式下，Vim 可以执行一些文件操作命令，如保存、退出等；亦可执行更加复杂的文本操作命令，如查找、替换等。</p>
<table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">命令</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">保存</td>
<td align="center"><code>: w &lt;文件名&gt;</code></td>
<td align="center">保存新文件</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>: w</code></td>
<td align="center">表示保存到当前文件</td>
</tr>
<tr>
<td align="center">退出</td>
<td align="center"><code>: q</code></td>
<td align="center">退出 vim</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>: q !</code></td>
<td align="center">强制退出（默认不保存修改）</td>
</tr>
<tr>
<td align="center">执行其他命令</td>
<td align="center"><code>: ! &lt;命令&gt;</code></td>
<td align="center">执行 shell 命令</td>
</tr>
<tr>
<td align="center">查找操作</td>
<td align="center"><code>: /&lt;正则表达式&gt;</code></td>
<td align="center">按 <code>n</code> 查找下一个，<code>shift + n</code> 查找上一个</td>
</tr>
<tr>
<td align="center">替换操作</td>
<td align="center"><code>: s/&lt;旧字符或正则表达式&gt;/&lt;新字符或正则表达式&gt;</code></td>
<td align="center">针对当前光标所在行的字符进行替换</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>: %s/&lt;旧字符或正则表达式&gt;/&lt;新字符或正则表达式&gt;</code></td>
<td align="center">全文搜索替换一处</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>: %s/&lt;旧字符或正则表达式&gt;/&lt;新字符或正则表达式&gt;/g</code></td>
<td align="center">全文搜索、全部替换</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>: m,n s/&lt;旧字符或正则表达式&gt;/&lt;新字符或正则表达式&gt;/g</code></td>
<td align="center">指定行范围内替换，其中 m，n 为正整数</td>
</tr>
</tbody></table>
<h2 id="可视模式（Visual-Mode）"><a href="#可视模式（Visual-Mode）" class="headerlink" title="可视模式（Visual Mode）"></a>可视模式（Visual Mode）</h2><p>在复制等文本操作命令时，常常需要选中相关文本。这就需要进入 Vim 的可视模式。进入可视模式的方式比较常见的有 3 种，具体如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">进入命令</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">按 <code>v</code> 进入</td>
<td align="center">字符可视模式，按行序以<strong>单个字符</strong>为单位进行选中操作</td>
</tr>
<tr>
<td align="center">按 <code>V</code> 进入</td>
<td align="center">行可视模式，按行序以<strong>单行</strong>为单位进行选中操作</td>
</tr>
<tr>
<td align="center">按 <code>ctrl + v</code> 进入</td>
<td align="center">块可视模式，以光标所在位置为顶点，自定义矩形块中的字符全部选定</td>
</tr>
</tbody></table>
<p>按 <code>ESC</code> 键返回正常模式。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要介绍了 Vim 的四种模式和四种模式下的文本编辑及操作命令，希望对读者有所帮助。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/06/Vim-Four-Modes.png" alt="Vim 四种模式"></p>
<h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><p><a href="https://www.bilibili.com/video/BV1Yt411X7mu" target="_blank" rel="noopener">【视频·中文】vim入门教程（共3讲） by 正月点灯笼</a></p>
<p><a href="https://www.tutorialspoint.com/vim/vim_quick_guide.htm" target="_blank" rel="noopener">【文本·英文】Vim - Quick Guide from tutorialspoint</a></p>
]]></content>
      <categories>
        <category>指南</category>
      </categories>
      <tags>
        <tag>Vim</tag>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的浅拷贝和深拷贝</title>
    <url>/2020/05/18/c-zhong-de-qian-kao-bei-he-shen-kao-bei/</url>
    <content><![CDATA[<blockquote>
<p>（导读）短文一篇。主要介绍浅拷贝和深拷贝的含义以及在 C++ 中的实现</p>
</blockquote>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/05/cristian-lozan-lb5yppoIEWk-unsplash.jpg" alt="封面图片"></p>
<p>Photo by <a href="https://unsplash.com/@chrisslozan?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Cristian Lozan</a> on <a href="https://unsplash.com/t/nature?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>先来看一个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShallowCopyObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> basicType;</span><br><span class="line">	<span class="keyword">int</span> *refType;</span><br><span class="line">	ShallowCopyObject()</span><br><span class="line">	&#123;</span><br><span class="line">		basicType = <span class="number">10</span>;</span><br><span class="line">		refType = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			refType[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我定义了一个 <code>ShallowCopyObject</code> 类，它包括两个成员变量</p>
<ol>
<li><code>basicType</code> ：类型为语言内置基本类型的 <code>int</code></li>
<li><code>refType</code> ：类型为指针，指向 <code>int</code> 类型数据</li>
</ol>
<p>与此同时，我还定义了一个无参构造函数，用于初始化 <code>basicType</code> 和 <code>refType</code> 的值。其中 <code>basicType</code> 初始化为 10；<code>refType</code> 初始化为一个大小为 10 的数组，依次存储 0~9 的整数。</p>
<h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>假设主函数 <code>main</code> 中有如下语句，那么终端会输出什么呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ShallowCopyObject a;</span><br><span class="line">ShallowCopyObject b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Before changing value of b.basicType"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b.basicType "</span> &lt;&lt; b.basicType &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">b.basicType = <span class="number">233</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After changing value of b.basicType"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a.basicType "</span> &lt;&lt; a.basicType &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b.basicType "</span> &lt;&lt; b.basicType &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>先自己分析一下，再上机敲一敲，看看自己的思路对不对。</p>
<h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>类似的，下面的语句会输出什么呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ShallowCopyObject a;</span><br><span class="line">ShallowCopyObject b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Before changing value of b.refType[6]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b.refType[6] "</span> &lt;&lt; b.refType[<span class="number">6</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">b.refType[<span class="number">6</span>] = <span class="number">666</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After b.refType[6]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a.refType[6] "</span> &lt;&lt; a.refType[<span class="number">6</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b.refType[6] "</span> &lt;&lt; b.refType[<span class="number">6</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>再试着自己分析一下，上机敲一敲，看看自己的思路对不对。</p>
<h1 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ShallowCopyObject a;</span><br><span class="line">ShallowCopyObject b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Before changing value of b.basicType"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b.basicType "</span> &lt;&lt; b.basicType &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">b.basicType = <span class="number">233</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After changing value of b.basicType"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a.basicType "</span> &lt;&lt; a.basicType &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b.basicType "</span> &lt;&lt; b.basicType &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>第一个问题，也就是上面的代码，会输出如下结果</p>
<div class="note default">
            <p>Before changing value of b.basicType<br>b.basicType 10<br>After changing value of b.basicType<br>a.basicType 10<br>b.basicType 233</p>
          </div>

<p>由此可见，<strong>两个对象基本数据类型的成员变量是相互独立的，不会相互影响</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ShallowCopyObject a;</span><br><span class="line">ShallowCopyObject b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Before changing value of b.refType[6]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b.refType[6] "</span> &lt;&lt; b.refType[<span class="number">6</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">b.refType[<span class="number">6</span>] = <span class="number">666</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After b.refType[6]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a.refType[6] "</span> &lt;&lt; a.refType[<span class="number">6</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b.refType[6] "</span> &lt;&lt; b.refType[<span class="number">6</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>而第二个问题，它的结果可能出乎意料：</p>
<div class="note default">
            <p>Before changing value of b.refType[6]<br>b.refType[6] 6<br>After b.refType[6]<br>a.refType[6] 666<br>b.refType[6] 666</p>
          </div>

<p>我们惊奇的发现，对 <code>b</code> 对象的成员变量修改，竟然影响到了 <code>a</code> 对象中的值！</p>
<p>这一切的原因，都是由于在C++ 中，默认对象之间的拷贝（包括默认复制构造函数和默认赋值语句）是浅拷贝。</p>
<h1 id="什么是浅拷贝？"><a href="#什么是浅拷贝？" class="headerlink" title="什么是浅拷贝？"></a>什么是浅拷贝？</h1><p>那么，什么是浅拷贝呢？</p>
<p>这里给出维基百科的定义：</p>
<blockquote>
<p>One method of copying an object is the shallow copy. In that case a new object B is created, and the fields values of A are copied over to B. This is also known as a field-by-field copy, field-for-field copy, or field copy. If the field value is a reference to an object (e.g., a memory address) it copies the reference, hence referring to the same object as A does, and if the field value is a primitive type it copies the value of the primitive type. In languages without primitive types (where everything is an object), all fields of the copy B are references to the same objects as the fields of original A. The referenced objects are thus shared, so if one of these objects is modified (from A or B), the change is visible in the other. Shallow copies are simple and typically cheap, as they can be usually implemented by simply copying the bits exactly.</p>
<p>(<a href="https://en.wikipedia.org/wiki/Object_copying#Shallow_copy" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Object_copying#Shallow_copy</a>)</p>
</blockquote>
<p>简单的来说，浅拷贝就是逐个字节的拷贝。也就是说，拷贝后每一个成员变量的值都相同。如果该值是基本数据类型，那么该值被拷贝；如果该值是引用数据类型（如对象、指针等），那么该值（注意：这里的值是指<strong>地址</strong>）也会被拷贝。</p>
<p>由此可知，针对第一个问题，由于改变的是基本类型的数据，它是独立的一份拷贝，因而另一个对象值的修改并不会影响被拷贝的对象；然而，在第二个问题中，由于浅拷贝，<code>b</code> 中 <code>refType</code> 指向了和 <code>a</code> 对象 <code>refType</code> 相同的位置（因为拷贝了地址），因而在 <code>b</code> 中修改 <code>refType</code> 数组中的值，会影响到对象 <code>a</code> 。</p>
<div class="note info">
            <h2 id="一句话描述"><a href="#一句话描述" class="headerlink" title="一句话描述"></a>一句话描述</h2><p><strong>浅拷贝会共享引用数据类型成员变量（指针指向同一个地址），而不共享原始数据类型的成员变量</strong></p>
          </div>

<h1 id="什么是深拷贝？"><a href="#什么是深拷贝？" class="headerlink" title="什么是深拷贝？"></a>什么是深拷贝？</h1><p>有时候，我们并不希望拷贝对象时，其引用成员变量指向同一个引用数据类型的数据对象，而希望它们指向不同的位置，但是这些位置存储的值是相同的。这就需要用到深拷贝。</p>
<p>在维基百科中，深拷贝是这样定义的：</p>
<blockquote>
<p>An alternative is a deep copy, meaning that fields are dereferenced: rather than references to objects being copied, new copy objects are created for any referenced objects, and references to these placed in B. The result is different from the result a shallow copy gives in that the objects referenced by the copy B are distinct from those referenced by A, and independent. Deep copies are more expensive, due to needing to create additional objects, and can be substantially more complicated, due to references possibly forming a complicated graph.</p>
<p>(<a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Object_copying#Deep_copy</a>)</p>
</blockquote>
<div class="note info">
            <h2 id="一句话描述"><a href="#一句话描述" class="headerlink" title="一句话描述"></a>一句话描述</h2><p><strong>深拷贝不会共享引用数据类型成员变量（它们的指针指向不同地址，但是拷贝后指针指向地址所存储的值是相等的），也不共享原始数据类型的成员变量</strong></p>
          </div>

<h2 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h2><p>在 C++ 中可以自定义复制构造函数、重载赋值运算符，实现深拷贝。对于本文开头提出的问题，可以做如下改进。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义复制构造函数</span></span><br><span class="line">DeepCopyObject(<span class="keyword">const</span> DeepCopyObject &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    basicType = obj.basicType;</span><br><span class="line">    refType = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];        <span class="comment">// 引用类型成员变量重新申请空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)  <span class="comment">// 将值逐个拷贝到新申请的空间中</span></span><br><span class="line">    &#123;</span><br><span class="line">        refType[i] = obj.refType[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重载赋值运算符</span></span><br><span class="line">DeepCopyObject &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> DeepCopyObject &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    basicType = obj.basicType;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;obj) <span class="comment">// obj = obj; 情况</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] refType;</span><br><span class="line">    refType = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        refType[i] = obj.refType[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>浅拷贝会<strong>共享</strong>引用数据类型成员变量（指针指向<strong>同一个地址</strong>），而<strong>不共享</strong>原始数据类型的成员变量</li>
<li>深拷贝<strong>不会共享</strong>引用数据类型成员变量（它们的指针指向<strong>不同</strong>地址，但是拷贝后指针指向地址所存储的<strong>值是相等的</strong>），也<strong>不共享</strong>原始数据类型的成员变量</li>
<li>在 C++ 中可以<strong>自定义复制构造函数</strong>、<strong>重载赋值运算符</strong>，<strong>实现深拷贝</strong></li>
</ul>
<h1 id="附：实现深拷贝完整代码"><a href="#附：实现深拷贝完整代码" class="headerlink" title="附：实现深拷贝完整代码"></a>附：实现深拷贝完整代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepCopyObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> basicType;</span><br><span class="line">	<span class="keyword">int</span> *refType;</span><br><span class="line"></span><br><span class="line">	DeepCopyObject()</span><br><span class="line">	&#123;</span><br><span class="line">		basicType = <span class="number">10</span>;</span><br><span class="line">		refType = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			refType[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DeepCopyObject(<span class="keyword">const</span> DeepCopyObject &amp;obj)</span><br><span class="line">	&#123;</span><br><span class="line">		basicType = obj.basicType;</span><br><span class="line">		refType = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			refType[i] = obj.refType[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~DeepCopyObject()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (refType)</span><br><span class="line">			<span class="keyword">delete</span>[] refType;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DeepCopyObject &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> DeepCopyObject &amp;obj)</span><br><span class="line">	&#123;</span><br><span class="line">		basicType = obj.basicType;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;obj) <span class="comment">// obj = obj; 情况</span></span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">delete</span>[] refType;</span><br><span class="line">		refType = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			refType[i] = obj.refType[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	DeepCopyObject a;</span><br><span class="line">	DeepCopyObject b = a; <span class="comment">// 调用 DeepCopyObject(const DeepCopyObject &amp; obj)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// b = a; // 调用 DeepCopyObject &amp; operator=(const DeepCopyObject &amp; obj)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Before changing value of b.basicType"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"b.basicType "</span> &lt;&lt; b.basicType &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	b.basicType = <span class="number">233</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"After changing value of b.basicType"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a.basicType "</span> &lt;&lt; a.basicType &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"b.basicType "</span> &lt;&lt; b.basicType &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Before changing value of b.refType[6]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"b.refType[6] "</span> &lt;&lt; b.refType[<span class="number">6</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	b.refType[<span class="number">6</span>] = <span class="number">666</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"After b.refType[6]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a.refType[6] "</span> &lt;&lt; a.refType[<span class="number">6</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"b.refType[6] "</span> &lt;&lt; b.refType[<span class="number">6</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>浅拷贝</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo搭建并部署个人博客</title>
    <url>/2020/03/12/shi-yong-hexo-da-jian-bing-bu-shu-ge-ren-bo-ke/</url>
    <content><![CDATA[<blockquote>
<p>前段时间，看到 Hexo 官方文档更新了使用 TravisCI 自动化部署部分。趁着这个机会，我将我的博客重新构建了一遍。这里记下简略过程，供读者参考。通过本篇文章，你将获得：</p>
<ol>
<li>使用 Hexo 构建静态博客</li>
<li>简单配置 NexT 主题</li>
<li>使用 TravisCI + GitHubPages 完成自动化部署</li>
</ol>
</blockquote>
<h1 id="前置需求"><a href="#前置需求" class="headerlink" title="前置需求"></a>前置需求</h1><p>在安装 Hexo 之前，你必须保证你的机器上安装了<strong>Node.js</strong>及<strong>Git</strong>。如果你未安装，你需要到如下网址，下载安装。</p>
<ul>
<li>Node.js：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></li>
<li>Git：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></li>
</ul>
<p>然后，你可以在命令行中输入如下命令，完成 <strong>Hexo</strong> 的安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span></span><br></pre></td></tr></table></figure>

<p>此外，为了部署在 Github 上，你需要有一个 <strong>GitHub 账号</strong>。如果没有，你可以到<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>注册一个。</p>
<h1 id="Hexo-最小配置"><a href="#Hexo-最小配置" class="headerlink" title="Hexo 最小配置"></a>Hexo 最小配置</h1><p>打开命令行（Windows 上可以使用 <strong>Git Bash</strong> 或者 <strong>PowerShell</strong>），输入如下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>

<p>等待片刻，<strong>Hexo</strong> 会帮我们做初始化网站的工作。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/hexo-init-blog.PNG" alt="Hexo初始化"></p>
<p>为方便后面部署，我们在 <code>blog</code> 中初始化一个 git 仓库，并配置好 git 相关信息。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 blog 文件夹</span></span><br><span class="line">cd blog</span><br><span class="line"><span class="comment"># 初始化 Git 仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 查看 Git 状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 配置个人信息（与你注册 GitHub 的用户名、邮箱一致）</span></span><br><span class="line">git config -<span class="literal">-local</span> user.name &lt;你的用户名&gt;</span><br><span class="line">git config -<span class="literal">-local</span> user.email &lt;你的邮箱名&gt;</span><br><span class="line"><span class="comment"># 查看配置，user.name、user.email 是否配置成功</span></span><br><span class="line">git config -<span class="literal">-local</span> -<span class="literal">-list</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/git-init-and-config.PNG" alt="初始化Git仓库"></p>
<p>接着，将仓库里的已有改动添加、提交。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">"init with hexo-cli"</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/git-add-and-commit.PNG" alt="Git提交改动"></p>
<p>在 blog 根目录，使用任意文本编辑器打开 <code>_config.yml</code> 文件，并在 <code>#Site</code> 部分输入你网站的信息。一个示例如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">CosmosNing的个人博客</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">探索·好奇</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">编程·学习·生活</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">个人博客;编程;学习;生活</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">CosmosNing</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<p>到现在， Hexo 最小配置已经完成。我们来看看效果如何。继续在命令行下输入如下命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果使用 PowerShell，则选择输入下一条命令（下同）</span></span><br><span class="line">hexo g; hexo s</span><br><span class="line"><span class="comment"># 如果使用 Git Bash 或者 Linux 终端，则选择输入下一条命令（下同）</span></span><br><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/hexo-g-and-hexo-s.PNG" alt="Hexo本地预览命令"></p>
<p>打开浏览器，访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p>
<p>你应该能得到类似这个画面</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/basic-result.PNG" alt="Hexo最小化配置效果"></p>
<div class="note info">
            <h2 id="提示-终止预览"><a href="#提示-终止预览" class="headerlink" title="提示-终止预览"></a>提示-终止预览</h2><p>你可以在命令行中，按下 <code>Ctrl + C</code> 终止上述预览命令</p>
          </div>

<h1 id="设置-NexT-主题"><a href="#设置-NexT-主题" class="headerlink" title="设置 NexT 主题"></a>设置 NexT 主题</h1><p>默认的主题不太美观，而且功能有限。下面，我将介绍目前 <strong>Hexo</strong> 中最受欢迎的主题——NexT 的安装与配置。</p>
<h2 id="最小配置"><a href="#最小配置" class="headerlink" title="最小配置"></a>最小配置</h2><p>首先，在命令行中输入如下命令，安装 <strong>NexT</strong> 主题</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme<span class="literal">-next</span>/hexo<span class="literal">-theme</span><span class="literal">-next</span> themes/next</span><br></pre></td></tr></table></figure>

<p>使用文本编辑器，打开项目根目录的 <code>_config.yml</code> 文件，将 <code>theme</code> 配置成 <code>next</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>至此，<strong>NexT</strong> 最小配置已经完成。我们来看看效果吧</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo clean; hexo g; hexo s</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/next-hexo-g.PNG" alt="Hexo本地预览"></p>
<p>打开浏览器，访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p>
<p>你应该能得到类似这个画面</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/next-basic-result.PNG" alt="next最小配置效果"></p>
<p>使用 <code>Ctrl + C</code> 终止上述命令。接下来，我们将这一阶段的改动提交到 Git 仓库。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 NexT 主题作为子模块加入仓库</span></span><br><span class="line">git submodule add https://github.com/theme<span class="literal">-next</span>/hexo<span class="literal">-theme</span><span class="literal">-next</span> themes/next</span><br><span class="line"><span class="comment"># 添加改动至暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">"add common site config with theme next(default config)"</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/git-commit-next-default.PNG" alt="NexT最小化配置提交"></p>
<h2 id="配置功能页面及资源文件"><a href="#配置功能页面及资源文件" class="headerlink" title="配置功能页面及资源文件"></a>配置功能页面及资源文件</h2><p>一个完整的博客应该包括 <code>主页</code> 、<code>分类</code>、<code>标签</code>、 <code>归档</code> 等功能页面。而在 <strong>Hexo</strong> 帮我们初始化时，只是完成了博文页的设置。其他功能页需要手动设置。具体步骤如下</p>
<ul>
<li>创建 <code>关于</code> 页</li>
</ul>
<p>在项目根目录下的 <code>source</code> 文件夹中，创建一个 <code>about</code> 文件夹。在 <code>about</code> 文件夹下，创建 <code>index.md</code> ，并在 <code>index.md</code> 中输入如下文字：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 关于我</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">在这里输入你的个人介绍</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建 <code>分类</code> 页</li>
</ul>
<p>在项目根目录下的 <code>source</code> 文件夹中，创建一个 <code>categories</code> 文件夹。在 <code>categories</code> 文件夹下，创建 <code>index.md</code> ，并在 <code>index.md</code> 中输入如下文字：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">type: "categories"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 <code>标签云</code> 页</li>
</ul>
<p>在项目根目录下的 <code>source</code> 文件夹中，创建一个 <code>tags</code> 文件夹。在 <code>tags</code> 文件夹下，创建 <code>index.md</code> ，并在 <code>index.md</code> 中输入如下文字：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签云</span><br><span class="line">type: "tags"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>至此，你可以在 <code>_config.yml</code> 配置使用这些页面</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加主题配置</span></span><br><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">    <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">    <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure>

<p>另外，你可以将博客中常用的图片（如 logo 、头像等）内置在博客站点中。你需要在项目根目录下的 <code>source</code> 文件夹中，创建 <code>images</code> 文件夹。然后将图片文件拷贝到这里即可。这样，你在 <code>_config.yml</code> 中可以通过 <code>/images/&lt;图片名&gt;</code> 来引用。</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p><strong>Hexo</strong> 开放的设计使得开发者可以通过插件的方式增强其能力。为了使得我们的博客功能更加完善，这里我们需要安装一些有用的插件。</p>
<ul>
<li><a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a></li>
</ul>
<p><code>hexo-generator-feed</code> 是一个 RSS Feed 生成器，通过它可以为我们的博客生成可用于 RSS 订阅的文件。默认配置下，它会在你的站点根目录生成 <code>atom.xml</code> 。</p>
<p>你可以输入如下命令安装插件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator</span><span class="literal">-feed</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<p>然后，在 <code>_config.yml</code> 中配置使用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">140</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">' '</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="comment"># 这个是自定义的 icon</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">/images/avatar-32.ico</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://github.com/theme-next/hexo-generator-searchdb" target="_blank" rel="noopener">hexo-generator-searchdb</a></li>
</ul>
<p><code>hexo-generator-searchdb</code>是一个本地搜索索引生成器，通过它可以为我们的博客生成可用于本地搜索的文件。默认配置下，它会在你的站点根目录生成 <code>search.xml</code> 。你不需要额外书写搜索算法，因为强大的 <code>NexT</code> 主题已经内置了搜索功能。</p>
<p>你可以输入如下命令安装插件：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator</span><span class="literal">-searchdb</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<p>然后，在 <code>_config.yml</code> 中配置使用：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="comment"># 注意需要将下列配置增加在 theme_config 中，并保持相对缩进</span></span><br><span class="line">  <span class="attr">local_search:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">    <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">    <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">    <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">    <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">    <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">    <span class="attr">preload:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a></li>
</ul>
<p><code>hexo-permalink-pinyin</code>是一个中文链接转拼音的工具，使用它有助于搜索引擎的抓取我们的博客页面（当然，如果你部署在 GitHub 上，百度无法抓取，因为 GitHub 禁止百度对此类页面的抓取）。</p>
<p>你可以输入如下命令安装插件：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm i hexo<span class="literal">-permalink</span><span class="literal">-pinyin</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<p>然后，在 <code>_config.yml</code> 中配置使用：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink_pinyin:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">separator:</span> <span class="string">'-'</span> <span class="comment"># default: '-'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">hexo-symbols-count-time</a></li>
</ul>
<p><code>hexo-symbols-count-time</code>是一个统计文章字数、估计阅读时间的工具，使用它有助于读者提高阅读效率。</p>
<p>你可以输入如下命令安装插件：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-symbols</span><span class="literal">-count</span><span class="literal">-time</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<p>然后，在 <code>_config.yml</code> 中配置使用：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="comment"># 注意需要将下列配置增加在 theme_config 中，并保持相对缩进</span></span><br><span class="line">  <span class="attr">symbols_count_time:</span></span><br><span class="line">    <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">exclude_codeblock:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">awl:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">wpm:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="noopener">hexo-generator-sitemap</a></li>
</ul>
<p><code>hexo-generator-sitemap</code>是一个生成网站 <code>sitemap</code> 工具，你可以主动将生成的 <code>sitemap.xml</code> 提交给搜索引擎，这样搜索引擎就可以更好的抓取你的博文。</p>
<p>你可以输入如下命令安装插件：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator</span><span class="literal">-sitemap</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<p>然后，在 <code>_config.yml</code> 中配置使用：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line">    <span class="attr">rel:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>至此，插件部分已配置完成。</p>
<div class="note info">
            <h2 id="提示-更多配置"><a href="#提示-更多配置" class="headerlink" title="提示-更多配置"></a>提示-更多配置</h2><p>更多 NexT 主题的配置，可以查看 <code>themes/next/_config.yml</code>，将你需要改动的配置拷贝到根目录下 <code>_config.yml</code> 中的 <code>theme_config</code> 结点下。（<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/DATA-FILES.md#选择-1hexo-方式" target="_blank" rel="noopener">参考</a>）</p><p>如果你懒得自定义，可以参考我的<a href="https://github.com/CosmosNing/CosmosNing.github.io/blob/source/_config.yml" target="_blank" rel="noopener">主题配置</a></p>
          </div>

<p>我们来看看效果如何。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo clean; hexo g; hexo s</span><br></pre></td></tr></table></figure>

<p>打开浏览器，访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p>
<p>我得到了以下画面</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/my-result.PNG" alt="效果预览"></p>
<h2 id="定制主题颜色及简单样式"><a href="#定制主题颜色及简单样式" class="headerlink" title="定制主题颜色及简单样式"></a>定制主题颜色及简单样式</h2><p>NexT 主题非常灵活，用户可以高度自定义，包括颜色，布局等。本节将浅显的介绍如何自定义主题的颜色及样式。</p>
<div class="note default">
            <p>推荐你使用 <code>Chrome</code> 浏览器作为调试工具</p>
          </div>

<p>首先，在根目录的 <code>source</code> 文件夹下创建 <code>_data</code> 文件夹。在 <code>_data</code> 文件夹下，创建 <code>styles.styl</code> 文件。</p>
<p>然后，配置根目录下 <code>_config.yml</code> ，以确保生成器将使用你自定义的样式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="comment"># 注意需要将下列配置增加在 theme_config 中，并保持相对缩进</span></span><br><span class="line">  <span class="attr">custom_file_path:</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们就可以使用 <code>Chrome</code> 浏览器对主题的样式进行微调。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地预览命令</span></span><br><span class="line">hexo clean; hexo g; hexo s</span><br></pre></td></tr></table></figure>

<p>打开浏览器，访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p>
<p>按下 <code>F12</code> 打开<code>Chrome</code> 浏览器开发者工具。并点选左上角红框所示的按钮。这样，你就可以使用鼠标快速找到网页中某块元素的样式。然后修改右半部分（如蓝框所示） <code>Styles</code> 的样式，并观察网页效果。如果合适，将对应的样式类，复制到上述创建的 <code>styles.styl</code> 文件中，并保存。下次预览生成，你就会得到定制化的主题样式。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/ChromeDevTools.PNG" alt="ChromeDevTools"></p>
<div class="note default">
            <p>点<a href="https://github.com/CosmosNing/CosmosNing.github.io/blob/source/source/_data/styles.styl" target="_blank" rel="noopener">这里</a>，查看我的样式配置。</p>
          </div>

<p>至此，我们的主题配置已经完成。下面，将改动提交至仓库</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">"&lt;你的提交信息&gt;"</span></span><br></pre></td></tr></table></figure>

<h1 id="使用-TravisCI-GitHubPages-实现自动化部署"><a href="#使用-TravisCI-GitHubPages-实现自动化部署" class="headerlink" title="使用 TravisCI + GitHubPages 实现自动化部署"></a>使用 TravisCI + GitHubPages 实现自动化部署</h1><h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><p>由于 Github Pages 目前只是支持 master 分支的页面渲染，所以我们需要提前做一些准备工作。打开命令行，输入如下命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于最新提交，创建名为 source 的分支</span></span><br><span class="line">git branch source</span><br><span class="line"><span class="comment"># 切换到 source 分支</span></span><br><span class="line">git checkout source</span><br><span class="line"><span class="comment"># 删除 master ，供静态页面的部署</span></span><br><span class="line">git branch <span class="literal">-d</span> master</span><br></pre></td></tr></table></figure>

<h2 id="创建-GithubPages-仓库"><a href="#创建-GithubPages-仓库" class="headerlink" title="创建 GithubPages 仓库"></a>创建 GithubPages 仓库</h2><p>登录你的 GitHub 账号，在主页的左侧，点击 <code>New</code> ，新建一个 GithubPages 仓库。你应该将其命名为 <code>&lt;你的 GitHub 用户名&gt;.github.io</code>，并点击 <code>Create repository</code> 完成创建。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/new-repo.png" alt="创建仓库"></p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/new-repo-info.PNG" alt="填写仓库信息"></p>
<p>接下来，需要将本地的博客仓库，推送到 GitHub。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:&lt;你的用户名&gt;/&lt;你的用户名&gt;.github.io.git</span><br><span class="line">git push <span class="literal">-u</span> origin source</span><br></pre></td></tr></table></figure>

<h2 id="创建-Personal-Access-Token"><a href="#创建-Personal-Access-Token" class="headerlink" title="创建 Personal Access Token"></a>创建 Personal Access Token</h2><p>在浏览器新建一个标签页，前往 GitHub <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">新建 Personal Access Token</a>，只勾选 <code>repo</code> 的权限并生成一个新的 Token。Token 生成后请<strong>复制并保存好</strong>（因为只会出现一次，刷新页面就再也看不见了）。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/token.PNG" alt="token"></p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/token-info.PNG" alt="token-info"></p>
<h2 id="安装及配置-TravisCI"><a href="#安装及配置-TravisCI" class="headerlink" title="安装及配置 TravisCI"></a>安装及配置 TravisCI</h2><p>在你的 GitHub 主页，点击上方菜单栏中的 <code>Marketplace</code>。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/travis01.png" alt="Travis-01"></p>
<p>在搜索框中，搜索 <code>travis</code></p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/travis02.PNG" alt="Travis-02"></p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/travis03.PNG" alt="Travis-03"></p>
<p>点选第一个 <code>Travis CI</code> ，并滑动到最后，选择 <code>Open Source</code>，再点击 <code>Install it for free</code>。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/travis04.PNG" alt="Travis-04"></p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/travis05.PNG" alt="Travis-05"></p>
<p>继续点 <code>绿色</code> 按钮。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/travis06.PNG" alt="Travis-06"></p>
<p><code>Install</code> !</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/travis07.PNG" alt="Travis-07"></p>
<p>现在我们可以在 <code>Travis CI</code> 官网上，登录并设置它了。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/travis08.PNG" alt="Travis-08"></p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/travis09.PNG" alt="Travis-09"></p>
<p>点击你的博客仓库，新建一个环境变量。<strong>Name</strong> 为 <code>GH_TOKEN</code>，<strong>Value</strong> 为刚才你在 GitHub 生成的 Token。确保 <strong>DISPLAY VALUE IN BUILD LOG</strong> 保持 <strong>不被勾选</strong> 避免你的 Token 泄漏。点击 <strong>Add</strong> 保存</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/travis10.PNG" alt="Travis-10"></p>
<p>在你的 Hexo 站点文件夹中新建一个 <code>.travis.yml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10</span> <span class="comment"># use nodejs v10 LTS</span></span><br><span class="line"><span class="attr">cache:</span> <span class="string">npm</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source</span> <span class="comment"># build source branch only</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="comment"># generate static files</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github-token:</span> <span class="string">$GH_TOKEN</span></span><br><span class="line">  <span class="attr">keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">target_branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">source</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure>

<p>最后，将改动提交，并推送到 GitHub 上:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">"你的提交信息"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>你的工作至此完成，可以泡杯咖啡，等待 <code>Travis CI</code> 运行结果（在你的 GitHub 博客仓库主页可以查看，如下图。如果是绿色的 ✅，那么成功；❎ 则代表失败）。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/build-status.PNG" alt="build-status"></p>
<h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><p>接下来你就可以自由的写博客啦。这里为你总结一些常用命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建博文</span></span><br><span class="line">hexo new &lt;标题名&gt;</span><br><span class="line"><span class="comment"># 本地预览</span></span><br><span class="line">hexo clean; hexo g; hexo s</span><br><span class="line"><span class="comment"># Git 推送</span></span><br><span class="line">git add .</span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">"你的提交信息"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a></p>
]]></content>
      <categories>
        <category>指南</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Hexo</tag>
        <tag>GitHubPages</tag>
        <tag>TravisCI</tag>
      </tags>
  </entry>
  <entry>
    <title>译文-程序员是如何排版简历的</title>
    <url>/2020/03/02/yi-wen-cheng-xu-yuan-shi-ru-he-pai-ban-jian-li-de/</url>
    <content><![CDATA[<blockquote>
<p>（译者按）又是一年招聘季，找工作的第一步便是要制作自己的简历。一份排版精美、可读性高的简历十分重要。那么，该如何高效的排版自己的简历？读者可以尝试一下本文示例的 CSS Grid 布局。</p>
<p>原标题：New Year, New Job? Let’s Make a Grid-Powered Resume!</p>
<p>作者：Ali Churcher</p>
<p>原文链接：<a href="https://css-tricks.com/new-year-new-job-lets-make-a-grid-powered-resume/" target="_blank" rel="noopener">https://css-tricks.com/new-year-new-job-lets-make-a-grid-powered-resume/</a></p>
</blockquote>
<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>许多受欢迎的简历都利用网格形状组织自己的简历的不同部分，以充分利用有限的页面空间。下面，请与我一起，使用 CSS 中的网格（Grid），创建一个无论是在打印情况下、还是在不同屏幕尺寸下浏览都看上去很棒的布局吧！这样，我们可以在线和离线使用简历，还可能在新的一年中派上用场！</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/resume_preview.png" alt="简历效果预览"></p>
<p>首先，我们创建一个简历的容器和简历子部分。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"resume"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"photo"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"about"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"work"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"community"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"skills"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要开始使用 CSS 中的网格，我们向 <code>resume</code> 样式类中添加 <code>display: grid</code> 。然后，我们得规定，容器内的元素如何在网格中放置。在这个示例中，我们将容器划分为 4 行 2 列。</p>
<p>与此同时，我们使用 CSS 网格中规定网格大小的单位 <code>fr</code> 来明确各个网格的比例大小关系。我们将每行等分（也就是每一行的大小都是 <code>1fr</code>），并设置第一列是第二列的两倍 （ <code>2fr</code> ）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.resume</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/resume-01-1.jpg" alt="简历容器布局示意图"></p>
<p>接下来，我们将使用 <code>grid-template-areas</code> 属性来描述元素在网格中摆放的位置。首先，我们需要为每一个简历子部分的 <code>grid-area</code> 指定一个名字。你可以使用任何名字，但是在这里，我们采用与简历子部分相同的名字：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.name</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.photo</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: photo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在，我们到了最有趣的部分。在样式类 <code>resume</code> 中的 <code>grid-template-areas</code> 属性中按你的需求放置上述定义好的 <code>grid-area</code> 的名字。例如，我们在 <code>grid-template-areas</code> 的左上角添加了 <code>name</code> ，这意味着我们将我们的名字放在了简历的左上角。我们的 <code>work</code> 部分有很多内容，因此我们将其添加了两次，使得它能够占据两个网格单元。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.resume</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>:</span><br><span class="line">        <span class="string">"name photo"</span></span><br><span class="line">        <span class="string">"work about"</span></span><br><span class="line">        <span class="string">"work education"</span></span><br><span class="line">        <span class="string">"community skills"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我们目前完成的成果：</p>
<iframe name="cp_embed_1" src="https://codepen.io/alichur/embed/xxbKdKZ?height=367&amp;theme-id=1&amp;default-tab=result&amp;user=alichur&amp;slug-hash=xxbKdKZ&amp;pen-title=grid%20resume%20%20lines&amp;name=cp_embed_1" scrolling="no" frameborder="0" height="367" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="grid resume  lines" class="cp_embed_iframe " style="width: 100%; overflow: hidden; display: block;" id="cp_embed_xxbKdKZ"></iframe>

<h1 id="调整布局"><a href="#调整布局" class="headerlink" title="调整布局"></a>调整布局</h1><p>属性<code>grid-template-areas</code> 使你能够轻松改变你的布局。比如，如果你认为，和教育（<code>education</code>）相比，雇主对你的技能（<code>skills</code>）更感兴趣，你仅仅只需要在 <code>grid-template-areas</code> 中调换它们的位置即可（也就意味着，它们在显示时，也会调换位置），而不需要做其他任何改动。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.resume</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>:</span><br><span class="line">    <span class="string">"name photo"</span></span><br><span class="line">    <span class="string">"work about"</span></span><br><span class="line">    <span class="string">"work skills"</span></span><br><span class="line">    <span class="string">"community education"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/resume-02.jpg" alt="调整布局示例"></p>
<iframe name="cp_embed_2" src="https://codepen.io/alichur/embed/bGNGGNP?height=367&amp;theme-id=1&amp;default-tab=result&amp;user=alichur&amp;slug-hash=bGNGGNP&amp;pen-title=grid%20resume%20%20swapping%20sections&amp;name=cp_embed_2" scrolling="no" frameborder="0" height="367" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="grid resume  swapping sections" class="cp_embed_iframe " style="width: 100%; overflow: hidden; display: block;" id="cp_embed_bGNGGNP"></iframe>
只需很小的 CSS 代码改动，我们就可以获得较窄一列靠左的简历布局。那就是网格布局的优势之一，即我们可以通过重新排列已经命名的 `grid-area` 来移动子块，而保证其他源代码保持其原有位置。

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.resume</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>:</span><br><span class="line">    <span class="string">"photo education"</span></span><br><span class="line">    <span class="string">"name work"</span></span><br><span class="line">    <span class="string">"about work"</span></span><br><span class="line">    <span class="string">"skills community"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/resume-03-1.jpg" alt="窄列靠左示例"></p>
<iframe name="cp_embed_3" src="https://codepen.io/alichur/embed/XWJrRjb?height=367&amp;theme-id=default&amp;default-tab=result&amp;user=alichur&amp;slug-hash=XWJrRjb&amp;pen-title=grid%20resume%20%20left%20design&amp;name=cp_embed_3" scrolling="no" frameborder="0" height="367" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="grid resume  left design" class="cp_embed_iframe " style="width: 100%; overflow: hidden; display: block;" id="cp_embed_XWJrRjb"></iframe>

<h1 id="划分更多列"><a href="#划分更多列" class="headerlink" title="划分更多列"></a>划分更多列</h1><p>也许你想在简历中添加个人参考。我们可以向网格模板中增添第三列，并把它放在最底部一行。要注意的是，我们也需要等比例的改变列的大小，然后更新模板区域。这样会使得某些元素占据了两列，但是这保持整体布局的正确。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.resume</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>:</span><br><span class="line">    <span class="string">"name name photo"</span></span><br><span class="line">    <span class="string">"work work about"</span></span><br><span class="line">    <span class="string">"work work education"</span></span><br><span class="line">    <span class="string">"community references skills"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/resume-04-1.jpg" alt="划分列示例"></p>
<iframe name="cp_embed_4" src="https://codepen.io/alichur/embed/gObYWvd?height=367&amp;theme-id=default&amp;default-tab=result&amp;user=alichur&amp;slug-hash=gObYWvd&amp;pen-title=grid%20resume%20%20split%20columns&amp;name=cp_embed_4" scrolling="no" frameborder="0" height="367" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="grid resume  split columns" class="cp_embed_iframe " style="width: 100%; overflow: hidden; display: block;" id="cp_embed_gObYWvd"></iframe>

<h1 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h1><p>对于小屏幕，比如移动设备，我们可以在单列展示简历。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.resume</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>:</span><br><span class="line">      <span class="string">"photo"</span></span><br><span class="line">      <span class="string">"name"</span></span><br><span class="line">      <span class="string">"about"</span></span><br><span class="line">      <span class="string">"work"</span></span><br><span class="line">      <span class="string">"education"</span></span><br><span class="line">      <span class="string">"skills"</span></span><br><span class="line">      <span class="string">"community"</span></span><br><span class="line">      <span class="string">"references"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们可以采用媒介查询（media query），当遇到更宽的屏幕时，改变布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.resume</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>:</span><br><span class="line">      <span class="string">"name photo"</span></span><br><span class="line">      <span class="string">"work about"</span></span><br><span class="line">      <span class="string">"work education"</span></span><br><span class="line">      <span class="string">"community skills"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于屏幕尺寸的响应，可以增加更多的临界点。例如，在平板电脑等中型屏幕上，我们可能希望所有内容都放在一个栏中，但“个人”和“图像”部分需要并排放置在顶部。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">900px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.resume</span> &#123;</span><br><span class="line">      <span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr;</span><br><span class="line">      <span class="attribute">grid-template-areas</span>:</span><br><span class="line">        <span class="string">"name photo"</span></span><br><span class="line">        <span class="string">"about about"</span></span><br><span class="line">        <span class="string">"work work"</span></span><br><span class="line">        <span class="string">"education education"</span></span><br><span class="line">        <span class="string">"skills skills"</span></span><br><span class="line">        <span class="string">"community community"</span></span><br><span class="line">        <span class="string">"references references"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="做好单页打印的准备"><a href="#做好单页打印的准备" class="headerlink" title="做好单页打印的准备"></a>做好单页打印的准备</h1><p>如果你需要在一张纸上精美的打印你的简历，则需要牢记一些注意事项。最困难的挑战通常是缩减字数，以满足一页纸的要求。</p>
<p>避免减小字体大小以挤压更多信息，因为它可能变得难以阅读。一个处理技巧便是在你制作简历时，为简历增加一个暂时的大小限制。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.resume</span> &#123;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">210mm</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">297mm</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过设置 A4 纸张大小的边界，我们可以清晰的看到内容尺寸是否太小，亦或者是内容超出边界（这意味着它会被打印到第二页）。</p>
<p>你可以告诉 CSS 在打印时将一些不必要的东西隐藏，比如浏览器会插入的像时间和页数等信息。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@page</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0cm</span>;</span><br><span class="line">  <span class="attribute">size</span>: A4 portrait;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的一件事是，不同的浏览器可能会使用大小略有不同的不同字体来呈现简历。 如果你想要非常精确的打印简历，另一种选择是将其另存为PDF，并在你的站点上提供下载链接。</p>
<h1 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h1><p>CSS Grid 在现代浏览器中具有良好的支持。</p>
<p>Internet Explorer（IE）支持使用前缀的 CSS Grid 规范的较旧版本。 例如，<code>grid-template-columns</code> 被编写为 <code>-ms-grid-columns</code> 。 通过 Autoprefixer 运行代码可以帮助添加这些前缀，但是由于在旧规范中某些属性的行为有所不同，而导致某些属性不存在，因此将需要进行手动更改和全面测试。 丹尼尔·托农（Daniel Tonon）的<a href="https://css-tricks.com/css-grid-in-ie-css-grid-and-the-new-autoprefixer/" target="_blank" rel="noopener">文章</a>值得一看，其中介绍了如何配置 Autoprefixer 以使事情尽可能正常地工作。</p>
<p>自动前缀的另一种方法是<a href="https://www.smashingmagazine.com/2017/11/css-grid-supporting-browsers-without-grid/" target="_blank" rel="noopener">提供回退</a>，例如通过使用 float 布局。 无法识别 CSS 网格属性的浏览器将使用此显示。 不管你是否需要支持IE，回退都是明智的，因为它确保了不支持 CSS Grid 的浏览器仍然正确显示你的内容。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>简历</tag>
        <tag>CSS</tag>
        <tag>排版</tag>
        <tag>Grid</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-66-plus-one</title>
    <url>/2020/02/17/leetcode-66-plus-one/</url>
    <content><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 第一遍</li>
<li><input disabled="" type="checkbox"> 第二遍</li>
<li><input disabled="" type="checkbox"> 第三遍</li>
<li><input disabled="" type="checkbox"> 第四遍</li>
<li><input disabled="" type="checkbox"> 第五遍</li>
</ul>
<h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote>
<p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1:</p>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br>示例 2:</p>
<p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/plus-one" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>编写 <code>public int[] plusOne(int[] digits)</code> 函数</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的思路可以简单描述为，模拟竖式加法运算。</p>
<h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 思路：模拟竖式计算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 末位加一</span></span><br><span class="line">    digits[digits.length - <span class="number">1</span>] = digits[digits.length - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            digits[i] = digits[i] % <span class="number">10</span>;</span><br><span class="line">            digits[i - <span class="number">1</span>] = digits[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理原有位数不够</span></span><br><span class="line">    <span class="keyword">if</span> (digits[<span class="number">0</span>] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; digits.length; i++) &#123;</span><br><span class="line">            result[i+<span class="number">1</span>] = digits[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>时间复杂度</strong>为 $O(n)$</li>
<li><strong>空间复杂度</strong><ul>
<li>最好 $O(1)$ </li>
<li>最坏 $O(n)$ （最高位进位情况）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1-two-sum</title>
    <url>/2020/02/17/leetcode-1-two-sum/</url>
    <content><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 第一遍</li>
<li><input disabled="" type="checkbox"> 第二遍</li>
<li><input disabled="" type="checkbox"> 第三遍</li>
<li><input disabled="" type="checkbox"> 第四遍</li>
<li><input disabled="" type="checkbox"> 第五遍</li>
</ul>
<h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>编写 <code>public int[] twoSum(int[] nums, int target)</code> 函数</p>
</blockquote>
<h2 id="思路：暴力法"><a href="#思路：暴力法" class="headerlink" title="思路：暴力法"></a>思路：暴力法</h2><p>很容易想到一种暴力解法，即，</p>
<ul>
<li>枚举每一种可能，按条件返回结果</li>
</ul>
<h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力解法：枚举每一种可能</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = j;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>时间复杂度</strong>为 $O(n^2)$</li>
<li><strong>空间复杂度</strong>为 $O(1)$ </li>
</ul>
<h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><p>上述暴力法的时间效率实在是不堪入目。一种比较常规的优化思路便是<strong>空间换时间</strong>，来看一看<a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/" target="_blank" rel="noopener">高手的解法</a>。</p>
<h2 id="思路：一遍哈希表"><a href="#思路：一遍哈希表" class="headerlink" title="思路：一遍哈希表"></a>思路：一遍哈希表</h2><p>上述暴力法时间的低效主要是由于，程序只记住了两个待检验的数组下标，而重复遍历了数组很多次。其实，没必要重复遍历：<strong>遍历的时候，存储起来</strong>，就会使得时间效率提高。</p>
<p>对于本题，可以用<strong>哈希表</strong>，存储<strong>数</strong>和<strong>下标</strong>之间的关系。这样在通常情况下，只需 $O(1)$ 的时间，便可访问到哈希表中已存在的元素。从而使得整个程序的时间复杂度降到 $O(n)$ 。</p>
<h2 id="Java-实现-1"><a href="#Java-实现-1" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement)) &#123;               <span class="comment">// 如果存在满足条件的数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(complement), i &#125;; <span class="comment">// 直接返回结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);                             <span class="comment">// 否则，存储到哈希表中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>时间复杂度</strong>为 $O(n)$ </li>
<li><strong>空间复杂度</strong>为 $O(n)$ </li>
</ul>
<h1 id="类似题目：15-3sum"><a href="#类似题目：15-3sum" class="headerlink" title="类似题目：15.3sum"></a>类似题目：15.3sum</h1><blockquote>
<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br> [-1, 0, 1],<br> [-1, -1, 2]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="刷题标记-1"><a href="#刷题标记-1" class="headerlink" title="刷题标记"></a>刷题标记</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 第一遍</li>
<li><input disabled="" type="checkbox"> 第二遍</li>
<li><input disabled="" type="checkbox"> 第三遍</li>
<li><input disabled="" type="checkbox"> 第四遍</li>
<li><input disabled="" type="checkbox"> 第五遍</li>
</ul>
<h2 id="高手方案-1"><a href="#高手方案-1" class="headerlink" title="高手方案"></a>高手方案</h2><p>这道题，我没什么思路，直接参考了<a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/" target="_blank" rel="noopener">高手题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || len &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    Arrays.sort(nums); <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">int</span> L = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> R = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                ans.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line">                <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++; <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R-<span class="number">1</span>]) R--; <span class="comment">// 去重</span></span><br><span class="line">                L++;</span><br><span class="line">                R--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) L++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><strong>空间换时间</strong>是一种常见的优化思路</li>
<li>另外，根据题意，<strong>舍弃遍历过程中绝不可能的组合</strong>，也是一种优化手段</li>
<li>已经<strong>有序</strong>的元素有着非常良好的性质，可以<strong>先排序</strong>，<strong>再解题</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>合并有序线性表</title>
    <url>/2020/02/17/he-bing-you-xu-xian-xing-biao/</url>
    <content><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 第一遍</li>
<li><input disabled="" type="checkbox"> 第二遍</li>
<li><input disabled="" type="checkbox"> 第三遍</li>
<li><input disabled="" type="checkbox"> 第四遍</li>
<li><input disabled="" type="checkbox"> 第五遍</li>
</ul>
<h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote>
<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>编写 <code>public ListNode mergeTwoLists(ListNode l1, ListNode l2)</code> 函数</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>合并有序线性表 L1、L2，有一个通用的思路，如下</p>
<ol>
<li>初始化每个表的遍历指针 Lp1，Lp2；并且新建一个线性表 L3，存储结果。</li>
<li>循环比较，将较小元素放入 L3</li>
<li>如果 L1 还有元素未遍历，处理 L1 剩余元素</li>
<li>处理 L2 剩余元素未遍历，处理 L2 剩余元素</li>
</ol>
<h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建带有头指针的链表，方便操作</span></span><br><span class="line">    ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 新建一个 p 指针用于遍历</span></span><br><span class="line">    ListNode p = l3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环比较，并把较小的结点加入链表 l3</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val)&#123;</span><br><span class="line">            p.next = l1;</span><br><span class="line">            p = p.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.next = l2;</span><br><span class="line">            p = p.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 l1 剩余元素加入 l3</span></span><br><span class="line">    <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p.next = l1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 l2 剩余元素加入 l3</span></span><br><span class="line">    <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p.next = l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 l3 的头指针</span></span><br><span class="line">    <span class="keyword">return</span> l3.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>为 $O(n+m)$</li>
<li><strong>空间复杂度</strong>为 $O(1)$</li>
</ul>
<h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><h2 id="思路：递归"><a href="#思路：递归" class="headerlink" title="思路：递归"></a>思路：递归</h2><p>高手还另外提供了一种<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/" target="_blank" rel="noopener">递归思路</a>：</p>
<ul>
<li>两个链表头部较小的一个与剩下元素的 <code>merge</code> 操作结果合并</li>
</ul>
<h2 id="Java-实现-1"><a href="#Java-实现-1" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>为 $O(n+m)$</li>
<li><strong>空间复杂度</strong>为 $O(n+m)$ ：最多消耗 n+m 层栈空间</li>
</ul>
<h1 id="类似题：88-merge-sorted-array"><a href="#类似题：88-merge-sorted-array" class="headerlink" title="类似题：88.merge-sorted-array"></a>类似题：88.merge-sorted-array</h1><blockquote>
<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p>
<p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="刷题标记-1"><a href="#刷题标记-1" class="headerlink" title="刷题标记"></a>刷题标记</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 第一遍</li>
<li><input disabled="" type="checkbox"> 第二遍</li>
<li><input disabled="" type="checkbox"> 第三遍</li>
<li><input disabled="" type="checkbox"> 第四遍</li>
<li><input disabled="" type="checkbox"> 第五遍</li>
</ul>
<h2 id="Java-实现-2"><a href="#Java-实现-2" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先把 nums 所有元素移到最后，记录开始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        nums1[i + n] = nums1[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再遍历比较，写入到 nums1 前半部分</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = n;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n + m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[j] &lt; nums2[i]) &#123;</span><br><span class="line">            nums1[k++] = nums1[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k++] = nums2[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 nums1 剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n + m)&#123;</span><br><span class="line">        nums1[k++] = nums1[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 nums2 剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)&#123;</span><br><span class="line">        nums1[k++] = nums2[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>时间复杂度</strong>为 $O(n+m)$</li>
<li><strong>空间复杂度</strong>为 $O(1)$</li>
</ul>
<h2 id="高手方案-1"><a href="#高手方案-1" class="headerlink" title="高手方案"></a>高手方案</h2><ul>
<li>思路<ul>
<li>从后往前遍历，将大的放到 nums1 的指定位置</li>
</ul>
</li>
<li>Java 实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作者：LeetCode</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// two get pointers for nums1 and nums2</span></span><br><span class="line">    <span class="keyword">int</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// set pointer for nums1</span></span><br><span class="line">    <span class="keyword">int</span> p = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while there are still elements to compare</span></span><br><span class="line">    <span class="keyword">while</span> ((p1 &gt;= <span class="number">0</span>) &amp;&amp; (p2 &gt;= <span class="number">0</span>))</span><br><span class="line">        <span class="comment">// compare two elements from nums1 and nums2 </span></span><br><span class="line">        <span class="comment">// and add the largest one in nums1 </span></span><br><span class="line">        nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add missing elements from nums2</span></span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2 + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>时间复杂度</strong>为 $O(n+m)$</li>
<li><strong>空间复杂度</strong>为 $O(1)$</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>合并有序线性表</strong> L1、L2，有一个<strong>通用的思路</strong>，如下</p>
<ol>
<li>初始化每个表的遍历指针 Lp1，Lp2；并且新建一个线性表 L3，存储结果。</li>
<li>循环比较，将较小元素放入 L3</li>
<li>如果 L1 还有元素未遍历，处理 L1 剩余元素</li>
<li>处理 L2 剩余元素未遍历，处理 L2 剩余元素</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>合并</tag>
        <tag>有序表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-189-rotate-array</title>
    <url>/2020/02/17/leetcode-189-rotate-array/</url>
    <content><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 第一遍</li>
<li><input disabled="" type="checkbox"> 第二遍</li>
<li><input disabled="" type="checkbox"> 第三遍</li>
<li><input disabled="" type="checkbox"> 第四遍</li>
<li><input disabled="" type="checkbox"> 第五遍</li>
</ul>
<h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p>
<p>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]<br>说明:</p>
<p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>编写 <code>public void rotate(int[] nums, int k)</code> </p>
</blockquote>
<h2 id="思路：暴力法"><a href="#思路：暴力法" class="headerlink" title="思路：暴力法"></a>思路：暴力法</h2><ul>
<li>两个循环<ul>
<li>内部循环只向右移动一格，用一个变量暂存溢出元素</li>
<li>外部循环 <strong>k</strong> 次，相当于向右移动 k 个位置</li>
</ul>
</li>
</ul>
<h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 暴力法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;          <span class="comment">//多次移动</span></span><br><span class="line">        <span class="keyword">int</span> tail = nums[nums.length - <span class="number">1</span>];  <span class="comment">// 用一个变量暂存移位溢出的数字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            nums[j] = nums[j - <span class="number">1</span>];         <span class="comment">// 内部循环只移动一格</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[<span class="number">0</span>] = tail;                    <span class="comment">// 将溢出的数组，放到数组首位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>为 $O(n*k)$</li>
<li><strong>空间复杂度</strong>为 $O(1)$</li>
</ul>
<h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><h2 id="思路：使用反转"><a href="#思路：使用反转" class="headerlink" title="思路：使用反转"></a>思路：使用反转</h2><p>这里记录一下 <strong>使用反转</strong> 这个思路</p>
<blockquote>
<p>这个方法基于这个事实：当我们旋转数组 k 次，$k%n$ 个尾部元素会被移动到头部，剩下的元素会被向后移动。</p>
<p>在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 $n−k$ 个元素，就能得到想要的结果。</p>
</blockquote>
<h2 id="Java-实现-1"><a href="#Java-实现-1" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>为 $O(n)$</li>
<li><strong>空间复杂度</strong>为 $O(1)$</li>
</ul>
<p>更多参见<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>循环移动数组元素可以利用<strong>反转</strong>高效解决，即<ul>
<li>反转数组所有元素</li>
<li>反转前 k 个 元素</li>
<li>反转后 n - k 个元素</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-26-remove-duplicates-from-sorted-array</title>
    <url>/2020/02/17/leetcode-26-remove-duplicates-from-sorted-array/</url>
    <content><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 第一遍</li>
<li><input disabled="" type="checkbox"> 第二遍</li>
<li><input disabled="" type="checkbox"> 第三遍</li>
<li><input disabled="" type="checkbox"> 第四遍</li>
<li><input disabled="" type="checkbox"> 第五遍</li>
</ul>
<h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<p>给定数组 nums = [1,1,2], </p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>int len = removeDuplicates(nums);</p>
<p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>   print(nums[i]);<br>}</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>编写 <code>public int removeDuplicates(int[] nums)</code> 函数</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于数组是有序的，所以重复的元素在数组中必定是连续出现。可以用双指针遍历比较数组元素，将非重复的元素依次放到数组前半部分即可。</p>
<p>双指针遍历问题中，关键是处理好各个指针移动的条件。对于本题，双指针的移动可由如下类 C 伪码描述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span>;  <span class="comment">// 记录数组中非重复元素的最后一个元素的下标</span></span><br><span class="line">j = <span class="number">0</span>;  <span class="comment">// 用于遍历数组，与下标为 i 的元素比较</span></span><br><span class="line"><span class="keyword">if</span> (nums[i] == nums[j])&#123;     <span class="comment">// 遇到重复元素</span></span><br><span class="line">    j++;                     <span class="comment">// 那么移动 j 指针，继续寻找非重复元素的下标</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                     <span class="comment">// 遇到非重复元素</span></span><br><span class="line">    nums[++i] = nums[j++];   <span class="comment">// 将 j 下标的元素复制到 i 的下一个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><p>根据上述思路，很容易得到以下 Java 实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 记录数组中非重复元素的最后一个元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// 用于遍历数组，与下标为 i 的元素比较</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用双指针遍历比较数组元素</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[j]) &#123;       <span class="comment">// 遇到重复元素</span></span><br><span class="line">            j++;                        <span class="comment">// 那么移动 j 指针，继续寻找非重复元素的下标</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                        <span class="comment">// 遇到非重复元素</span></span><br><span class="line">            nums[++i] = nums[j++];      <span class="comment">// 将 j 下标的元素复制到 i 的下一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;                       <span class="comment">// 返回元素个数，因而 i 要加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于只涉及到一个循环，其<strong>时间复杂度</strong>为 $O(n)$ ;</p>
<p>由于只涉及到常数级别的额外空间使用，故<strong>空间复杂度</strong>为 $O(1)$ </p>
<h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><p>参见<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/" target="_blank" rel="noopener">官方题解</a>，与我的思路类似。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><strong>双指针</strong>技巧，又称作<strong>快慢指针</strong>：通过两个遍历速度不同的指针，达到遍历过程中比较等操作。</li>
<li><strong>双指针</strong>的思路关键要处理好<strong>遍历指针移动的条件</strong>。这个问题解决好了，那么问题也就解决了。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-11-container-with-most-water</title>
    <url>/2020/02/13/leetcode-11-container-with-most-water/</url>
    <content><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 第一遍</li>
<li><input disabled="" type="checkbox"> 第二遍</li>
<li><input disabled="" type="checkbox"> 第三遍</li>
<li><input disabled="" type="checkbox"> 第四遍</li>
<li><input disabled="" type="checkbox"> 第五遍</li>
</ul>
<h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote>
<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p>示例:</p>
<p>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>编写 <code>public int maxArea(int[] height)</code> 函数</p>
</blockquote>
<h2 id="思路：暴力解法"><a href="#思路：暴力解法" class="headerlink" title="思路：暴力解法"></a>思路：暴力解法</h2><p>很自然的一种暴力思路就是枚举每一种可能，计算题意中的面积；并且，在枚举过程中，不断比较，得到最大值。</p>
<h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 思路：二重循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> minIndex = height[i] &gt; height[j] ? j : i;</span><br><span class="line">            <span class="keyword">int</span> area = height[minIndex] * (j - i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (area &gt; result) &#123;</span><br><span class="line">                result = area;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码可知，程序包含二重循环，因而<strong>时间复杂度</strong>为 $O(n^2)$ </p>
<h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><p>上述方案比较费时，来看一看高手的解法。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>利用<strong>双指针</strong>，分别初始在<strong>起始</strong>和<strong>末尾</strong>。</li>
<li>依题意，计算所围的面积</li>
<li>将<strong>高度较短</strong>的指针向中心移动，然后回到第 2 步 </li>
</ul>
<p>P.S. 为什么是移动高度较短的指针？因为移动较高的指针，只会使得面积变小；而移动较低指针，可能会遇到较高指针（基于此假设，面积可能会变大）。</p>
<h3 id="Java-实现-1"><a href="#Java-实现-1" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 作者：LeetCode</span></span><br><span class="line">    <span class="comment">// 链接：https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode/</span></span><br><span class="line">    <span class="keyword">int</span> maxarea = <span class="number">0</span>, l = <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));</span><br><span class="line">        <span class="keyword">if</span> (height[l] &lt; height[r])</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxarea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码可知，<strong>时间复杂度</strong>为 $O(n)$ ，这是一个极大的优化</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>解题小套路<ul>
<li>遇到较难的题目<ul>
<li>先想<strong>能否暴力解决</strong>，在此之后再优化，或者看别人思路。</li>
<li>暴力无法解决，找找<strong>解的规律</strong>，即从基本情况开始，寻找其是否有<strong>重复子问题</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>双指针</strong>在数组遍历中是一个常见套路，需要多多注意。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
        <tag>左右夹逼</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-141-linked-list-cycle</title>
    <url>/2020/02/12/leetcode-141-linked-list-cycle/</url>
    <content><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 第一遍</li>
<li><input disabled="" type="checkbox"> 第二遍</li>
<li><input disabled="" type="checkbox"> 第三遍</li>
<li><input disabled="" type="checkbox"> 第四遍</li>
<li><input disabled="" type="checkbox"> 第五遍</li>
</ul>
<h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote>
<p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>示例 1：</p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>示例 2：</p>
<p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
<p>示例 3：</p>
<p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p>
<p>进阶：</p>
<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>编写 <code>public boolean hasCycle(ListNode head)</code> 函数</p>
</blockquote>
<p>P.S.这道题，我审题出现了错误。原本以为要自己实现 <code>ListNode</code> 类，结果不需要。只要依据输入的链表编写 <code>hasCycle</code> 函数即可。</p>
<h2 id="暴力思路"><a href="#暴力思路" class="headerlink" title="暴力思路"></a>暴力思路</h2><p>有环的链表，从头节点依次向下一个结点遍历，一定会出现死循环；而无环链表，就会正常跳出循环。</p>
<p>一种直接的思路时，依次遍历链表的每个结点，并把它缓存起来。之后碰到与缓存中相同的结点，说明链表有环；正常的循环终止，说明无环。</p>
<h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 缓存结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list.contains(head))              <span class="comment">// 如果缓存中存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;                     <span class="comment">// 直接返回 true</span></span><br><span class="line"></span><br><span class="line">        list.add(head);                      <span class="comment">// 否则，将该结点加入缓存</span></span><br><span class="line">        head = head.next;                    <span class="comment">// 继续遍历</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;                            <span class="comment">// 循环正常退出，非死循环，返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上述代码分析可得，该算法的<strong>时间复杂度</strong>为 O( n )，<strong>空间复杂度</strong>为 O( n )</p>
<p>根据题中描述，貌似存在只使用<strong>常量级别</strong>（ O(1) ）空间的算法，让我们来看看高手的方案。</p>
<h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>高手利用了<strong>两个指针遍历</strong>链表，但是却以<strong>不同的速度</strong>在遍历。如果链表中有环，那么在有限的循环中它们一定会相碰（即访问到同一个结点）；否则，一定会有一个指针（这个指针是快指针）提前到达链表尾部，从而返回无环的判断结果。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><strong>双指针</strong>但以<strong>不同速度</strong>遍历链表（类比田径比赛中的快慢运动员），可以判断链表是否有环，其空间复杂度为 O( 1 )</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>遍历</tag>
        <tag>链表</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-70-climbing-stairs</title>
    <url>/2020/02/11/leetcode-70-climbing-stairs/</url>
    <content><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 第一遍</li>
<li><input disabled="" type="checkbox"> 第二遍</li>
<li><input disabled="" type="checkbox"> 第三遍</li>
<li><input disabled="" type="checkbox"> 第四遍</li>
<li><input disabled="" type="checkbox"> 第五遍</li>
</ul>
<h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶<br>示例 2：</li>
</ol>
<p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/climbing-stairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>编写  <code>public int climbStairs(int n);</code> 函数</p>
</blockquote>
<h2 id="法一——递归（超时！）"><a href="#法一——递归（超时！）" class="headerlink" title="法一——递归（超时！）"></a>法一——递归（超时！）</h2><h3 id="思路一：原始递归"><a href="#思路一：原始递归" class="headerlink" title="思路一：原始递归"></a>思路一：原始递归</h3><p>根据题意，很容易想到一种递归解决方案。</p>
<p>试想这样一个场景，从第 n 阶台阶下楼，每次要么下 1 阶，要么下 2 阶（易知这种场景和上述问题类似，并且结果相同）。那么，在到达第 i 层时，总方法数为<br>$$<br>climbStairs(i) = climbStairs( i - 1 ) + climbStairs( i - 1 )<br>$$<br>这个就是递归程序递推公式。</p>
<p>那么什么时候，递归程序终止呢？很显然，当 i = 0 或 i = 1 时，方法数只可能为 1。</p>
<p>这也就是递归的终止条件。</p>
<p>由此，可以给出其类 C 伪码描述，具体如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( n == <span class="number">0</span> || n == <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> climbStairs( n - <span class="number">1</span> ) + climbStairs( n - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路二：用“空间换时间”优化"><a href="#思路二：用“空间换时间”优化" class="headerlink" title="思路二：用“空间换时间”优化"></a>思路二：用“空间换时间”优化</h3><p>递归程序由于有很多的冗余计算，会使得程序的执行时间随数据规模呈指数级上升，这是极其恐怖的。一种优化思路，便是利用<strong>空间换时间</strong>的方案优化。具体的，在本例中，即考虑将已经计算过的方案书缓存起来，供后续调用使用。</p>
<h3 id="思路二的-Java-实现"><a href="#思路二的-Java-实现" class="headerlink" title="思路二的 Java 实现"></a>思路二的 Java 实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; cache </span><br><span class="line">        = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 利用 HashMap 缓存数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n1, n2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(n - <span class="number">1</span>)) &#123;<span class="comment">// 如果中间结果已在缓存</span></span><br><span class="line">            <span class="comment">// 直接从缓存中取得数据</span></span><br><span class="line">            n1 = Integer.parseInt(cache.get(n - <span class="number">1</span>).toString());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，要计算</span></span><br><span class="line">            n1 = climbStairs(n - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 再存入缓存</span></span><br><span class="line">            cache.put(n - <span class="number">1</span>, n1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(n - <span class="number">2</span>)) &#123;<span class="comment">// 与 n - 1 类似</span></span><br><span class="line"></span><br><span class="line">            n2 = Integer.parseInt(cache.get(n - <span class="number">2</span>).toString());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            n2 = climbStairs(n - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            cache.put(n - <span class="number">2</span>, n2);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n1 + n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方案在 leetcode 上测试运行，发现当 n 达到 40以上，开始出现超时。看来光用递归解决不了问题。</p>
<p>看到本题标签有<code>动态规划</code>，于是查找资料，重新思考。</p>
<p>看到<a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">这篇博客</a>，写的不错，并得到下面一种思路。</p>
<h2 id="法二——非递归"><a href="#法二——非递归" class="headerlink" title="法二——非递归"></a>法二——非递归</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>仔细运行法一中的程序，发现其方案数竟然是<strong>斐波那契数列</strong>，于是可以用斐波那契数列的非递归程序解决。也就是<a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">这篇博客</a>中所提到的<strong>“自底向上”</strong>的思路。</p>
<h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 法二 非递归（自底向上，相当于上楼）</span></span><br><span class="line">    <span class="comment">// 通过法一，我们可以观察到到达每层楼的方案序列，貌似构成了斐波那契数列</span></span><br><span class="line">    <span class="comment">// 利用斐波那契数列解决</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            n3 = n1 + n2;</span><br><span class="line">            n1 = n2;</span><br><span class="line">            n2 = n3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很惊喜的发现，该方案成功 AC，并且执行时间效率非常高。</p>
<h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><h2 id="执行用时为-0-s-的范例"><a href="#执行用时为-0-s-的范例" class="headerlink" title="执行用时为 0 s 的范例"></a>执行用时为 0 s 的范例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解法：第n层需要的步数 = （第n-1层 + 1步） + （第n-2层 + 2步）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        c = a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，我的法二和高手范例几乎类似，这是十分美妙的。</p>
<h2 id="官方方案"><a href="#官方方案" class="headerlink" title="官方方案"></a>官方方案</h2><p><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode/</a></p>
<p>最后两种数学方法给跪了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>本题涉及动态规划。能够利用动态规划解决问题，需要问题有以下特性<ul>
<li>optimal substructure，即原问题的最优解可有子问题的最优解组合而成。</li>
<li>overlapping sub-problems，即可将原问题划分为若干规模较小但与原问题类似的子问题解决</li>
</ul>
</li>
<li>动态规划的实现，可以有以下两种思路<ul>
<li>自顶向下思路（参见本题法一）</li>
<li>自底向上思路（参见本题法二）</li>
</ul>
</li>
<li>递归的优化，可以采用<strong>空间换时间</strong>的缓存方案</li>
</ul>
<p>P.S. 部分总结意译了维基百科对于<a href="https://en.wikipedia.org/wiki/Dynamic_programming#Computer_programming" target="_blank" rel="noopener">动态规划</a>的解释</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.283.move-zeroes</title>
    <url>/2020/02/09/leetcode-283-move-zeroes/</url>
    <content><![CDATA[<h1 id="刷题标记"><a href="#刷题标记" class="headerlink" title="刷题标记"></a>刷题标记</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 第一遍</li>
<li><input disabled="" type="checkbox"> 第二遍</li>
<li><input disabled="" type="checkbox"> 第三遍</li>
<li><input disabled="" type="checkbox"> 第四遍</li>
<li><input disabled="" type="checkbox"> 第五遍</li>
</ul>
<h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p>
<p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/move-zeroes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>编写函数：<code>public void moveZeroes(int[] nums)</code></p>
</blockquote>
<h2 id="法一——遍历和移位同时进行（Fail）"><a href="#法一——遍历和移位同时进行（Fail）" class="headerlink" title="法一——遍历和移位同时进行（Fail）"></a>法一——遍历和移位同时进行（Fail）</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>遍历 <code>nums</code><ul>
<li>若是 0 ，所有向前移</li>
<li>若非 0 ，下一个</li>
</ul>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>遍历需要一个循环，移位需要一个循环，将两个循环嵌套即可。详见下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 法一(fail)</span></span><br><span class="line">    <span class="comment">// 遍历 nums</span></span><br><span class="line">    <span class="comment">// 若是 0 ，所有向前移</span></span><br><span class="line">    <span class="comment">// 若非 0 ，下一个</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 0 的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length - count; j++) &#123;</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[nums.length - count] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h3><ul>
<li>时间上，两个循环嵌套，每层至多循环 n 次，故时间复杂度为 $O(n)$</li>
<li>空间上，只定义了额外的几个辅助变量（ <code>count</code> 、<code>i</code>、<code>j</code> 等 ），故空间复杂度为 $O(1)$</li>
</ul>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul>
<li>所给解法虽然能过题中所给样例，但是遇到<strong>连续 0</strong>的情况，就会给出错误输出（如输入 [0, 0, 1]，本程序输出 [0, 1, 0]；实际上，应输出 [1, 0, 0]）。</li>
<li>回顾此解法，发现问题所在：内层循环在移位时，并没有考虑<strong>连续 0</strong></li>
<li>可能的解决方案：在内层循环中再嵌套一层循环，用于找其后非零元素</li>
<li>预估其时间复杂度较高（$O(n^3)$），此法废弃</li>
</ul>
<h2 id="法二——自顶向下的思路（AC）"><a href="#法二——自顶向下的思路（AC）" class="headerlink" title="法二——自顶向下的思路（AC）"></a>法二——自顶向下的思路（AC）</h2><h3 id="自顶向的下编程理念"><a href="#自顶向的下编程理念" class="headerlink" title="自顶向的下编程理念"></a>自顶向的下编程理念</h3><ul>
<li><p>将解决问题的过程，分成几个较大的步骤。从宏观层面上，验证思路的正确性</p>
</li>
<li><p>将上述每一步骤，各自抽象成一个函数，确定函数的形参列表和返回值，并按解题步骤在主控程序中排列好</p>
</li>
<li><p>转向细节层面，考虑每一个小步骤的功能如何实现</p>
</li>
</ul>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li>第一遍遍历，得到 0 的个数</li>
<li>第二遍遍历，删掉所有 0 元素（伪删除，仅将非零元素前移）</li>
<li>在末尾补全 0</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="顶层实现"><a href="#顶层实现" class="headerlink" title="顶层实现"></a>顶层实现</h4><p>为得到 0 的个数，定义 <code>int countZeros(int[] nums)</code> 解决</p>
<p>为删掉所有 0 元素，定义 <code>void removeZeros(int[] nums)</code> 解决</p>
<p>为在末尾补全 0，定义 <code>void completeZeros(int[] nums, int count)</code> 解决</p>
<p>假设函数功能均按照预期运行，则在主控函数 <code>moveZeroes</code> 中可如下调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 法二</span></span><br><span class="line">    <span class="comment">// 第一遍遍历，得到 0 的个数</span></span><br><span class="line">    <span class="keyword">int</span> count_0 = countZeros(nums);</span><br><span class="line">    <span class="comment">// 第二遍遍历，删掉所有 0 元素</span></span><br><span class="line">    removeZeros(nums);</span><br><span class="line">    <span class="comment">// 在末尾补全 0</span></span><br><span class="line">    completeZeros(nums, count_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><h5 id="int-countZeros-int-nums"><a href="#int-countZeros-int-nums" class="headerlink" title="int countZeros(int[] nums)"></a>int countZeros(int[] nums)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="void-removeZeros-int-nums"><a href="#void-removeZeros-int-nums" class="headerlink" title="void removeZeros(int[] nums)"></a>void removeZeros(int[] nums)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="void-completeZeros-int-nums-int-count"><a href="#void-completeZeros-int-nums-int-count" class="headerlink" title="void completeZeros(int[] nums, int count)"></a>void completeZeros(int[] nums, int count)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">completeZeros</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= nums.length - count ; i--) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 法二</span></span><br><span class="line">    <span class="comment">// 第一遍遍历，得到 0 的个数</span></span><br><span class="line">    <span class="keyword">int</span> count_0 = countZeros(nums);</span><br><span class="line">    <span class="comment">// 第二遍遍历，删掉所有 0 元素</span></span><br><span class="line">    removeZeros(nums);</span><br><span class="line">    <span class="comment">// 在末尾补全 0</span></span><br><span class="line">    completeZeros(nums, count_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">completeZeros</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= nums.length - count ; i--) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时空复杂度分析-1"><a href="#时空复杂度分析-1" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h3><ul>
<li>时间上，调用了 3 个 串行的 $O(n)$ ，故时间复杂度为 $O(n)$</li>
<li>空间上，使用了常数个辅助变量，空间复杂度为 $O(1)$</li>
</ul>
<h1 id="高手方案"><a href="#高手方案" class="headerlink" title="高手方案"></a>高手方案</h1><h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><ul>
<li>遍历数组，不为 0 的元素移动数组前方，用 index下标记录。</li>
<li>遍历结束，对index值后的元素统一设为0</li>
</ul>
<h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来自执行用时 0 ms 范例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nums[index] = nums[i];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-count; i&lt;nums.length; i++)&#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>时间复杂度</strong>为 $O(n)$</li>
<li><strong>空间复杂度</strong>为 $O(1)$</li>
</ul>
<p>另一种容易理解的解法，具体参见<a href="https://leetcode-cn.com/problems/move-zeroes/solution/0-ms-zai-suo-you-java-ti-jiao-zhong-ji-bai-liao--2/" target="_blank" rel="noopener">这个题解</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><strong>自顶向下</strong>的编程理念</li>
<li>双指针优化思路</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>WindowsTerminal下载、安装及配置</title>
    <url>/2020/02/08/windowsterminal-xia-zai-an-zhuang-ji-pei-zhi/</url>
    <content><![CDATA[<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><h2 id="Microsoft-Store"><a href="#Microsoft-Store" class="headerlink" title="Microsoft Store"></a>Microsoft Store</h2><ul>
<li>打开 Microsoft Store</li>
<li>搜索 <code>Windows Terminal</code></li>
<li>点击 <code>获取</code></li>
<li>等待下载安装完成即可</li>
</ul>
<p>P.S. 此版本比较老旧，如果想用最新版，推荐下面的方式安装</p>
<h2 id="Release-pre-build（Recommended）"><a href="#Release-pre-build（Recommended）" class="headerlink" title="Release pre-build（Recommended）"></a>Release pre-build（Recommended）</h2><ul>
<li>打开网址：<a href="https://github.com/microsoft/terminal/releases" target="_blank" rel="noopener">https://github.com/microsoft/terminal/releases</a></li>
<li>选择最新 release 的 Assets 中的Microsoft.WindowsTerminal_XXXXXX_8wekyb3d8bbwe.msixbundle（其中，<code>XXXXXX</code> 为版本号）下载（建议在科学上网的条件下下载，否则容易下载失败）</li>
<li>下载完成后，双击该文件，按提示安装</li>
</ul>
<h2 id="Build-from-source"><a href="#Build-from-source" class="headerlink" title="Build from source"></a>Build from source</h2><p>P.S.这个配置较为复杂，暂且请参考<a href="https://github.com/microsoft/terminal#developer-guidance" target="_blank" rel="noopener">官方文档</a></p>
<h1 id="美化配置"><a href="#美化配置" class="headerlink" title="美化配置"></a>美化配置</h1><p>P.S. 安装配置前推荐准备好科学上网</p>
<h2 id="安装-Fira-字体"><a href="#安装-Fira-字体" class="headerlink" title="安装  Fira 字体"></a>安装  Fira 字体</h2><p>参见 <a href="https://www.misiyu.cn/article/134.html" target="_blank" rel="noopener">博客教程</a></p>
<h2 id="安装-oh-my-posh-前置"><a href="#安装-oh-my-posh-前置" class="headerlink" title="安装 oh-my-posh 前置"></a>安装 oh-my-posh 前置</h2><p>照着这个<a href="https://www.misiyu.cn/article/134.html" target="_blank" rel="noopener">博客教程</a> Fira code字体的安装，但是<strong>安装oh-my-posh主题</strong>时，<em>choco 安装终端模拟器 - ConEmu</em> 这一步总会出错。</p>
<p>在 <a href="https://github.com/JanDeDobbeleer/oh-my-posh#prerequisites" target="_blank" rel="noopener">oh-my-posh 仓库</a>中，找到了替代方案，即采用 Scoop 安装 ConEmu。</p>
<p>在此之前要先安装 Scoop，具体命令如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载安装 Scoop</span></span><br><span class="line"><span class="variable">$</span> <span class="built_in">set-executionpolicy</span> remotesigned <span class="literal">-scope</span> currentuser</span><br><span class="line">iex (<span class="built_in">new-object</span> net.webclient).downloadstring(<span class="string">'https://get.scoop.sh'</span>)</span><br><span class="line"><span class="comment"># 搜索 conemu</span></span><br><span class="line"><span class="variable">$</span> scoop search conemu</span><br></pre></td></tr></table></figure>



<p>此时返回结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">Results from other known buckets...</span><br><span class="line">(add them using <span class="string">'scoop bucket add &lt;name&gt;'</span>)</span><br><span class="line"></span><br><span class="line">    bucket/conemu-color-themes</span><br><span class="line">    bucket/conemu</span><br></pre></td></tr></table></figure>



<p>在安装前，要运行如下命令（感觉是第一次，需要初始化）（<a href="https://github.com/lukesampson/scoop/wiki/Buckets#installing-from-other-buckets" target="_blank" rel="noopener">参考</a>）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> scoop bucket add extras</span><br></pre></td></tr></table></figure>



<p>再安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> scoop install conemu</span><br></pre></td></tr></table></figure>




<blockquote>
<p>P.S. 如果安装过程中有错误，需要手动运行命令卸载未安装成功的包。命令如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt;<span class="variable">$</span> scoop uninstall &lt;包名&gt;</span><br></pre></td></tr></table></figure>
<p>卸载后再重新安装</p>
</blockquote>
<h2 id="安装-oh-my-posh"><a href="#安装-oh-my-posh" class="headerlink" title="安装 oh-my-posh"></a>安装 oh-my-posh</h2><p>运行如下命令安装。如果有选项，输入 <strong>Y</strong> 即可</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">Install-Module</span> posh<span class="literal">-git</span> <span class="literal">-Scope</span> CurrentUser</span><br><span class="line"><span class="variable">$</span> <span class="built_in">Install-Module</span> oh<span class="literal">-my</span><span class="literal">-posh</span> <span class="literal">-Scope</span> CurrentUser</span><br></pre></td></tr></table></figure>



<p>更新配置文件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="variable">$PROFILE</span></span><br></pre></td></tr></table></figure>



<p>继续输入</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="keyword">if</span> (!(<span class="built_in">Test-Path</span> <span class="literal">-Path</span> <span class="variable">$PROFILE</span> )) &#123; <span class="built_in">New-Item</span> <span class="literal">-Type</span> File <span class="literal">-Path</span> <span class="variable">$PROFILE</span> <span class="literal">-Force</span> &#125;</span><br><span class="line"><span class="variable">$</span> notepad <span class="variable">$PROFILE</span></span><br></pre></td></tr></table></figure>



<p>在打开的文件中添加：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> posh<span class="literal">-git</span></span><br><span class="line"><span class="built_in">Import-Module</span> oh<span class="literal">-my</span><span class="literal">-posh</span></span><br><span class="line"><span class="built_in">Set-Theme</span> Avit</span><br></pre></td></tr></table></figure>



<p>将配置刷新到终端</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将用户名部分改为你电脑的用户名即可</span></span><br><span class="line"><span class="variable">$</span> C:\Users\&lt;用户名&gt;\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</span><br></pre></td></tr></table></figure>



<h2 id="自定义主题颜色"><a href="#自定义主题颜色" class="headerlink" title="自定义主题颜色"></a>自定义主题颜色</h2><p>参考<a href="https://dev.to/teckert/roll-your-own-color-scheme-in-windows-terminal-466b" target="_blank" rel="noopener">这篇博文</a></p>
]]></content>
      <categories>
        <category>指南</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Terminal</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基础入门</title>
    <url>/2019/12/30/git-ji-chu-ru-men/</url>
    <content><![CDATA[<h1 id="Git-基础入门"><a href="#Git-基础入门" class="headerlink" title="Git 基础入门"></a>Git 基础入门</h1><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/04/yancy-min-842ofHC6MaI-unsplash.jpg" alt="题图"></p>
<h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p>
<h2 id="最小配置"><a href="#最小配置" class="headerlink" title="最小配置"></a>最小配置</h2><h3 id="配置-user-name-和-user-email"><a href="#配置-user-name-和-user-email" class="headerlink" title="配置 user.name 和 user.email"></a>配置 <code>user.name</code> 和 <code>user.email</code></h3><ul>
<li><code>git config</code> 命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name '&lt;用户名&gt;'</span><br><span class="line">git config --global user.email '&lt;电子邮件&gt;'</span><br></pre></td></tr></table></figure>

<ul>
<li>参数简析</li>
</ul>
<table>
<thead>
<tr>
<th align="center">–local</th>
<th align="center">–global</th>
<th align="center">–system</th>
</tr>
</thead>
<tbody><tr>
<td align="center">仅对<strong>某个仓库</strong>有效</td>
<td align="center">对<strong>当前用户</strong>所有仓库有效</td>
<td align="center">对<strong>系统</strong>所有登录的用户有效</td>
</tr>
</tbody></table>
<ul>
<li>显示 <code>config</code> 配置，加上 <code>--list</code>, 如</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --list -- global</span><br></pre></td></tr></table></figure>

<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><h3 id="已有项目纳入-Git-管理"><a href="#已有项目纳入-Git-管理" class="headerlink" title="已有项目纳入 Git 管理"></a>已有项目纳入 Git 管理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &lt;项目根目录&gt;</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<h3 id="新建项目用-Git-管理"><a href="#新建项目用-Git-管理" class="headerlink" title="新建项目用 Git 管理"></a>新建项目用 Git 管理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &lt;某个文件夹&gt;</span><br><span class="line">git init &lt;项目名&gt; # git 会创建与项目名同名的文件夹</span><br><span class="line">cd &lt;项目名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="（可选）配置-local-用户信息"><a href="#（可选）配置-local-用户信息" class="headerlink" title="（可选）配置 local 用户信息"></a>（可选）配置 local 用户信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --local user.name '用户名'</span><br><span class="line">git config --local user.email '电子邮件'</span><br></pre></td></tr></table></figure>

<h2 id="暂存、提交"><a href="#暂存、提交" class="headerlink" title="暂存、提交"></a>暂存、提交</h2><h3 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &lt;待提交的文件&gt;...</span><br></pre></td></tr></table></figure>

<ul>
<li>参数简析</li>
</ul>
<table>
<thead>
<tr>
<th align="center">-u</th>
<th align="center">-A</th>
</tr>
</thead>
<tbody><tr>
<td align="center">语义为 update，即将已经跟踪的文件添加到暂存区</td>
<td align="center">语义为 all，即将所有的文件添加到暂存区</td>
</tr>
</tbody></table>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m '&lt;提交信息&gt;'</span><br></pre></td></tr></table></figure>

<h3 id="其他常用的命令"><a href="#其他常用的命令" class="headerlink" title="其他常用的命令"></a>其他常用的命令</h3><ul>
<li><p><code>git status</code>：git 管理文件状态</p>
</li>
<li><p><code>git log</code>：查看提交记录</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log               # 默认命令（仅显示当前分支）</span><br><span class="line">git log --oneline     # 仅显示历史提交信息</span><br><span class="line">git log -n&lt;数字&gt;       # 显示最近几次提交历史（次数由数字决定）</span><br><span class="line">git log --all         # 查看所有分支log</span><br><span class="line">git log --graph       # 图形化方式显示（log前会有线，分析多分支版本关系常用）</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>gitk</code>：图形化查看提交记录</p>
</li>
<li><p><code>git reset --hard</code>：清空暂存区所有修改</p>
</li>
<li><p><code>git cat-file</code></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git cat-file -t &lt;哈希值&gt;   # 查看对应 哈希值 对应的类型</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git cat-file -p &lt;哈希值&gt;   # 查看对应 哈希值 对应的内容</span><br></pre></td></tr></table></figure>

<ul>
<li><code>git chekout</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout &lt;与当前分支不同的已存在的分支名&gt; # 切换分支</span><br><span class="line">git checkout -b &lt;新分支名&gt; &lt;commitid&gt;     # 检出对应版本，并创建新分支管理</span><br></pre></td></tr></table></figure>

<ul>
<li><code>git branch</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####显示命令#####</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认命令，显示所有分支，并注明当前处于哪个分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="meta">#</span><span class="bash"> 除了默认显示信息，加入了最近一次提交信息</span></span><br><span class="line">git branch -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####创建命令#####</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于当前最新版本，创建新分支</span></span><br><span class="line">git branch &lt;新分支名&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于commitid 或 tag，创建新分支</span></span><br><span class="line">git branch &lt;新分支名&gt; &lt; commitid | tag &gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####删除命令#####</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除对应分支</span></span><br><span class="line">git branch -d &lt;已存在的分支名&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>git diff</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff &lt;commitid1&gt; &lt;commitid2&gt; # 显示两个提交之间的差异</span><br></pre></td></tr></table></figure>


<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="给文件重命名"><a href="#给文件重命名" class="headerlink" title="给文件重命名"></a>给文件重命名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git mv &lt;原文件名&gt; &lt;新文件名&gt;</span><br><span class="line">git commit -m '提交信息'            # 可直接提交，不需通过 add 加入暂存区</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="git-目录解析"><a href="#git-目录解析" class="headerlink" title=".git 目录解析"></a>.git 目录解析</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd .git</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 目录结构（初始）</span></span><br><span class="line">├─hooks</span><br><span class="line">├─info</span><br><span class="line">├─objects</span><br><span class="line">│  ├─info</span><br><span class="line">│  └─pack</span><br><span class="line">└─refs</span><br><span class="line">    ├─heads</span><br><span class="line">    └─tags</span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录结构（有提交后）</span></span><br><span class="line">├─hooks</span><br><span class="line">├─info</span><br><span class="line">├─logs</span><br><span class="line">│  └─refs</span><br><span class="line">│      └─heads</span><br><span class="line">├─objects</span><br><span class="line">│  ├─1b</span><br><span class="line">│  ├─c8</span><br><span class="line">│  ├─dc</span><br><span class="line">│  ├─info</span><br><span class="line">│  └─pack</span><br><span class="line">└─refs</span><br><span class="line">    ├─heads</span><br><span class="line">    └─tags</span><br></pre></td></tr></table></figure>

<h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><ul>
<li><code>HEAD</code> 文件，存储了当前指向哪个分支</li>
<li><code>config</code> 文件：当前项目的配置信息</li>
<li><code>refs/heads</code> 文件夹：存储分支信息<ul>
<li>其中的文件，存储了各分支最新的 <code>commitid</code></li>
</ul>
</li>
<li><code>refs/tags</code> 文件夹：存储标签信息（用于如 <strong>里程碑</strong> 设置）<ul>
<li>其中的文件，存储了各标签对应的 <code>commitid</code></li>
</ul>
</li>
<li><code>objects</code> 文件夹：无含义的文件夹名和对应文件夹下的文件名拼接，形成哈希值，利用  <code>git cat-file</code> 可查看对应的信息。</li>
</ul>
<h3 id="commit、tree、blob-对象之间的关系"><a href="#commit、tree、blob-对象之间的关系" class="headerlink" title="commit、tree、blob 对象之间的关系"></a>commit、tree、blob 对象之间的关系</h3><ul>
<li>每个 <strong>commit</strong> 对应一颗 <strong>tree</strong></li>
<li><strong>tree</strong> 指明了当前 <strong>commit</strong> 的文件目录结构。 <strong>tree</strong> 中可包含 <strong>tree</strong> 和 <strong>blob</strong></li>
<li><strong>blob</strong> 代表文件</li>
</ul>
<h3 id="潜在错误：分离头指针"><a href="#潜在错误：分离头指针" class="headerlink" title="潜在错误：分离头指针"></a>潜在错误：分离头指针</h3><ul>
<li>输入如下命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout &lt;哈希值&gt;    # 分离头指针（这个分支没有被 git 管理）</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果在这个基础上 <code>commit</code> ，之后切换分支时，这些 <code>commit</code> 会丢失。</p>
</li>
<li><p>补救措施</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch &lt;新分支名&gt; &lt;commitid&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>建议：检出某个版本时，推荐用新的分支管理</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;新分支名&gt; &lt;commitid&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>版本控制</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>MIPS指令系统简易入门</title>
    <url>/2019/11/12/mips-zhi-ling-xi-tong-jian-yi-ru-men/</url>
    <content><![CDATA[<h1 id="MIPS-指令系统"><a href="#MIPS-指令系统" class="headerlink" title="MIPS 指令系统"></a>MIPS 指令系统</h1><h2 id="MIPS指令中数据的表示"><a href="#MIPS指令中数据的表示" class="headerlink" title="MIPS指令中数据的表示"></a>MIPS指令中数据的表示</h2><ul>
<li>提供 32 个通用寄存器</li>
<li>大端存储</li>
<li>只能通过 Load / Store 指令访问存储器数据</li>
</ul>
<h2 id="MIPS-指令格式和寻址方式"><a href="#MIPS-指令格式和寻址方式" class="headerlink" title="MIPS 指令格式和寻址方式"></a>MIPS 指令格式和寻址方式</h2><h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><ul>
<li>所有指令都是 32 位宽，需按字地址对齐，字地址为 4 的倍数</li>
<li>R- Type（RR 型指令）<ul>
<li>寻址方式：<strong>寄存器寻址</strong></li>
<li>若是双目运算类指令，则 rs 和 rt 的内容分别作为第一和第二源操作数，结果送 rd；</li>
<li>若是移位指令，则对 rt 的内容进行移位，结果送 rd ，所移位数由 shamt 字段给出</li>
<li>指令格式如下：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">OP</th>
<th align="center">rs</th>
<th align="center">rt</th>
<th align="center">rd</th>
<th align="center">shamt</th>
<th align="center">func</th>
</tr>
</thead>
<tbody><tr>
<td align="center">操作码：000000（6 个 0）（31-26：<strong>6位</strong>）</td>
<td align="center">第一源操作数（25-21：<strong>5位</strong>）</td>
<td align="center">第二源操作数（20-16：<strong>5位</strong>）</td>
<td align="center">存储结果（15-11：<strong>5位</strong>）</td>
<td align="center">移位指令位移量（10-6：<strong>5位</strong>）</td>
<td align="center">操作类型（如 sub add等）（5-0：<strong>6位</strong>）</td>
</tr>
</tbody></table>
<ul>
<li>I-Type（立即数型指令）<ul>
<li>寻址方式：寄存器寻址、立即数寻址、相对寻址、基址寻址、变址寻址</li>
<li>若是双目运算类指令，则将 rs 的内容和立即数分别作为第一和第二源操作数，结果送 rt</li>
<li>若是 Load/Store 指令，则将 rs 的内容和立即数符号扩展后的内容相加作为内存单元地址，Load 指令将内存单元内容送 rt， Store 指令将 rt 内容送内存</li>
<li>若是条件转移（分支）指令，则对 rs 和 rt 内容进行指定运算，根据运算结果决定是否转到转移目标地址处执行。（转移目标地址通过相对寻址方式得到，即将 PC 的内容和立即数符号扩展后的内容相加得到）</li>
<li>指令格式如下</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">OP</th>
<th align="center">rs</th>
<th align="center">rt</th>
<th align="center">立即数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">操作码（31-26：<strong>6位</strong>）</td>
<td align="center">第一源操作数（25-21：<strong>5 位</strong>）</td>
<td align="center">存储结果（20-16：<strong>5 位</strong>）</td>
<td align="center">第二源操作数（15-0：<strong>16位</strong>）</td>
</tr>
</tbody></table>
<ul>
<li>J-Type（无条件跳转指令）<ul>
<li>寻址方式：变通的直接寻址</li>
<li>将当前 PC 的高 4 位拼上 26 位直接地址，最后添上两个 0 ，即得到 32 位的跳转目标地址</li>
<li>指令格式如下</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">OP</th>
<th align="center">直接地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">操作码：000010 或 000011（31-26：<strong>6 位</strong>）</td>
<td align="center">（25-0：<strong>26 位</strong>）</td>
</tr>
</tbody></table>
<ul>
<li>注： <strong>MIPS 中寻址方式由指令格式来确定，而指令格式由 op 来确定</strong>（6 位全 0 为 R 型；6 位 低三位为 010 或 011 为 J 型；剩余为 I 型）</li>
</ul>
<h2 id="MIPS-汇编语言"><a href="#MIPS-汇编语言" class="headerlink" title="MIPS 汇编语言"></a>MIPS 汇编语言</h2><table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">指令名称</th>
<th align="center">汇编举例</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>算数运算</strong></td>
<td align="center">add</td>
<td align="center">add s1, s2, s3</td>
<td align="center">s1 = s2 + s3</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">subtract</td>
<td align="center">subtract s1, s2, s3</td>
<td align="center">s1 = s2 - s3</td>
</tr>
<tr>
<td align="center"><strong>存储访问</strong></td>
<td align="center">load word</td>
<td align="center">lw s1, 100( 2 )</td>
<td align="center">s1 = Memory[s2 + 100]</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">store word</td>
<td align="center">sw s1, 100( 2 )</td>
<td align="center">Memory[s2 + 100] = s1</td>
</tr>
<tr>
<td align="center"><strong>逻辑运算</strong></td>
<td align="center">and</td>
<td align="center">and s1, s2, s3</td>
<td align="center">s1 = s2 &amp; s3</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">or</td>
<td align="center">or s1, s2, s3</td>
<td align="center">s1 = s2 $</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">nor</td>
<td align="center">nor s1, s2, s3</td>
<td align="center">s1 = ~(s2 $</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">and immediate</td>
<td align="center">andi s1, s2, 100</td>
<td align="center">s1 = s2 &amp; 100</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">or immediate</td>
<td align="center">ori s1, s2, 100</td>
<td align="center">s1 = s2 $</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">shift left logical</td>
<td align="center">sll s1, s2, 10</td>
<td align="center">s1 = s2 &lt;&lt; 10</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">shift right logical</td>
<td align="center">srl s1, s2, 10</td>
<td align="center">s1 = s2 &gt;&gt; 10</td>
</tr>
<tr>
<td align="center"><strong>条件分支</strong></td>
<td align="center">branch on equal</td>
<td align="center">beq s1, s2, L</td>
<td align="center">if(s1 == s2)    goto L</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">branch on not equal</td>
<td align="center">bne s1, s2, L</td>
<td align="center">if(s1 != s2)    goto L</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">set on less than</td>
<td align="center">slt s1, s2, s3</td>
<td align="center">if(s2 &lt; s3)    s1 = 1;     else    s1 = 0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">set on less than immediate</td>
<td align="center">slti s1, s2, 100</td>
<td align="center">if(s2 &lt; 100)    s1 = 1;     else    s1 = 0</td>
</tr>
<tr>
<td align="center"><strong>无条件跳转</strong></td>
<td align="center">jump</td>
<td align="center">j L</td>
<td align="center">goto L</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">jump register</td>
<td align="center">j ra</td>
<td align="center">goto ra</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">jump and link</td>
<td align="center">jal L</td>
<td align="center">ra = PC + 4; goto L（为什么加 4 因为每条指令 32 位【4 个字节】）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理复习笔记7-输入输出组织</title>
    <url>/2019/10/15/ji-suan-ji-zu-cheng-yuan-li-fu-xi-bi-ji-7-shu-ru-shu-chu-zu-zhi/</url>
    <content><![CDATA[<h1 id="7．输入输出组织"><a href="#7．输入输出组织" class="headerlink" title="7．输入输出组织"></a>7．输入输出组织</h1><h2 id="（×）I-O系统基本概念"><a href="#（×）I-O系统基本概念" class="headerlink" title="（×）I/O系统基本概念"></a>（×）I/O系统基本概念</h2><p>（详见教材） </p>
<h2 id="（★）常见外部设备"><a href="#（★）常见外部设备" class="headerlink" title="（★）常见外部设备"></a>（★）常见外部设备</h2><h3 id="常见外部设备及其工作原理"><a href="#常见外部设备及其工作原理" class="headerlink" title="常见外部设备及其工作原理"></a>常见外部设备及其工作原理</h3><p>（详见教材）</p>
<h3 id="部分外部设备的性能指标"><a href="#部分外部设备的性能指标" class="headerlink" title="部分外部设备的性能指标"></a>部分外部设备的性能指标</h3><h4 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h4><ul>
<li>$VRAM\ 容量 = 分辨率\times 灰度级位数$</li>
<li>$VRAM\ 带宽 =分辨率\times 灰度级位数\times 帧频$</li>
</ul>
<h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><ul>
<li><p>外存容量：$面数\times 磁道数\times 道容量$</p>
<ul>
<li>其中，<ul>
<li>$面数=2n-2$ ，n 为磁盘片数</li>
<li>$磁道数=\frac{道密度\times (D外-D内)}{2}$ ，D 为直径</li>
<li>$道容量=\pi D\times 位密度$</li>
</ul>
</li>
</ul>
</li>
<li><p>（★★★★★★）存取速度（数据传输率）：$v=道容量\times 转速$</p>
</li>
<li><p>（★★★★★★）存取时间</p>
<ul>
<li>$T存取时间=T找道+T找扇区+T数据传输​$<br>$$<br>T_{找道}=\frac{T_{max}-T_{min}}{2}\ T_{max}为最长找道时间，T_{min}为最短找道时间<br>$$</li>
</ul>
</li>
</ul>
<p>$$<br>T_{找扇区}=\frac{0+\frac{1}{n}}{2}\ n为转速<br>$$</p>
<p>$$<br>T_{数据传输时间}=L\times \frac{1}{v}\ L为数据量大小，v为数据传输率<br>$$</p>
<h2 id="（★）I-O-接口"><a href="#（★）I-O-接口" class="headerlink" title="（★）I/O 接口"></a>（★）I/O 接口</h2><h3 id="功能及基本结构"><a href="#功能及基本结构" class="headerlink" title="功能及基本结构"></a>功能及基本结构</h3><ul>
<li><p>功能</p>
<ul>
<li>实现<strong>主机和外设的通信</strong>联络控制</li>
<li>进行<strong>地址译码</strong>和<strong>设备选择</strong></li>
<li><strong>数据缓冲</strong></li>
<li><strong>信号格式转换</strong>（如串并转换）</li>
<li><strong>传送控制命令和状态信息</strong></li>
</ul>
</li>
<li><p>基本结构</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/10/15/IO-Interface.png?raw=true" alt="I/O接口基本结构"></p>
</li>
</ul>
<h3 id="I-O-端口及其编址"><a href="#I-O-端口及其编址" class="headerlink" title="I/O 端口及其编址"></a>I/O 端口及其编址</h3><ul>
<li><strong>I/O 端口</strong>是指接口电路中可被 CPU 直接访问的<strong>寄存器</strong>，主要有<strong>数据端口</strong>、<strong>状态端口</strong>和<strong>控制端口</strong></li>
<li><strong>I/O 端口</strong>和<strong>I/O 接口</strong>的关系：$I/O\ 端口 + 相应控制逻辑电路\overset{组成}{=} I/O\ 接口$</li>
<li>I/O 端口编址方式<ul>
<li>统一编址</li>
<li>独立编址</li>
</ul>
</li>
</ul>
<h2 id="（★★★）I-O的三种控制方式"><a href="#（★★★）I-O的三种控制方式" class="headerlink" title="（★★★）I/O的三种控制方式"></a>（★★★）I/O的三种控制方式</h2><p><a href="https://cosmosning.github.io/2019/09/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B04-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/">回看操作系统相关知识</a></p>
<h3 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/10/15/Prog-Query.png?raw=true" alt="I/O接口基本结构"></p>
<h3 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h3><h4 id="中断的基本概念"><a href="#中断的基本概念" class="headerlink" title="中断的基本概念"></a>中断的基本概念</h4><p>（详见教材）</p>
<h4 id="中断工作流程"><a href="#中断工作流程" class="headerlink" title="中断工作流程"></a>中断工作流程</h4><h5 id="中断响应（中断隐指令，硬件完成）"><a href="#中断响应（中断隐指令，硬件完成）" class="headerlink" title="中断响应（中断隐指令，硬件完成）"></a>中断响应（中断隐指令，硬件完成）</h5><ul>
<li>响应中断的 3 个条件<ol>
<li>CPU 处于 “开中断” 状态</li>
<li>至少要有一个未被屏蔽的中断请求</li>
<li>当前指令执行完</li>
</ol>
</li>
<li>中断响应周期中完成以下几个操作<ol>
<li><strong>关中断</strong>（将中断允许标志为“禁止”）</li>
<li><strong>保存断点</strong></li>
<li><strong>识别中断源并转中断服务程序</strong></li>
</ol>
</li>
</ul>
<h5 id="中断执行（中断程序完成）"><a href="#中断执行（中断程序完成）" class="headerlink" title="中断执行（中断程序完成）"></a>中断执行（中断程序完成）</h5><ul>
<li>接着中断响应周期的操作<ol>
<li><strong>保存现场和屏蔽字</strong></li>
<li><strong>开中断</strong></li>
<li><strong>执行中断服务程序</strong></li>
<li><strong>关中断</strong></li>
<li><strong>恢复现场和屏蔽字</strong></li>
<li><strong>开中断、中断返回</strong></li>
</ol>
</li>
</ul>
<h4 id="多重中断和中断屏蔽"><a href="#多重中断和中断屏蔽" class="headerlink" title="多重中断和中断屏蔽"></a>多重中断和中断屏蔽</h4><ul>
<li>多重中断：中断内可以嵌套中断</li>
<li>中断屏蔽（见后解题技巧及重要结论中的总结）</li>
</ul>
<h3 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h3><h4 id="DMA-控制器的组成"><a href="#DMA-控制器的组成" class="headerlink" title="DMA 控制器的组成"></a>DMA 控制器的组成</h4><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/10/15/DMA-Controller.png?raw=true" alt="I/O接口基本结构"></p>
<h4 id="DMA-的传送过程"><a href="#DMA-的传送过程" class="headerlink" title="DMA 的传送过程"></a>DMA 的传送过程</h4><p>DMA 传送过程主要分为三步</p>
<ol>
<li>预处理<ul>
<li>准备内存区</li>
<li>设置传送参数</li>
<li>发送“启动 DMA ”命令，然后调度 CPU 执行其他进程</li>
</ul>
</li>
<li>数据传送<ul>
<li>整个数据传送过程由 DMA 单独完成</li>
</ul>
</li>
<li>后处理<ul>
<li>数据传输完成后，DMA 发出“ DMA 结束”给 CPU，转入中断服务程序，做一些数据校验等后处理工作</li>
</ul>
</li>
</ol>
<h1 id="解题技巧及重要结论"><a href="#解题技巧及重要结论" class="headerlink" title="解题技巧及重要结论"></a>解题技巧及重要结论</h1><ul>
<li><p>显示器中的相关计算公式补充</p>
<ul>
<li>$n=log_2(m)$ ，其中，m 为颜色数，n 为刷新存储器中存储单元的字长</li>
</ul>
</li>
<li><p>磁盘相关计算公式补充</p>
<ul>
<li>$数据传输率=转速(单位：*/s)\times 每个磁道的扇区数\times每个扇区上的数据量$</li>
</ul>
</li>
<li><p>中断优先级和屏蔽字的相互确定</p>
<ul>
<li>依据优先级确定屏蔽字：依据优先级，某一级中断只能<strong>屏蔽自己及比自己低优先级</strong>的中断，故中断屏蔽字对应位数取 1 ，其他位取 0 。</li>
<li>依据屏蔽字确定优先级：<strong>比</strong>屏蔽字的<strong>二进制数据大小</strong>，大的优先级高</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>计算机组成与系统结构.袁春风等</li>
<li>2020年计算机组成原理考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理复习笔记6-系统总线</title>
    <url>/2019/10/13/ji-suan-ji-zu-cheng-yuan-li-fu-xi-bi-ji-6-xi-tong-zong-xian/</url>
    <content><![CDATA[<h1 id="6．-系统总线"><a href="#6．-系统总线" class="headerlink" title="6． 系统总线"></a>6． 系统总线</h1><h2 id="（×）总线概述：识记总线的基本概念，分类，总线的组成及性能指标；"><a href="#（×）总线概述：识记总线的基本概念，分类，总线的组成及性能指标；" class="headerlink" title="（×）总线概述：识记总线的基本概念，分类，总线的组成及性能指标；"></a>（×）总线概述：识记总线的基本概念，分类，总线的组成及性能指标；</h2><p>（详见教材）</p>
<h2 id="（★★）总线仲裁的仲裁方式以及各自的工作原理；"><a href="#（★★）总线仲裁的仲裁方式以及各自的工作原理；" class="headerlink" title="（★★）总线仲裁的仲裁方式以及各自的工作原理；"></a>（★★）总线仲裁的仲裁方式以及各自的工作原理；</h2><h3 id="集中仲裁"><a href="#集中仲裁" class="headerlink" title="集中仲裁"></a>集中仲裁</h3><table>
<thead>
<tr>
<th align="center">对比项目</th>
<th align="center">链式查询</th>
<th align="center">计数器定时查询</th>
<th align="center">独立请求</th>
</tr>
</thead>
<tbody><tr>
<td align="center">工作原理</td>
<td align="center">离总线控制部件距离越近，优先级越高</td>
<td align="center">优先级由计数器设置</td>
<td align="center">每个设备都有一条连接总线控制部件的请求线</td>
</tr>
<tr>
<td align="center">控制线数</td>
<td align="center"><strong>3</strong>（总线请求 <strong>BR</strong> ：1；总线忙 <strong>BS</strong> ：1；总线允许 <strong>BG</strong> ：1）</td>
<td align="center">$\lceil log_2n\rceil+2$（总线请求 <strong>BR</strong> ：1；总线忙 <strong>BS</strong> ：1；总线允许 <strong>BG</strong> ：$\lceil log_2n\rceil$）</td>
<td align="center"><strong>2n+1</strong>（总线请求 <strong>BR</strong> ：n；总线忙 <strong>BS</strong> ：n；总线允许 <strong>BG</strong> ：1）</td>
</tr>
<tr>
<td align="center">优点</td>
<td align="center">优先级固定；结构简单；扩充容易</td>
<td align="center">优先级灵活</td>
<td align="center">响应速度块；优先级灵活</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">对电路故障敏感，优先级不灵活</td>
<td align="center">控制线多；控制复杂</td>
<td align="center">控制线多；控制复杂</td>
</tr>
</tbody></table>
<h3 id="分布仲裁"><a href="#分布仲裁" class="headerlink" title="分布仲裁"></a>分布仲裁</h3><p>（详见王道）</p>
<h2 id="（★★）总线操作和定时方式以及原理；"><a href="#（★★）总线操作和定时方式以及原理；" class="headerlink" title="（★★）总线操作和定时方式以及原理；"></a>（★★）总线操作和定时方式以及原理；</h2><h3 id="总线周期的-4-个阶段"><a href="#总线周期的-4-个阶段" class="headerlink" title="总线周期的 4 个阶段"></a>总线周期的 4 个阶段</h3><h3 id="定时方式"><a href="#定时方式" class="headerlink" title="定时方式"></a>定时方式</h3><ul>
<li>同步<ul>
<li>采用<strong>统一的时钟信号</strong>来协调发送和接收双方传送定时关系</li>
</ul>
</li>
<li>异步<ul>
<li>不互锁</li>
<li>半互锁</li>
<li>全互锁</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/10/13/Bus-Timing.png?raw=true" alt="异步请求回答信号的互锁"></p>
<h2 id="（×）总线标准，常用标准所规定的机械结构、功能结构和电气规范；"><a href="#（×）总线标准，常用标准所规定的机械结构、功能结构和电气规范；" class="headerlink" title="（×）总线标准，常用标准所规定的机械结构、功能结构和电气规范；"></a>（×）总线标准，常用标准所规定的机械结构、功能结构和电气规范；</h2><p>（详见教材）</p>
<h1 id="解题技巧及重要结论"><a href="#解题技巧及重要结论" class="headerlink" title="解题技巧及重要结论"></a>解题技巧及重要结论</h1><ul>
<li>有关总线性能的一些概念<ul>
<li>总线的<strong>时间周期</strong>：即<strong>机器的时钟周期</strong>。</li>
<li>总线的<strong>工作频率</strong>：总线周期的倒数。指<strong>1秒内传送几次数据</strong>。<ul>
<li>若$总线时间周期=N个时钟周期$，那么总线的工作频率为 $\frac{时钟频率}{N}$</li>
</ul>
</li>
<li><strong>总线宽度</strong>：又称<strong>总线位宽</strong>，它是总线上同时能够传输的数据位数，通常指<strong>数据总线的根数</strong></li>
<li>总线<strong>带宽</strong>：总线的数据传输率，单位时间内总线上可传输数据的位数。<ul>
<li>公式：$总线带宽=\frac{总线周期中传输的数据量(单位：B)}{总线周期(单位：s)}=总线工作频率\times \frac{总线宽度}{8}$</li>
<li>单位：B/s、KB/s 等</li>
</ul>
</li>
<li>例题：<ul>
<li>（2012 · 408）某同步总线的时钟频率为 100 MHz ，宽度为 32 位，地址/数据线复用，每传输一个地址或数据占用一个时钟周期。若该总线支持突发传输方式，则一次“主存写”总线事务传输 128 位数据所需要的时间至少是</li>
<li>分析：<ul>
<li>这里计算的时间包括两个部分：<strong>传输地址</strong>的时间和<strong>传输数据的时间</strong></li>
<li>带宽为 100 M × 32 bit = 3200 Mbit/s</li>
<li>所以，</li>
<li>传输 32 位地址需要 10 ns （32 / (3200 M)）</li>
<li>传输 128 位数据需要 40 ns （128/ (3200 M)）</li>
<li>总时间为 50 ns</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>计算机组成与系统结构.袁春风等</li>
<li>2020年计算机组成原理考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理复习笔记5-中央处理器</title>
    <url>/2019/10/11/ji-suan-ji-zu-cheng-yuan-li-fu-xi-bi-ji-5-zhong-yang-chu-li-qi/</url>
    <content><![CDATA[<h1 id="5．中央处理器"><a href="#5．中央处理器" class="headerlink" title="5．中央处理器"></a>5．中央处理器</h1><h2 id="（★★★）指令的执行过程"><a href="#（★★★）指令的执行过程" class="headerlink" title="（★★★）指令的执行过程"></a>（★★★）指令的执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ul>
<li>一个指令周期包括四个部分，从前到后分别是<ul>
<li>取指周期：取指令</li>
<li>间址周期（可无）：取操作数的有效地址</li>
<li>执行周期：执行指令</li>
<li>中断周期（可无）：处理中断请求</li>
</ul>
</li>
</ul>
<h3 id="指令周期的数据流及对应微操作"><a href="#指令周期的数据流及对应微操作" class="headerlink" title="指令周期的数据流及对应微操作"></a>指令周期的数据流及对应微操作</h3><h4 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h4><ul>
<li>数据流</li>
</ul>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">数据流</th>
<th align="center">解释说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">PC $\rightarrow$ MAR $\rightarrow$ 地址总线 $\rightarrow$ 主存</td>
<td align="center">PC 中的地址送入主存</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">CU发出控制信号 $\rightarrow$ 控制总线 $\rightarrow$ 主存</td>
<td align="center">CU 向主存发出控制信号</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">主存 $\rightarrow$ 数据总线 $\rightarrow$ MDR $\rightarrow$ IR</td>
<td align="center">主存将指定地址的<strong>指令</strong>送入 IR 寄存器</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">CU发出读命令 $\rightarrow$ PC 内容加 1</td>
<td align="center">PC 自增</td>
</tr>
</tbody></table>
<ul>
<li>微操作</li>
</ul>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">微操作</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">PC $\rightarrow$ MAR</td>
<td align="center">将现行指令地址送入 MAR</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1 $\rightarrow$ R</td>
<td align="center">命令存储器读</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">M( MAR ) $\rightarrow$ MDR</td>
<td align="center">现行指令从存储器中读至 MDR</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">MDR $\rightarrow$ IR</td>
<td align="center">现行<strong>指令</strong>送入 IR</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">OP( IR ) $\rightarrow$ CU</td>
<td align="center">指令操作码送入 CU 译码</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">( PC ) + 1 $\rightarrow$ PC</td>
<td align="center">形成下一条指令的地址</td>
</tr>
</tbody></table>
<p>（★）小总结：主存 和 CPU 的数据交互总是经过<strong>总线</strong>和<strong>相应的寄存器</strong></p>
<h4 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h4><ul>
<li>数据流</li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>数据流</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Ad( IR )  $\rightarrow$ MAR $\rightarrow​$ 地址总线 $\rightarrow​$ 主存</td>
<td>IR 中指令的地址码部分送入主存</td>
</tr>
<tr>
<td>2</td>
<td>CU发出读命令 $\rightarrow$ 控制总线 $\rightarrow$ 主存</td>
<td>CU 向主存发出控制信号</td>
</tr>
<tr>
<td>3</td>
<td>主存 $\rightarrow$ 数据总线 $\rightarrow$ MDR</td>
<td>主存将指定地址的<strong>有效地址</strong>送入 MDR 寄存器</td>
</tr>
</tbody></table>
<ul>
<li>微操作</li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>微操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Ad( IR ) $\rightarrow$ MAR</td>
<td>将指令字的地址码（形式地址）部分送入 MAR</td>
</tr>
<tr>
<td>2</td>
<td>1 $\rightarrow$ R</td>
<td>命令存储器读</td>
</tr>
<tr>
<td>3</td>
<td>M( MAR ) $\rightarrow$ MDR</td>
<td>将<strong>有效地址</strong>从存储器中读至 MDR</td>
</tr>
</tbody></table>
<h4 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h4><ul>
<li><p>数据流（具体指令具体分析）</p>
</li>
<li><p>微操作（具体指令具体分析）</p>
</li>
</ul>
<h4 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h4><ul>
<li>数据流</li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>数据流</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>CU 控制将 SP 减 1 $\rightarrow$ MAR $\rightarrow$ 地址总线 $\rightarrow$ 主存</td>
<td>将栈顶指针送入主存</td>
</tr>
<tr>
<td>2</td>
<td>CU发出写命令 $\rightarrow$ 控制总线 $\rightarrow​$ 主存</td>
<td>CU 向主存发出控制信号</td>
</tr>
<tr>
<td>3</td>
<td>PC $\rightarrow$ MDR  $\rightarrow$ 数据总线 $\rightarrow$ 主存</td>
<td>保存断点到主存</td>
</tr>
<tr>
<td>4</td>
<td>CU ( 中断服务程序的入口地址 )$\rightarrow$  PC</td>
<td>将中断服务程序的入口地址送入 PC</td>
</tr>
</tbody></table>
<h2 id="（★★）数据通路及控制器"><a href="#（★★）数据通路及控制器" class="headerlink" title="（★★）数据通路及控制器"></a>（★★）数据通路及控制器</h2><p>（详见教材）</p>
<h2 id="（★★）异常与中断"><a href="#（★★）异常与中断" class="headerlink" title="（★★）异常与中断"></a>（★★）异常与中断</h2><p>（详见教材）</p>
<h1 id="解题技巧及重要结论"><a href="#解题技巧及重要结论" class="headerlink" title="解题技巧及重要结论"></a>解题技巧及重要结论</h1><ul>
<li>几个概念的关系<ul>
<li>指令与微程序<strong>一一对应</strong></li>
<li>微程序由<strong>多条</strong>微指令</li>
<li>每条微指令中又有<strong>多条</strong>微操作</li>
</ul>
</li>
<li>若指令系统中，具有 <strong>n</strong> 种机器指令，则控制存储器中的微程序数量至少为 <strong>n + 2</strong> （ 2 的含义：1 条公共取指，1 条处理中断）</li>
<li>指令流水线中的计算<ul>
<li>吞吐率<ul>
<li>基本公式<ul>
<li>$TP=\frac{n}{T_k}$ ，<ul>
<li>$n$ 为任务数，$T_k$ 是完成 $n$ 个任务所花费的时间</li>
</ul>
</li>
</ul>
</li>
<li>当流水线各段处理时间相等时，进一步有<ul>
<li>$TP=\frac{n}{(k+n-1)\Delta t}​$<ul>
<li>k 级流水线，$\Delta t$ 为时钟周期</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>加速比<ul>
<li>基本公式<ul>
<li>$S=\frac{T_0}{T_k}$</li>
</ul>
</li>
<li>当流水线各段处理时间相等时，进一步有<ul>
<li>$S=\frac{kn\Delta t}{(k+n-1)\Delta t}=\frac{kn}{k+n-1}$</li>
</ul>
</li>
</ul>
</li>
<li>流水线效率<ul>
<li>$E=\frac{T_0}{kT_k}$<ul>
<li>$T_0$ 为顺序执行 $n$ 个任务所用的总时间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>依据各段指令的时间，确定时钟周期：选各段指令的时间<strong>最大的</strong></li>
<li>超标量流水线的含义：指的是 CPU 中存在<strong>一条以上</strong>的流水线，在<strong>每个时钟周期</strong>内可以完成<strong>一条以上</strong>的指令（空间换时间）</li>
<li>单流水线处理机（度为 1 ）和超标量流水线（度为 d）的多条指令连续执行的时间计算问题<ul>
<li>利用公式 $T_k=(k+n-1)\Delta t$ ，其中 k 级流水线，n 为指令条数， $\Delta t$ 为时钟周期</li>
<li>注意：超标量中<strong>指令条数要除以度数</strong>，再带入公式计算</li>
</ul>
</li>
<li>影响流水线的因素<ul>
<li>结构相关（资源冲突）<ul>
<li>多条指令同一时间竞争统一资源</li>
<li>解决方案<ul>
<li>前一条使用时，后一条等待一个时钟周期</li>
<li>设置更多的相关资源</li>
</ul>
</li>
</ul>
</li>
<li>数据相关（数据冲突）<ul>
<li>后一条指令需要前一条指令执行完毕才能执行（比如说后一条指令需要前一条指令计算的结果）</li>
<li>解决方案<ul>
<li>后一条指令中插入 NOP 操作，等待前一条指令执行完成</li>
<li>设置数据旁路</li>
<li>编译优化，调整指令顺序</li>
</ul>
</li>
</ul>
</li>
<li>控制相关（控制冲突）<ul>
<li>指令跳转时，导致流水线断流</li>
<li>解决方案<ul>
<li>分支预测</li>
<li>等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>计算机组成与系统结构.袁春风等</li>
<li>2020年计算机组成原理考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理复习笔记4-指令系统</title>
    <url>/2019/10/10/ji-suan-ji-zu-cheng-yuan-li-fu-xi-bi-ji-4-zhi-ling-xi-tong/</url>
    <content><![CDATA[<h1 id="4．指令系统"><a href="#4．指令系统" class="headerlink" title="4．指令系统"></a>4．指令系统</h1><h2 id="（★★★）指令格式"><a href="#（★★★）指令格式" class="headerlink" title="（★★★）指令格式"></a>（★★★）指令格式</h2><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><h4 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h4><ul>
<li>格式</li>
</ul>
<table>
<thead>
<tr>
<th align="center">OP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">操作码</td>
</tr>
</tbody></table>
<ul>
<li>举例<ul>
<li>空操作指令、停机指令等<strong>不需要操作数</strong>的指令</li>
<li><strong>操作数隐含</strong>的指令（操作数及运算结果保存在<strong>堆栈</strong>中）</li>
</ul>
</li>
</ul>
<h4 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h4><ul>
<li>格式</li>
</ul>
<table>
<thead>
<tr>
<th align="center">OP</th>
<th align="center">A1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">操作码</td>
<td align="center">操作数地址</td>
</tr>
</tbody></table>
<ul>
<li>指令含义：$OP(A_1)\rightarrow A_1$</li>
<li>举例<ul>
<li><strong>单目</strong>操作指令（即只需要一个操作数的指令，且运算结果保存在原位置，如<strong>自增1</strong>、<strong>求反</strong>等）</li>
<li><strong>双目</strong>操作指令，但一个操作数<strong>隐含</strong>（比如存放在 ACC 中）</li>
</ul>
</li>
</ul>
<h4 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h4><ul>
<li>格式</li>
</ul>
<table>
<thead>
<tr>
<th align="center">OP</th>
<th align="center">A1</th>
<th align="center">A2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">操作码</td>
<td align="center">操作数地址 1</td>
<td align="center">操作数地址 2</td>
</tr>
</tbody></table>
<ul>
<li>指令含义： $(A_1)OP(A_2)\rightarrow A_1$</li>
</ul>
<h4 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h4><ul>
<li>格式</li>
</ul>
<table>
<thead>
<tr>
<th align="center">OP</th>
<th align="center">A1</th>
<th align="center">A2</th>
<th align="center">A3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">操作码</td>
<td align="center">操作数地址 1</td>
<td align="center">操作数地址 2</td>
<td align="center">运算<strong>结果</strong>存放地址</td>
</tr>
</tbody></table>
<ul>
<li>指令含义： $(A_1)OP(A_2)\rightarrow (A_3)$</li>
</ul>
<h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><ul>
<li>格式</li>
</ul>
<table>
<thead>
<tr>
<th align="center">OP</th>
<th align="center">A1</th>
<th align="center">A2</th>
<th align="center">A3</th>
<th align="center">A4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">操作码</td>
<td align="center">操作数地址 1</td>
<td align="center">操作数地址 2</td>
<td align="center">运算<strong>结果</strong>存放地址</td>
<td align="center">下址（下一条指令的地址）</td>
</tr>
</tbody></table>
<ul>
<li>指令含义： $(A_1)OP(A_2)\rightarrow (A_3)$ ， $A_4=下一条指令地址$</li>
</ul>
<h3 id="定长操作码和扩展操作码的优缺点对比"><a href="#定长操作码和扩展操作码的优缺点对比" class="headerlink" title="定长操作码和扩展操作码的优缺点对比"></a>定长操作码和扩展操作码的优缺点对比</h3><ul>
<li>定长操作码：指令操作码的位数固定<ul>
<li>译码方便、指令执行速度快</li>
<li>有信息冗余</li>
</ul>
</li>
<li>扩展操作码：指令操作码的位数不固定<ul>
<li>设计灵活，能容纳更多的指令</li>
<li>译码麻烦</li>
</ul>
</li>
</ul>
<h3 id="采用扩展操作码方式指令数目的计算及设计"><a href="#采用扩展操作码方式指令数目的计算及设计" class="headerlink" title="采用扩展操作码方式指令数目的计算及设计"></a>采用扩展操作码方式指令数目的计算及设计</h3><ul>
<li>思路<ul>
<li>从含<strong>操作数地址最多</strong>的开始计算：由<strong>操作数地址位数</strong>和<strong>指令类型</strong>（几地址指令），确定操作码的位数，这个位数所能表示的最大数字 - 1 ，即为该类型指令的最大指令数</li>
<li>以此类推</li>
<li>P.S. 若根据题意，若高位地址设计指令未用完，可用于设计下一级指令（指令条数相乘即可）</li>
</ul>
</li>
</ul>
<h2 id="（★★）指令的寻址方式"><a href="#（★★）指令的寻址方式" class="headerlink" title="（★★）指令的寻址方式"></a>（★★）指令的寻址方式</h2><h3 id="有效地址的概念"><a href="#有效地址的概念" class="headerlink" title="有效地址的概念"></a>有效地址的概念</h3><p>（详见教材）</p>
<h3 id="数据寻址和指令寻址"><a href="#数据寻址和指令寻址" class="headerlink" title="数据寻址和指令寻址"></a>数据寻址和指令寻址</h3><h4 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h4><ul>
<li>一般格式</li>
</ul>
<table>
<thead>
<tr>
<th align="center">操作码</th>
<th align="center">寻址特征</th>
<th align="center">形式地址 A</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h4><ul>
<li>顺序寻址：PC 自增实现</li>
<li>跳跃寻址：由转移类指令实现</li>
</ul>
<h3 id="常见寻址方式及寻址过程"><a href="#常见寻址方式及寻址过程" class="headerlink" title="常见寻址方式及寻址过程"></a>常见寻址方式及寻址过程</h3><table>
<thead>
<tr>
<th align="center">寻址方式</th>
<th align="center">有效地址</th>
<th align="center">访存次数（不含取本条指令而访存）</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">隐含寻址</td>
<td align="center">程序指定</td>
<td align="center">0</td>
<td></td>
</tr>
<tr>
<td align="center">立即寻址</td>
<td align="center">A 即是操作数</td>
<td align="center">0</td>
<td></td>
</tr>
<tr>
<td align="center">直接寻址</td>
<td align="center">EA = A</td>
<td align="center">1</td>
<td></td>
</tr>
<tr>
<td align="center">一次间接间接寻址</td>
<td align="center">EA = ( A )</td>
<td align="center">2</td>
<td></td>
</tr>
<tr>
<td align="center">寄存器寻址</td>
<td align="center">EA = Ri</td>
<td align="center">0</td>
<td></td>
</tr>
<tr>
<td align="center">寄存器间接一次寻址</td>
<td align="center">EA = ( Ri )</td>
<td align="center">1</td>
<td></td>
</tr>
<tr>
<td align="center">相对寻址</td>
<td align="center">EA = ( PC ) + A</td>
<td align="center">1</td>
<td></td>
</tr>
<tr>
<td align="center">基址寻址</td>
<td align="center">EA = ( BR ) + A</td>
<td align="center">1</td>
<td>BR 不变，A 变，面向操作系统</td>
</tr>
<tr>
<td align="center">变址寻址</td>
<td align="center">EA = ( IX ) + A</td>
<td align="center">1</td>
<td>A 不变，IX 变，面向用户，典型应用：<strong>数组</strong></td>
</tr>
</tbody></table>
<h2 id="（★）CISC和RISC"><a href="#（★）CISC和RISC" class="headerlink" title="（★）CISC和RISC"></a>（★）CISC和RISC</h2><h3 id="CISC和RISC的基本概念及区别"><a href="#CISC和RISC的基本概念及区别" class="headerlink" title="CISC和RISC的基本概念及区别"></a>CISC和RISC的基本概念及区别</h3><p>（详见教材）</p>
<h3 id="MIPS-32的典型指令"><a href="#MIPS-32的典型指令" class="headerlink" title="MIPS 32的典型指令"></a>MIPS 32的典型指令</h3><p>（详见教材）</p>
<h1 id="解题技巧及重要结论"><a href="#解题技巧及重要结论" class="headerlink" title="解题技巧及重要结论"></a>解题技巧及重要结论</h1><ul>
<li>数组<strong>下标</strong>即为<strong>变址寄存器中的值</strong></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>计算机组成与系统结构.袁春风等</li>
<li>2020年计算机组成原理考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理复习笔记3-存储器分层体系结构</title>
    <url>/2019/10/04/ji-suan-ji-zu-cheng-yuan-li-fu-xi-bi-ji-3-cun-chu-qi-fen-ceng-ti-xi-jie-gou/</url>
    <content><![CDATA[<h1 id="3．存储器分层体系结构"><a href="#3．存储器分层体系结构" class="headerlink" title="3．存储器分层体系结构"></a>3．存储器分层体系结构</h1><h2 id="（★★）存储器的分层结构及存储硬件概述"><a href="#（★★）存储器的分层结构及存储硬件概述" class="headerlink" title="（★★）存储器的分层结构及存储硬件概述"></a>（★★）存储器的分层结构及存储硬件概述</h2><h3 id="存储系统的分层"><a href="#存储系统的分层" class="headerlink" title="存储系统的分层"></a>存储系统的分层</h3><ul>
<li>寄存器</li>
<li>Cache</li>
<li>主存</li>
<li>辅存（外存）</li>
</ul>
<p>注：从上到下，速度变慢，容量变大，成本变低</p>
<h3 id="半导体随机访问存储器的组织"><a href="#半导体随机访问存储器的组织" class="headerlink" title="半导体随机访问存储器的组织"></a>半导体随机访问存储器的组织</h3><ul>
<li>基本结构（详见教材）</li>
<li>支持<strong>随机存取</strong>，<strong>掉电数据丢失</strong></li>
<li>分为 SRAM 和 DRAM</li>
</ul>
<table>
<thead>
<tr>
<th align="center">特点</th>
<th align="center">SRAM</th>
<th align="center">DRAM</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储信息</td>
<td align="center">触发器</td>
<td align="center">电容</td>
</tr>
<tr>
<td align="center">破坏性读出</td>
<td align="center">非</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">需要刷新</td>
<td align="center">不要</td>
<td align="center">要</td>
</tr>
<tr>
<td align="center">送行列地址</td>
<td align="center">同时送</td>
<td align="center">分两次</td>
</tr>
<tr>
<td align="center">运行速度</td>
<td align="center">快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">集成度</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">发热量（功耗）</td>
<td align="center">大</td>
<td align="center">小</td>
</tr>
<tr>
<td align="center">存储成本</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">主要用途</td>
<td align="center">高速缓存</td>
<td align="center">主机内存</td>
</tr>
</tbody></table>
<h3 id="只读存储器及主存的主要技术指标"><a href="#只读存储器及主存的主要技术指标" class="headerlink" title="只读存储器及主存的主要技术指标"></a>只读存储器及主存的主要技术指标</h3><ul>
<li>支持<strong>随机存取</strong>，<strong>掉电非易失</strong></li>
<li>分为<ul>
<li>MROM：内容出厂前写入，无法后期改动</li>
<li>PROM：一次可改</li>
<li>EPROM：可多次擦除，多次写入</li>
<li>Flash Memory（闪存，如 <strong>U 盘</strong>）</li>
<li>SSD</li>
</ul>
</li>
<li>性能指标（★★★）<ul>
<li>$存储容量=存储字数\times 字长$ ，<strong>存储字数</strong>表示存储器<strong>地址空间大小</strong>，<strong>字长</strong>表示一次存储操作的<strong>数据</strong>量</li>
<li>$存储速度=\frac{数据的宽度}{存储周期}$<ul>
<li>其中存储周期中包括两个部分，一个是<strong>存取时间</strong>，另一个是<strong>恢复时间</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="存储器芯片与CPU的连接"><a href="#存储器芯片与CPU的连接" class="headerlink" title="存储器芯片与CPU的连接"></a>存储器芯片与CPU的连接</h3><ul>
<li>主存与 CPU 之间有三条线相连，分别是<ul>
<li>数据线（双向）</li>
<li>控制信号线（CPU $\rightarrow$ 主存）</li>
<li>地址线（CPU $\rightarrow$ 主存）</li>
</ul>
</li>
<li>主存容量扩展（★★★★）<ul>
<li>位扩展<ul>
<li>用多个芯片对字长进行扩充（如 8 片 8K × 1 位芯片位扩展后，得到 8K × 8 位）</li>
<li>连接方式<ul>
<li><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/10/04/Bit.png?raw=true" alt="位扩展"></li>
</ul>
</li>
</ul>
</li>
<li>字扩展<ul>
<li>用多个芯片对字的数量进行扩充（如 8 片 8K × 1 位芯片位扩展后，得到 64K × 1 位）</li>
<li>连接方式<ul>
<li><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/10/04/Word.png?raw=true" alt="字扩展"></li>
</ul>
</li>
</ul>
</li>
<li>字位同时扩展<ul>
<li>同时扩充字和位，组合上述两种扩展</li>
<li>连接方式<ul>
<li><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/10/04/Bit-Word.png?raw=true" alt="字位同时扩展"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多模块存储器的交叉存储"><a href="#多模块存储器的交叉存储" class="headerlink" title="多模块存储器的交叉存储"></a>多模块存储器的交叉存储</h3><ul>
<li><strong>低位</strong>地址为<strong>体号</strong>，<strong>高位</strong>地址为<strong>体内地址</strong>，所以又称为低位交叉编址</li>
<li>交叉编址：每个模块按 <strong>“模 m”</strong> 交叉编址。（即 0，m，···，( k - 1 )m，···存储在第一个单元，其他以此类推）<br><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/10/04/Cross.png?raw=true" alt="多模块存储器的交叉存储"></li>
<li>一些公式（★★）<ul>
<li>设模块字长等于数据总线宽度，模块存取一个字的周期为 <em>T</em>，总线传送周期为 <em>r</em>， 为实现流水线方式存取，存储器交叉模块数应<strong>大于等于</strong><ul>
<li>$m=\frac{T}{r}$ （<em>m</em> 称为<strong>交叉存取度</strong>）</li>
</ul>
</li>
<li>连续存储 <em>m</em> 个字的时间为<ul>
<li>$t=T+(m-1)r$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="（★★）Cache"><a href="#（★★）Cache" class="headerlink" title="（★★）Cache"></a>（★★）Cache</h2><h3 id="高速缓冲存储器的CPU基本访存过程"><a href="#高速缓冲存储器的CPU基本访存过程" class="headerlink" title="高速缓冲存储器的CPU基本访存过程"></a>高速缓冲存储器的CPU基本访存过程</h3><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/10/04/Cache.png?raw=true" alt="带Cache的CPU基本访存过程"></p>
<h3 id="Cache和主存之间的映射方式（★★★★★★★★）"><a href="#Cache和主存之间的映射方式（★★★★★★★★）" class="headerlink" title="Cache和主存之间的映射方式（★★★★★★★★）"></a>Cache和主存之间的映射方式（★★★★★★★★）</h3><h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><ul>
<li>映射关系<ul>
<li>$cache\ 行号 = 主存块号\ Mod\ cache\ 行数$</li>
</ul>
</li>
<li>地址结构</li>
</ul>
<table>
<thead>
<tr>
<th align="center">标记</th>
<th align="center">cache <strong>行号</strong></th>
<th align="center">块内地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/10/04/Direct.png?raw=true" alt="直接映射"></p>
<h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><ul>
<li>映射关系<ul>
<li>主存块可装入 cache 中任意一行</li>
</ul>
</li>
<li>地址结构</li>
</ul>
<table>
<thead>
<tr>
<th align="center">标记</th>
<th align="center">块内地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/10/04/Full.png?raw=true" alt="全相联映射"></p>
<h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><ul>
<li>映射关系<ul>
<li>$cache\ 组号 = 主存块号\ Mod\ cache\ 组数$</li>
</ul>
</li>
<li>地址结构</li>
</ul>
<table>
<thead>
<tr>
<th align="center">标记</th>
<th align="center">cache <strong>组号</strong></th>
<th align="center">块内地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/10/04/Group.png?raw=true" alt="组相联映射"></p>
<h3 id="程序访问的局部性原理对编程的影响及Cache-friendly的程序"><a href="#程序访问的局部性原理对编程的影响及Cache-friendly的程序" class="headerlink" title="程序访问的局部性原理对编程的影响及Cache-friendly的程序"></a>程序访问的局部性原理对编程的影响及Cache-friendly的程序</h3><p>（详见教材）</p>
<h3 id="Cache替换算法和Cache写策略"><a href="#Cache替换算法和Cache写策略" class="headerlink" title="Cache替换算法和Cache写策略"></a>Cache替换算法和Cache写策略</h3><h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><p>类似操作系统中内存管理页面置换</p>
<ul>
<li>FIFO</li>
<li>LRU</li>
<li>LFU</li>
<li>随机替换</li>
</ul>
<h4 id="Cache-写策略"><a href="#Cache-写策略" class="headerlink" title="Cache 写策略"></a>Cache 写策略</h4><ul>
<li>全写法<ul>
<li>基本做法：写操作时，若写命中，则同时写 Cache 和主存；若写不命中，则有以下两种处理方法<ul>
<li>写分配法：先在主存块中更新相应存储单元，然后分配一个 Cache 行，将更新后的主存块装到分配的 Cache 行中</li>
<li>非写分配法：仅更新主存单元而不装入主存块到 Cache 中</li>
</ul>
</li>
</ul>
</li>
<li>回写法<ul>
<li>基本做法：若写命中，则写入 Cache 而不写入主存；若写不命中，则在 Cache 中分配一行，将主存块调入该 Cache 行中并更新相应单元的内容。</li>
</ul>
</li>
</ul>
<h3 id="平均访问时间的计算"><a href="#平均访问时间的计算" class="headerlink" title="平均访问时间的计算"></a>平均访问时间的计算</h3><ul>
<li>命中率：$H=\frac{N_c}{N_c+N_m}$ ，其中 $N_c$ 为命中 cache 的次数，$N_m$ 为访问主存的次数</li>
<li>平均访存时间：$T_a=Ht_c+(1-H)t_m$ ，$t_c$ 为命中时 cache 访存的时间，$t_m$ 为未命中时的访存时间</li>
</ul>
<h2 id="（★★）虚拟存储器"><a href="#（★★）虚拟存储器" class="headerlink" title="（★★）虚拟存储器"></a>（★★）虚拟存储器</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>（详见教材）</p>
<h3 id="三种实现方案"><a href="#三种实现方案" class="headerlink" title="三种实现方案"></a>三种实现方案</h3><ul>
<li>页式</li>
<li>段式</li>
<li>段页式</li>
</ul>
<h3 id="缺页的处理及TLB的原理和作用（重点：虚拟地址和物理地址的转换问题、查段表和页表）"><a href="#缺页的处理及TLB的原理和作用（重点：虚拟地址和物理地址的转换问题、查段表和页表）" class="headerlink" title="缺页的处理及TLB的原理和作用（重点：虚拟地址和物理地址的转换问题、查段表和页表）"></a>缺页的处理及TLB的原理和作用（重点：虚拟地址和物理地址的转换问题、查段表和页表）</h3><p>（参见操作系统-内存管理部分的<a href="https://cosmosning.github.io/2019/09/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><strong>离散（非连续）内存分配方法</strong></a>）</p>
<h1 id="解题技巧及重要结论"><a href="#解题技巧及重要结论" class="headerlink" title="解题技巧及重要结论"></a>解题技巧及重要结论</h1><ul>
<li>有关SRAM、DRAM芯片引脚数的计算：<ul>
<li>引脚包括<strong>地址线</strong>、<strong>数据线</strong>、<strong>片选信号线</strong>、<strong>读信号线</strong>、<strong>写信号线</strong>、<strong>电源信号线</strong>、<strong>接地线</strong></li>
<li>地址线、数据线条数由芯片容量确定（如 <strong>1024 × 8 位</strong> 有 10 根地址线，8根数据线）（地址线的计算注意题设条件，若采用<strong>地址复用技术</strong>，地址线条数要相应<strong>除以二</strong>，此时<strong>片选</strong>分为<strong>两根</strong>：<strong>行通选</strong>、<strong>列通选</strong>）</li>
<li>读信号线和写信号线有时候会合并成<strong>一根</strong></li>
</ul>
</li>
<li>确定某地址 A 所在芯片的最小地址<ul>
<li>例题：假定用若干 2K × 4 位的芯片组成一个 8K × 8 位的存储器，则地址 0B1FH 所在芯片的最小地址为</li>
<li>分析<ul>
<li>2K 说明每一片芯片地址位数为 11 位，8K 对应的有 13 位（其中低 11 位为片内选，2 位为片选）</li>
<li>0B1FH 写成二进制，将片内选部分写成全 0 即可得相应的最小地址</li>
</ul>
</li>
</ul>
</li>
<li>根据地址范围确定芯片地址线位数<ul>
<li>先计算：<strong>最大地址 - 最小地址 + 1</strong></li>
<li>上一步的结果，从低位（第 1 位）到高位，第一个出现 1 的位数<strong>减去 1</strong>，即为相应芯片的地址线位数</li>
</ul>
</li>
<li>芯片接线问题<ul>
<li>从<strong>低位</strong>开始接<strong>地址线</strong>，然后接<strong>译码</strong>线</li>
</ul>
</li>
<li>交叉编址中的访存冲突的判定：<ul>
<li>先计算对应访存地址所在的模块序号：*<em>模块序号( id ) = 访存地址( A ) % 存储器交叉模块数 ( n ) *</em></li>
<li>判定访存冲突的规则：给定的访存地址在相邻的 n 次访问中出现在同一存储模块内。</li>
</ul>
</li>
<li>交叉编址中的流水线存取的时间（或周期等）计算</li>
<li>cache <strong>组相联映射</strong>中组号的计算<ul>
<li>将<strong>主存单元块号除以主存块大小</strong>即可；或者将块号写成二进制，根据主存块大小确定块内地址位数（如 32 B 代表有 5 位），块号二进制中低地址为块内地址，剩下的位数为块号，把相应的位数转换成十进制即可。</li>
</ul>
</li>
<li>cache <strong>直接映像（直接映射）</strong> 的地址划分<ul>
<li>基本公式：$cache\ 行数=\frac{cache 容量}{主存块每块大小}​$</li>
<li>$cache\ 块内地址位数=log_2(cache\ 行大小【以B为单位】)​$</li>
<li>$cache\ 行号位数=log_2(cache\ 行数)=log_2(\frac{cache 容量}{主存块每块大小})$</li>
<li>主存标记位数<ul>
<li>$主存标记位数=log_2(主存容量大小)-cache\ 块内地址位数-cache\ 组号位数$</li>
<li>$主存标记位数=log_2(\frac{主存容量}{cache\ 能存放的数据容量})$（注意是<strong>数据容量</strong>，cache 的总容量【具体见下】不同）</li>
</ul>
</li>
<li>应用：主存装入 cache 的地址：将主存地址写成二进制，取这个二进制的低位，这些低位与 cache  地址结构中除主存标记位以外的对应，即为装入 cache 的地址</li>
</ul>
</li>
<li>cache <strong>组相联映射</strong> 的地址划分<ul>
<li>$cache\ 块内地址位数=log_2(主存块大小【以B为单位】)$</li>
<li>$cache\ 组号位数=\frac{cache\ 容量}{主存块大小\times 路数}​$</li>
<li>$主存标记位数=log_2(主存容量大小)-cache\ 块内地址位数-cache\ 组号位数​$</li>
</ul>
</li>
<li><strong>直接映射</strong>分<strong>行</strong>，<strong>组相联映射</strong>分<strong>组</strong></li>
<li>cache容量的计算<ul>
<li>cache 容量包括<strong>存储容量</strong>和<strong>标记阵列容量</strong>（有效位【1位，一定有】、标记位【一定有，由 cache 地址划分】、一致性维护位【指明采用<strong>回写法</strong>才有】、替换算法控制位）</li>
<li>$cache\ 容量 = cache\ 行数\times (标记位位数之和 +主存每块存储容量【注意单位为 bit】)$</li>
<li>其中<ul>
<li>$cache\ 行数=\frac{cache\ 容量}{主存块大小}$</li>
<li>$标记位数之和=1【代表有效位】+主存标记位数+···（根据题意要求，增补）$</li>
<li>$主存每块大小=字节数\times 字节数位数$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>计算机组成与系统结构.袁春风等</li>
<li>2020年计算机组成原理考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理复习笔记2-运算方法与运算部件</title>
    <url>/2019/09/28/ji-suan-ji-zu-cheng-yuan-li-fu-xi-bi-ji-2-yun-suan-fang-fa-yu-yun-suan-bu-jian/</url>
    <content><![CDATA[<h1 id="2．运算方法与运算部件"><a href="#2．运算方法与运算部件" class="headerlink" title="2．运算方法与运算部件"></a>2．运算方法与运算部件</h1><h2 id="（★★）数制与编码"><a href="#（★★）数制与编码" class="headerlink" title="（★★）数制与编码"></a>（★★）数制与编码</h2><h3 id="进位计数制及其相互转换"><a href="#进位计数制及其相互转换" class="headerlink" title="进位计数制及其相互转换"></a>进位计数制及其相互转换</h3><h4 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h4><ul>
<li>r 进制数可表示为<ul>
<li>$\sum_{i=n}^{-m}K_ir^i$ </li>
<li>其中 <em>r</em> 是基数，$K_i$ 的取值可以是 0 , 1, ··· , r - 1共 <em>r</em> 个数码中的任意一个</li>
</ul>
</li>
</ul>
<h4 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h4><h5 id="R-进制-gt-十进制"><a href="#R-进制-gt-十进制" class="headerlink" title="R 进制 -&gt; 十进制"></a>R 进制 -&gt; 十进制</h5><ul>
<li><strong>按权展开</strong>即可</li>
</ul>
<h5 id="十进制-gt-R-进制"><a href="#十进制-gt-R-进制" class="headerlink" title="十进制 -&gt; R 进制"></a>十进制 -&gt; R 进制</h5><ul>
<li>整数部分：<strong>除基取余，上右下左</strong></li>
<li>小数部分：<strong>乘基取整，上左下右</strong></li>
</ul>
<h5 id="八进制-lt-gt-二进制"><a href="#八进制-lt-gt-二进制" class="headerlink" title="八进制 &lt;-&gt; 二进制"></a>八进制 &lt;-&gt; 二进制</h5><ul>
<li><strong>1 位</strong>八进制对应 <strong>3 位</strong> 二进制</li>
<li>二进制转八进制，若位数不够，则整数部分高位补 0 ，小数部分低位补 0 </li>
</ul>
<h5 id="十六进制-lt-gt-二进制"><a href="#十六进制-lt-gt-二进制" class="headerlink" title="十六进制 &lt;-&gt; 二进制"></a>十六进制 &lt;-&gt; 二进制</h5><ul>
<li><strong>1 位</strong>八进制对应 <strong>4 位</strong> 二进制</li>
<li>二进制转十六进制，若位数不够，则整数部分高位补 0 ，小数部分低位补 0 </li>
</ul>
<h3 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h3><ul>
<li>真值：带有 “+” 和 “-” 的数</li>
<li>机器数：用 “0” 和 “1” 代表数字符号的数，包括 <strong>原码、补码、反码</strong>等</li>
</ul>
<h3 id="BCD编码"><a href="#BCD编码" class="headerlink" title="BCD编码"></a>BCD编码</h3><ul>
<li>用 4 位 二进制数来表示十进制中 0~9 这 10 个数码。（由于 2 的 4 次方 为 16 ，故有 6  个冗余状态）</li>
<li>8421码：每 4 位 对应 1 个十进制位。<ul>
<li>相加修正<ul>
<li>若对应位相加结果 &lt;= 十进制的 9 ，则不需要修正</li>
<li>若大于，则要<strong>加 6 修正</strong> ，并向高位进位</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h3><h4 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h4><ul>
<li>7 位二进制表示</li>
</ul>
<h4 id="汉字"><a href="#汉字" class="headerlink" title="汉字"></a>汉字</h4><ul>
<li>汉字编码包括<strong>输入编码、汉字内码、汉字字形码</strong><ul>
<li>区域码：<strong>两个字节</strong>表示一个汉字，每个字节 <strong>7 位</strong></li>
<li>$国标码 = (区位码)_{16}+2020H​$</li>
<li>$汉字内码 = (国标码)_{16}+8080H​$</li>
</ul>
</li>
</ul>
<h4 id="字符串的存放"><a href="#字符串的存放" class="headerlink" title="字符串的存放"></a>字符串的存放</h4><ul>
<li>大端：<strong>高位字节</strong>到<strong>低位字节</strong>依次存放</li>
<li>小端：<strong>低位字节</strong>到<strong>高位字节</strong>依次存放</li>
<li>注意：是以<strong>字节</strong>为单位存放，不是以位为单位存放</li>
</ul>
<h3 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h3><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><ul>
<li>奇校验： <strong>1 的个数</strong>为奇数</li>
<li>偶校验： <strong>1 的个数</strong>为偶数</li>
</ul>
<h4 id="海明校验"><a href="#海明校验" class="headerlink" title="海明校验"></a>海明校验</h4><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/28/Hamming-1.png?raw=true" alt="海明校验1"></p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/28/Hamming-2.png?raw=true" alt="海明校验2"></p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/28/Hamming-3.png?raw=true" alt="海明校验3"></p>
<h4 id="循环冗余（CRC）校验"><a href="#循环冗余（CRC）校验" class="headerlink" title="循环冗余（CRC）校验"></a>循环冗余（CRC）校验</h4><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/28/CRC-1.png?raw=true" alt="循环冗余校验1"></p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/28/CRC-2.png?raw=true" alt="循环冗余校验2"></p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/28/CRC-3.png?raw=true" alt="循环冗余校验3"></p>
<h2 id="（★★★）定点数的表示、运算与运算部件"><a href="#（★★★）定点数的表示、运算与运算部件" class="headerlink" title="（★★★）定点数的表示、运算与运算部件"></a>（★★★）定点数的表示、运算与运算部件</h2><h3 id="无符号数与有符号整数的表示"><a href="#无符号数与有符号整数的表示" class="headerlink" title="无符号数与有符号整数的表示"></a>无符号数与有符号整数的表示</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>无符号数：所有位为数值位</li>
<li>有符号数：第一位为符号位（ 0 为 正，1 为负），剩余位为数值位</li>
</ul>
<h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><ul>
<li>最高位为符号位，剩余位为数值位，表示该数的绝对值</li>
<li>0 有<strong>两种</strong>表示</li>
</ul>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><ul>
<li>原码到补码的转换<ul>
<li>正数：不变</li>
<li>负数：符号位不变，数值位<strong>按位取反，末位加一</strong></li>
</ul>
</li>
<li>0 仅有<strong>一种</strong>表示</li>
</ul>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><ul>
<li>原码到反码的转换<ul>
<li>正数；不变</li>
<li>负数：符号位不变，数值位<strong>按位取反</strong></li>
</ul>
</li>
<li>0 有<strong>两种</strong>表示</li>
</ul>
<h4 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h4><ul>
<li>补码到移码的转换：<strong>补码的符号位取反</strong>，即得到对应的移码</li>
<li>0 仅有<strong>一种</strong>表示</li>
</ul>
<h3 id="补码定点数加减法运算"><a href="#补码定点数加减法运算" class="headerlink" title="补码定点数加减法运算"></a>补码定点数加减法运算</h3><ul>
<li>公式<br>$$<br>[A+B]<em>{补}=[A]</em>{补}+[B]<em>{补}<br>$$<br>$$<br>[A-B]</em>{补}=[A]<em>{补}+[-B]</em>{补}<br>$$</li>
<li>注意：运算结果仍为<strong>补码</strong>，此步计算完后，要<strong>回化</strong>，转为机器数或者真值</li>
</ul>
<h3 id="定点数乘除运算"><a href="#定点数乘除运算" class="headerlink" title="定点数乘除运算"></a>定点数乘除运算</h3><h4 id="原码一位乘"><a href="#原码一位乘" class="headerlink" title="原码一位乘"></a>原码一位乘</h4><ul>
<li>步骤：<ol>
<li>操作数取绝对值运算，结果符号位取<strong>操作数符号位</strong>的<strong>异或</strong>结果。</li>
<li>部分积长度同被乘数，取 n + 1 位（双符号位），初值为 0</li>
<li>从乘数的最低位开始判断<ol>
<li>若最低位为 1，部分积加上 | x | ，再右移一位</li>
<li>若最低位为 0，部分积加上 0 ，再右移一位</li>
</ol>
</li>
<li>重复 3</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/28/True-Code-Mul.png?raw=true" alt="原码一位乘"></p>
<p>注：最后结果要加上符号位：符号位 <strong>1 异或 0 = 1</strong> ，最终得 x 乘 y = -0.10001111</p>
<h4 id="补码一位乘"><a href="#补码一位乘" class="headerlink" title="补码一位乘"></a>补码一位乘</h4><ul>
<li><p>步骤：</p>
<ol>
<li>符号位参与运算，运算的数均以补码表示</li>
<li><strong>被乘数</strong>一般取<strong>双符号位</strong>，<strong>部分积</strong>取<strong>双符号位</strong>，初值为 0 ，<strong>乘数</strong>可取<strong>单符号位</strong></li>
<li><strong>乘数末位增设附加位 $y_{n+1}$ ，且初值为 0</strong> </li>
<li>对应下面的表格，进行相关操作</li>
<li>移位按补码右移规则进行</li>
<li>循环上述操作</li>
</ol>
</li>
<li><p>Booth 算法的移位规则</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">$y_n$（高位）</th>
<th align="center">$y_{n+1}$（低位）</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">部分积右移一位</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">部分积加$[X]_{补}$ ，右移一位</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">部分积加$[-X]_{补}$ ，右移一位</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">部分积右移一位</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/28/Two-s-Complement-Code-Mul.png?raw=true" alt="补码一位乘"></p>
<h4 id="原码除法（不恢复余数法）"><a href="#原码除法（不恢复余数法）" class="headerlink" title="原码除法（不恢复余数法）"></a>原码除法（不恢复余数法）</h4><ul>
<li>步骤：<ol>
<li>符号位不参与运算，结果符号位为操作数符号位两者的异或</li>
<li>用被除数减去乘数<ol>
<li>若余数为<strong>正</strong>，商上 <strong>1</strong> ，左移一位，再减去除数</li>
<li>若余数为<strong>负</strong>，商上 <strong>0</strong> ，左移一位，再加上除数</li>
</ol>
</li>
<li>当最后一步，余数为负（上商 0 ），需要加上除数，得到正确的余数</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/28/True-Code-Div.png?raw=true" alt="原码不恢复余数法"></p>
<h4 id="补码除法（加减交替法）"><a href="#补码除法（加减交替法）" class="headerlink" title="补码除法（加减交替法）"></a>补码除法（加减交替法）</h4><ul>
<li>步骤：<ol>
<li>符号位参与运算，运算的数均以补码表示</li>
<li>若被除数与除数<strong>同号</strong>，则被除数<strong>减去</strong>除数；若被除数与除数<strong>异号</strong>，则被除数<strong>加上</strong>除数（<strong>同号相减，异号相加</strong>）</li>
<li>若余数与除数<strong>同号</strong>，则商上 <strong>1</strong> ，左移一位，<strong>减去</strong>除数；若余数与除数<strong>异号</strong>，则商上 <strong>0</strong> ，左移一位，<strong>加上</strong>除数（<strong>同号商 1 左移减，异号商 0 左移加</strong>）</li>
<li>重复 3</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/28/Two-s-Complement-Code-Div.png?raw=true" alt="补码加减交替法"></p>
<h3 id="溢出概念和判别方法"><a href="#溢出概念和判别方法" class="headerlink" title="溢出概念和判别方法"></a>溢出概念和判别方法</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>运算结果超出了表示范围</li>
</ul>
<h4 id="判别方法"><a href="#判别方法" class="headerlink" title="判别方法"></a>判别方法</h4><h5 id="一位符号位"><a href="#一位符号位" class="headerlink" title="一位符号位"></a>一位符号位</h5><ul>
<li>原操作数符号相同，结果符号与原操作不同，结果溢出</li>
</ul>
<h5 id="双符号位"><a href="#双符号位" class="headerlink" title="双符号位"></a>双符号位</h5><ul>
<li>运算结果<strong>双符号位相同</strong>，表示未<strong>溢出</strong></li>
<li>运算结果<strong>双符号位不同</strong>，表示<strong>溢出</strong>，符号位最高位决定正负</li>
</ul>
<h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><h4 id="算术移位"><a href="#算术移位" class="headerlink" title="算术移位"></a>算术移位</h4><ul>
<li>针对有符号数，移位过程中符号位不变</li>
<li>（★★★★）移位后填补空位原则如下表</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">码制</th>
<th align="center">添补代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">正数</td>
<td align="center">原码、补码、反码</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">负数</td>
<td align="center">原码</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">补码</td>
<td align="center">左移添 0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">右移添 1</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">反码</td>
<td align="center">1</td>
</tr>
</tbody></table>
<h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><ul>
<li>针对无符号数（或者说把该机器数当成无符号数）</li>
<li>移位规则<ul>
<li>左移和右移，空位都添 0</li>
</ul>
</li>
</ul>
<h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/28/Cyclic-Shift.png?raw=true" alt="循环移位"></p>
<h2 id="（★★）浮点数的表示与运算"><a href="#（★★）浮点数的表示与运算" class="headerlink" title="（★★）浮点数的表示与运算"></a>（★★）浮点数的表示与运算</h2><h3 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h3><ul>
<li>$N=r^E\times M$</li>
<li>其中，<em>r</em> 为阶码的底（隐含，在计算机中 <em>r</em> = 2），<em>E</em> 为阶码，<em>M</em> 为尾数</li>
</ul>
<h3 id="IEEE754标准"><a href="#IEEE754标准" class="headerlink" title="IEEE754标准"></a>IEEE754标准</h3><ul>
<li>统一数据格式如下表</li>
</ul>
<table>
<thead>
<tr>
<th align="center">$m_s$</th>
<th align="center">$E$</th>
<th align="center">$M$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数符</td>
<td align="center">阶码（<strong>移码</strong>表示）</td>
<td align="center">尾数（<strong>原码</strong>表示）</td>
</tr>
</tbody></table>
<ul>
<li>不同类型浮点数数位安排</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">数符</th>
<th align="center">阶码</th>
<th align="center">尾数数值</th>
<th align="center">总位数</th>
<th align="center">偏置值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">短浮点数(float)</td>
<td align="center">1</td>
<td align="center">8</td>
<td align="center">23</td>
<td align="center">32</td>
<td align="center">127（7FH）</td>
</tr>
<tr>
<td align="center">长浮点数(double)</td>
<td align="center">1</td>
<td align="center">11</td>
<td align="center">52</td>
<td align="center">64</td>
<td align="center">1023（3FFH）</td>
</tr>
</tbody></table>
<ul>
<li>注<ul>
<li>由于规格化后，尾数最高位总为 1 ，可将此位隐含，故尾数实际可多存一位（还原此浮点数时，需要补上最高位的 1）</li>
<li>以短浮点数为例<ul>
<li>偏置值为 127 （而非 128 ），因为要用<strong>全1</strong>表示<strong>无穷大</strong></li>
<li>阶码范围为 1~254，因为<strong>全0</strong>表示<strong>非规格化数</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h3><ul>
<li>步骤<ul>
<li>对阶<ul>
<li>小阶向大阶看齐：小阶右移，阶增加，直至阶码相等</li>
</ul>
</li>
<li>尾数求和</li>
<li>规格化（详见下一个标题）</li>
<li>舍入<ul>
<li>0 舍 1 入<ul>
<li>尾数右移<ul>
<li>低位丢弃了 0 ，则舍去</li>
<li>低位丢弃了 1 ，则尾数加一（可能导致溢出，需右规处理）</li>
</ul>
</li>
</ul>
</li>
<li>恒置 1<ul>
<li>尾数右移，低位恒置 1</li>
</ul>
</li>
</ul>
</li>
<li>溢出判断<ul>
<li>双符号位补码：双符号位相同，未溢出；双符号位不同，溢出。溢出情况又分为<ul>
<li>双符号位为 10，下溢</li>
<li>双符号位为 01，上溢</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="浮点数规格化"><a href="#浮点数规格化" class="headerlink" title="浮点数规格化"></a>浮点数规格化</h3><ul>
<li>规格化后<ul>
<li>原码：最高数值位总为 1</li>
<li>补码：符号位和最高数值位不同</li>
<li>根据这个性质，可判断浮点数中的尾数是否是规格化数</li>
</ul>
</li>
<li>非规格化尾数的规格化操作<ul>
<li>左规<ul>
<li><strong>左移</strong>一位，阶码<strong>减一</strong></li>
</ul>
</li>
<li>右规<ul>
<li><strong>右移</strong>一位，阶码<strong>加一</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="（★）ALU的功能与结构"><a href="#（★）ALU的功能与结构" class="headerlink" title="（★）ALU的功能与结构"></a>（★）ALU的功能与结构</h2><h3 id="补码加减运算器的实现"><a href="#补码加减运算器的实现" class="headerlink" title="补码加减运算器的实现"></a>补码加减运算器的实现</h3><p>（详见教材）</p>
<h3 id="典型指令完成设计与实现"><a href="#典型指令完成设计与实现" class="headerlink" title="典型指令完成设计与实现"></a>典型指令完成设计与实现</h3><p>（详见教材）</p>
<h2 id="（★★）掌握不同层次程序员看到的运算"><a href="#（★★）掌握不同层次程序员看到的运算" class="headerlink" title="（★★）掌握不同层次程序员看到的运算"></a>（★★）掌握不同层次程序员看到的运算</h2><h3 id="高级语言以C语言为例"><a href="#高级语言以C语言为例" class="headerlink" title="高级语言以C语言为例"></a>高级语言以C语言为例</h3><p>（详见教材）</p>
<h3 id="ISA层面则以MIPS32为例"><a href="#ISA层面则以MIPS32为例" class="headerlink" title="ISA层面则以MIPS32为例"></a>ISA层面则以MIPS32为例</h3><p>（详见教材）</p>
<h1 id="解题技巧及重要结论"><a href="#解题技巧及重要结论" class="headerlink" title="解题技巧及重要结论"></a>解题技巧及重要结论</h1><ul>
<li>BCD 码表示的数相加减，可以先将两数转换为十进制（每 4 位二进制位看成 1 位十进制位），十进制相加减，在将十进制结果转换为 BCD 码表示。</li>
<li>判断 8421 BCD 码的合法性：检查是否出现 <strong>1010~1111</strong> 范围内的二进制数，若有，则非法。</li>
<li>海明校验码能纠一位错应该满足 $2^k\ge n+k +1$ ，其中 <em>n</em> 为数据位数，<em>k</em> 为校验位数</li>
<li>一种判运算结果溢出的技巧：全部转换成十进制进行对应计算，在依据数据位数所确定的数据表示范围，来判断结果是否溢出。</li>
<li><strong>补码</strong>表示时，若<strong>符号位相同</strong>，则<strong>数值位越大码越大</strong></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>计算机组成与系统结构.袁春风等</li>
<li>2020年计算机组成原理考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理复习笔记1-概述</title>
    <url>/2019/09/24/ji-suan-ji-zu-cheng-yuan-li-fu-xi-bi-ji-1-gai-shu/</url>
    <content><![CDATA[<h1 id="1．计算机系统概述"><a href="#1．计算机系统概述" class="headerlink" title="1．计算机系统概述"></a>1．计算机系统概述</h1><h2 id="（×）计算机的发展历程"><a href="#（×）计算机的发展历程" class="headerlink" title="（×）计算机的发展历程"></a>（×）计算机的发展历程</h2><p>（详见教材）</p>
<h2 id="（★★）冯·诺依曼计算机结构"><a href="#（★★）冯·诺依曼计算机结构" class="headerlink" title="（★★）冯·诺依曼计算机结构"></a>（★★）冯·诺依曼计算机结构</h2><h3 id="冯·诺依曼计算机结构的特点"><a href="#冯·诺依曼计算机结构的特点" class="headerlink" title="冯·诺依曼计算机结构的特点"></a>冯·诺依曼计算机结构的特点</h3><ul>
<li><strong>“存储程序”</strong>工作方式</li>
<li>由<strong>运算器、控制器、存储器、输入设备、输出设备</strong> 5 个基本部件组成</li>
<li>指令和数据存储在存储器内；控制器能控制指令自动执行；运算器可以算术运算、逻辑运算；操作人员通过输入输出设备使用计算机</li>
<li>计算机内部用<strong>二进制表示</strong>指令和数据；每条指令由<strong>操作码</strong>（指名操作类型）和<strong>地址码</strong>（指出操作数所在地址）组成；<strong>一组指令组成程序</strong></li>
</ul>
<h3 id="计算机硬件的基本组成与功能"><a href="#计算机硬件的基本组成与功能" class="headerlink" title="计算机硬件的基本组成与功能"></a>计算机硬件的基本组成与功能</h3><ul>
<li>中央处理器（CPU）</li>
<li>存储器<ul>
<li>外存</li>
<li>内存</li>
</ul>
</li>
<li>I/O 控制器</li>
<li>外部设备</li>
<li>总线</li>
</ul>
<h3 id="计算机系统的组成（硬件-软件）及其层次结构"><a href="#计算机系统的组成（硬件-软件）及其层次结构" class="headerlink" title="计算机系统的组成（硬件+软件）及其层次结构"></a>计算机系统的组成（硬件+软件）及其层次结构</h3><ul>
<li>应用（问题）</li>
<li>算法</li>
<li>编程（语言）</li>
<li>操作系统 / 虚拟机</li>
<li>指令集体系结构（ISA）</li>
<li>微体系结构</li>
<li>功能部件 / RTL</li>
<li>电路</li>
<li>器件</li>
</ul>
<p>其中 ISA 为软硬件的交界面</p>
<h3 id="计算机的工作原理"><a href="#计算机的工作原理" class="headerlink" title="计算机的工作原理"></a>计算机的工作原理</h3><p>（详见教材）</p>
<h2 id="（★★）计算机的性能指标"><a href="#（★★）计算机的性能指标" class="headerlink" title="（★★）计算机的性能指标"></a>（★★）计算机的性能指标</h2><h3 id="CPU执行时间"><a href="#CPU执行时间" class="headerlink" title="CPU执行时间"></a>CPU执行时间</h3><ul>
<li>用于程序执行的时间，包括<ul>
<li>用户 CPU 时间：用于运行用户程序代码的时间</li>
<li>系统 CPU 时间：为了执行用户程序而需要 CPU 运行操作系统程序的时间</li>
</ul>
</li>
</ul>
<h3 id="CPI（★★★★）"><a href="#CPI（★★★★）" class="headerlink" title="CPI（★★★★）"></a>CPI（★★★★）</h3><ul>
<li>执行一条指令所需要的时钟周期</li>
<li>一些公式<ul>
<li>$CPU执行时间 = \frac{程序所含时钟周期数}{时钟频率}=程序所含时钟周期数\times 时钟周期$</li>
<li>$程序的总时钟周期数=程序所含指令条数\times CPI$  （这里的 <em>CPI</em> 是综合  <em>CPI</em> ）</li>
<li>$程序总时钟周期数=\sum_{i=1}^{n}(CPI_i\times C_i)$ （有 <em>n</em> 种不同的指令，第 <em>i</em> 种指令条数和 <em>CPI</em> 分别是 $C_i$  和 $CPI_i$ ）</li>
<li>$CPI = \sum_{i=1}^{n}(CPI_i\times F_i) =程序总时钟周期数\div程序所含指令条数$ ，其中 $F_i$ 为第 <em>i</em> 种指令在程序中所占的比例</li>
<li>$CPU执行时间 = CPI\times 程序总指令数\times时钟周期=\frac{(指令条数\times CPI)}{主频}$</li>
</ul>
</li>
</ul>
<h3 id="时钟周期-T"><a href="#时钟周期-T" class="headerlink" title="时钟周期 T"></a>时钟周期 T</h3><ul>
<li>CPU 主脉冲信号的宽度</li>
</ul>
<h3 id="主频-f"><a href="#主频-f" class="headerlink" title="主频 f"></a>主频 f</h3><ul>
<li>时钟周期的倒数：f = 1 / T</li>
</ul>
<h3 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h3><ul>
<li>每秒执行多少百万条指令</li>
<li>公式<ul>
<li>$MIPS=\frac{指令条数}{执行时间\times 10^6} = \frac{主频（注意以MHz为单位）}{CPI}$</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>计算机组成与系统结构.袁春风等</li>
<li>2020年计算机组成原理考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习笔记6-操作系统接口</title>
    <url>/2019/09/24/cao-zuo-xi-tong-fu-xi-bi-ji-6-cao-zuo-xi-tong-jie-kou/</url>
    <content><![CDATA[<h1 id="7．操作系统接口"><a href="#7．操作系统接口" class="headerlink" title="7．操作系统接口"></a>7．操作系统接口</h1><h2 id="操作系统接口类型"><a href="#操作系统接口类型" class="headerlink" title="操作系统接口类型"></a>操作系统接口类型</h2><ul>
<li>字符显示式联机用户接口</li>
<li>图形化联机用户接口</li>
<li>脱机用户接口</li>
</ul>
<h2 id="系统调用概念"><a href="#系统调用概念" class="headerlink" title="系统调用概念"></a>系统调用概念</h2><p>（详见教材）</p>
<h2 id="系统调用的类型和实现方法"><a href="#系统调用的类型和实现方法" class="headerlink" title="系统调用的类型和实现方法"></a>系统调用的类型和实现方法</h2><p>（详见教材）</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>计算机操作系统.汤小丹等</li>
<li>2020年操作系统考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习笔记5-磁盘与文件系统</title>
    <url>/2019/09/15/cao-zuo-xi-tong-fu-xi-bi-ji-5-ci-pan-yu-wen-jian-xi-tong/</url>
    <content><![CDATA[<h1 id="6．磁盘与文件系统"><a href="#6．磁盘与文件系统" class="headerlink" title="6．磁盘与文件系统"></a>6．磁盘与文件系统</h1><h2 id="磁盘的结构和基本概念"><a href="#磁盘的结构和基本概念" class="headerlink" title="磁盘的结构和基本概念"></a>磁盘的结构和基本概念</h2><ul>
<li><strong>磁道</strong>：磁盘上的同心圆</li>
<li><strong>盘面</strong>：磁盘的某一面</li>
<li><strong>扇区</strong>（盘块）：磁道划分为<strong>扇区</strong>，每个扇区固定大小</li>
<li><strong>柱面</strong>：所有盘面上相对位置相同的磁道组成<strong>柱面</strong></li>
<li>磁头</li>
<li>磁头臂</li>
<li>磁盘地址组成：<strong>柱面号·盘面号·扇区号</strong></li>
</ul>
<p>（其他基本概念详见教材）</p>
<h2 id="磁盘的调度（★★★★★）"><a href="#磁盘的调度（★★★★★）" class="headerlink" title="磁盘的调度（★★★★★）"></a>磁盘的调度（★★★★★）</h2><h3 id="存取时间的计算"><a href="#存取时间的计算" class="headerlink" title="存取时间的计算"></a>存取时间的计算</h3><ul>
<li>寻找时间 $T_s$ ：磁头移动到指定磁道的时间（下式中，<em>m</em> 是和磁盘驱动器速度相关的常数，移动跨越 <em>n</em> 条磁道，<em>s</em> 为磁臂启动时间）</li>
</ul>
<p>$$<br>T_s=m\times n + s<br>$$</p>
<ul>
<li>延迟时间 $T_r$ ：磁头定位到某一磁道的扇区所需要的时间（下式中 <em>r</em> 为磁盘转速）</li>
</ul>
<p>$$<br>T_r=\frac{1}{2r}<br>$$</p>
<ul>
<li>传输时间 $T_t$ ：磁盘读出或写入数据经历的时间（下式中 <em>b</em> 为每次读/写的字节数， <em>N</em> 为一个磁道上的字节数）</li>
</ul>
<p>$$<br>T_{t}=\frac{b}{rN}<br>$$</p>
<ul>
<li>总平均存取时间为</li>
</ul>
<p>$$<br>T_a=T_s+\frac{1}{2r}+\frac{b}{rN}<br>$$</p>
<h3 id="调度算法（★★★★★）"><a href="#调度算法（★★★★★）" class="headerlink" title="调度算法（★★★★★）"></a>调度算法（★★★★★）</h3><table>
<thead>
<tr>
<th align="center">算法名称</th>
<th align="center">调度标准</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">先来先服务（FCFS）</td>
<td align="center">先来先服务</td>
<td align="center">公平、简单</td>
<td align="center">平均寻道距离大</td>
</tr>
<tr>
<td align="center">最短寻找时间优先（SSTF）</td>
<td align="center">选择<strong>距离当前磁头位置最短</strong>的请求</td>
<td align="center">性能比FCFS好</td>
<td align="center">不能保证平均寻道时间最短，可能出现<strong>“饥饿”</strong></td>
</tr>
<tr>
<td align="center">扫描算法（SCAN，电梯调度）</td>
<td align="center">选择<strong>当前磁头运动方向上</strong>且<strong>距离当前磁头位置最短</strong>的请求</td>
<td align="center">寻道性能好，可避免“饥饿”</td>
<td align="center">不利于远离磁头一端的请求</td>
</tr>
<tr>
<td align="center">循环扫描算法（C-SCAN）</td>
<td align="center">类似 SCAN 算法，但是当一个方向上处理完成后回返时，直接移动到起始端，不响应途中的任何请求。到达起始端后，才继续响应</td>
<td align="center">消除了对两端磁道请求的不公平性</td>
<td align="center">——–</td>
</tr>
</tbody></table>
<h2 id="磁盘的性能改善和容错"><a href="#磁盘的性能改善和容错" class="headerlink" title="磁盘的性能改善和容错"></a>磁盘的性能改善和容错</h2><p>（见教材 8.4 8.5节）</p>
<h2 id="外存分配方法与物理文件组织"><a href="#外存分配方法与物理文件组织" class="headerlink" title="外存分配方法与物理文件组织"></a>外存分配方法与物理文件组织</h2><h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><ul>
<li>每个文件在磁盘上占有一组<strong>连续</strong>的块</li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/15/Continuous.png?raw=true" alt="连续分配"></p>
<h3 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h3><ul>
<li>每个文件散落在磁盘的各个碎片区域，每一块都存有指向下一块的指针</li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/15/Linked.png?raw=true" alt="链接分配"></p>
<h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><ul>
<li>单独使用一块来存储文件各块存储位置，构成索引块</li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/15/Index.png?raw=true" alt="索引分配"></p>
<h2 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h2><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><ul>
<li>类似内存中的动态分配（回看内存管理）</li>
</ul>
<h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><ul>
<li>空闲盘块链</li>
<li>空闲盘区链</li>
</ul>
<h3 id="位示图法（★）"><a href="#位示图法（★）" class="headerlink" title="位示图法（★）"></a>位示图法（★）</h3><ul>
<li>用二进制的一位来表示某一盘块的使用情况： <em>1</em> 表示已分配， <em>0</em> 表示未分配（空闲）</li>
<li>盘块的分配算法（行列号从 <em>1</em> 开始）<ol>
<li>找到合适的 “0” 的二进制位</li>
<li>计算盘块号 <em>b</em> ：$b = (i-1)n+j$ （其中 <em>i</em> 代表行数，<em>j</em> 代表列数，<em>n</em> 代表每行位数）</li>
<li>修改位示图矩阵：$map[i,j] = 1$</li>
</ol>
</li>
<li>盘块的回收算法<ol>
<li>块号 <em>b</em> 转换为行 <em>i</em> 列 <em>j</em> 号$i = (b-1)\ DIV\ n + 1,j=(b-1)\ MOD\ n + 1$</li>
<li>修改位示图矩阵：$map[i,j] = 0$</li>
</ol>
</li>
</ul>
<h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><p>（详见教材）</p>
<h2 id="逻辑文件组织"><a href="#逻辑文件组织" class="headerlink" title="逻辑文件组织"></a>逻辑文件组织</h2><h3 id="无结构文件（流式文件）"><a href="#无结构文件（流式文件）" class="headerlink" title="无结构文件（流式文件）"></a>无结构文件（流式文件）</h3><ul>
<li>以<strong>字节</strong>为单位，如源代码文件等</li>
</ul>
<h3 id="有结构文件（记录式文件）"><a href="#有结构文件（记录式文件）" class="headerlink" title="有结构文件（记录式文件）"></a>有结构文件（记录式文件）</h3><ul>
<li>由一条条<strong>记录</strong>组成，每条记录中包含若干数据项。</li>
</ul>
<h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><ul>
<li>按某种顺序排列形成的文件</li>
<li>排列方式分为<strong>串结构</strong>和<strong>顺序结构</strong><ul>
<li>串结构：通常按<strong>存入时间先后顺序</strong>排序</li>
<li>顺序结构：用户指定<strong>关键字</strong>，按<strong>关键字</strong>排序</li>
</ul>
</li>
</ul>
<h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><ul>
<li>建立索引表，为每个记录设置一个表项，从而加快检索记录的速度</li>
<li>可<strong>按关键字建立索引</strong>，一个索引文件可能被<strong>多个索引表</strong>索引（如图书信息可按图书编号、图书名、作者等进行索引查找）</li>
</ul>
<h4 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h4><ul>
<li>为每个文件建立索引表，将记录分组，只为<strong>每组的第一条记录建立索引表项</strong></li>
<li>可以有<strong>一级、二级、多级</strong>索引顺序文件</li>
<li>查找效率比较（假设文件所含有的记录数为 <em>N</em> ，为检索到指定含有关键字的记录）<ul>
<li>顺序文件：<strong>平均需要查找 $\frac{N}{2}$</strong></li>
<li>索引顺序文件：*<em>平均需要查找 $\sqrt{N}$ *</em></li>
</ul>
</li>
</ul>
<h4 id="直接文件（散列文件）"><a href="#直接文件（散列文件）" class="headerlink" title="直接文件（散列文件）"></a>直接文件（散列文件）</h4><ul>
<li>通过哈希函数，完成从<strong>关键字</strong>到<strong>物理地址</strong>的直接转换。</li>
</ul>
<h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li>创建</li>
<li>删除</li>
<li>读</li>
<li>写</li>
<li>设置读/写位置</li>
</ul>
<h3 id="“打开”和“”关闭“”（★★★★）"><a href="#“打开”和“”关闭“”（★★★★）" class="headerlink" title="“打开”和“”关闭“”（★★★★）"></a>“打开”和“”关闭“”（★★★★）</h3><ul>
<li><strong>打开</strong>：系统将指名文件的<strong>属性</strong>（包括该文件在外存上的物理位置），从外存<strong>拷贝到内存打开文件表的一个表目中</strong>，并将<strong>该表目的编号（或称为索引号）返回给用户</strong>，即建立了用户和指定文件之间的连接。</li>
<li><strong>关闭</strong>：断开上述连接</li>
<li>“打开”并非真正打开，而是读取文件相关属性；“关闭”并非真正关闭，而是断开连接。</li>
</ul>
<h2 id="文件目录及其管理"><a href="#文件目录及其管理" class="headerlink" title="文件目录及其管理"></a>文件目录及其管理</h2><ul>
<li>目录管理的要求<ul>
<li><strong>实现“按名存取”</strong></li>
<li><strong>提高目录检索速度</strong></li>
<li><strong>文件共享</strong></li>
<li><strong>允许文件重名</strong></li>
</ul>
</li>
</ul>
<h3 id="文件控制块（FCB）"><a href="#文件控制块（FCB）" class="headerlink" title="文件控制块（FCB）"></a>文件控制块（FCB）</h3><ul>
<li>作用类似进程管理中的 PCB ，用来存放控制文件需要的各种信息，包括：<ul>
<li>基本信息：文件名、物理位置、逻辑结构、物理结构等</li>
<li>存取控制信息：存取权限</li>
<li>使用信息：创建时间、修改时间</li>
</ul>
</li>
<li>从而实现了<strong>“按名存取”</strong></li>
<li>FCB 的有序集合成为<strong>文件目录</strong>，一个 FCB 就是一个<strong>文件目录表项</strong></li>
<li>创建新文件时，也会创建一个对应的 FCB</li>
</ul>
<h3 id="索引结点"><a href="#索引结点" class="headerlink" title="索引结点"></a>索引结点</h3><ul>
<li>为加快按文件名检索目录文件而引入。（无索引时，需依次检索 FCB，但是 FCB 中很多信息对于检索目录是多余的，因此把需要的信息抽出，形成索引【通常包括 <strong>文件名</strong> 、<strong>索引结点编号</strong> 】，从而可以加快检索速度）</li>
<li>根据索引结点所处位置不同，分为<ul>
<li>磁盘索引结点</li>
<li>内存索引结点</li>
</ul>
</li>
</ul>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h4><ul>
<li>目录表类似一维数组，存储目录表项</li>
<li>评价<ul>
<li>简单，实现了“按名存取”</li>
<li>查找速度慢</li>
<li>不允许重名</li>
<li>不便于共享</li>
<li>只适用于<strong>单用户</strong></li>
</ul>
</li>
</ul>
<h4 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h4><ul>
<li>顶级目录表类似二维数组，第一维为用户名、第二维存储指向用户目录表的指针</li>
<li>二级目录表存储对应用户的目录表项</li>
<li>评价<ul>
<li>能满足目录管理的四个要求</li>
</ul>
</li>
</ul>
<h4 id="树形（多级）目录结构（★★★）"><a href="#树形（多级）目录结构（★★★）" class="headerlink" title="树形（多级）目录结构（★★★）"></a>树形（多级）目录结构（★★★）</h4><ul>
<li>对二级的推广，现代 OS 常用</li>
<li>包括以下<strong>目录操作</strong><ul>
<li>创建目录</li>
<li>删除目录</li>
<li>改变目录</li>
<li>移动目录</li>
<li>链接操作</li>
<li>查找</li>
</ul>
</li>
</ul>
<h4 id="目录查询技术"><a href="#目录查询技术" class="headerlink" title="目录查询技术"></a>目录查询技术</h4><h5 id="线性检索法（★★★）"><a href="#线性检索法（★★★）" class="headerlink" title="线性检索法（★★★）"></a>线性检索法（★★★）</h5><ul>
<li>单级目录情况<ul>
<li>类似顺序查找算法流程</li>
</ul>
</li>
<li>树形目录情况<ul>
<li>读入第一个文件分量（文件分量即文件路径中被 “/” 分隔的字符串），在第一级目录表中，顺序查找，找到匹配，得到下一级目录表的块号</li>
<li>读入下一个文件分量，在对应级目录表中，顺序查找，找到匹配，得到下一级目录表的块号</li>
<li>以此类推，直至目录中所有文件分量都已处理完毕或者是未找到退出</li>
</ul>
</li>
</ul>
<h5 id="Hash-方法"><a href="#Hash-方法" class="headerlink" title="Hash 方法"></a>Hash 方法</h5><ul>
<li>利用 Hash 函数完成从<strong>文件名</strong>到<strong>索引值</strong>的映射，之后再用得到的索引值找到目录</li>
</ul>
<h2 id="文件共享和保护"><a href="#文件共享和保护" class="headerlink" title="文件共享和保护"></a>文件共享和保护</h2><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><h4 id="基于有向无循环图"><a href="#基于有向无循环图" class="headerlink" title="基于有向无循环图"></a>基于有向无循环图</h4><p>（详见教材）</p>
<h4 id="利用索引结点（硬链接）（★★★）"><a href="#利用索引结点（硬链接）（★★★）" class="headerlink" title="利用索引结点（硬链接）（★★★）"></a>利用索引结点（硬链接）（★★★）</h4><ul>
<li>在用户目录表中，其表项只包括<strong>文件名</strong>和<strong>指向索引结点的指针</strong>，其他的相关信息放在索引结点中</li>
</ul>
<h4 id="不同用户对共享文件创建、删除操作中的链接计数"><a href="#不同用户对共享文件创建、删除操作中的链接计数" class="headerlink" title="不同用户对共享文件创建、删除操作中的链接计数"></a>不同用户对共享文件创建、删除操作中的链接计数</h4><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/15/Count-Of-File-Sharing.png?raw=true" alt="索引分配"></p>
<h4 id="利用符号链接（软链接）（★★★）"><a href="#利用符号链接（软链接）（★★★）" class="headerlink" title="利用符号链接（软链接）（★★★）"></a>利用符号链接（软链接）（★★★）</h4><ul>
<li>共享时，会新建一个 LINK 文件，这个 LINK 文件中<strong>只含有被链接文件的路径</strong></li>
</ul>
<p><strong>硬链接查找较快</strong></p>
<h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><ul>
<li>有<strong>口令保护</strong>、<strong>加密保护</strong>、<strong>访问控制</strong>等方法</li>
<li>访问控制<ul>
<li>类型<ul>
<li>读</li>
<li>写</li>
<li>执行</li>
<li>添加</li>
<li>删除</li>
<li>列表清单</li>
</ul>
</li>
<li>根据用户身份进行控制，为文件和目录添加一个<strong>访问控制表</strong>，<strong>规定每个用户名及其所允许访问的类型</strong></li>
</ul>
</li>
</ul>
<h1 id="解题技巧及重要结论"><a href="#解题技巧及重要结论" class="headerlink" title="解题技巧及重要结论"></a>解题技巧及重要结论</h1><ul>
<li><p>软链接、硬链接中的引用计数问题</p>
<ul>
<li>建立<ul>
<li>软链接（符号链接）：引用计数<strong>直接复制</strong></li>
<li>硬链接：引用计数<strong>加一</strong></li>
</ul>
</li>
<li>删除<ul>
<li>软链接：<strong>删除</strong>操作，对软链接<strong>不可见</strong>（注意软链接只保存了<strong>文件的路径</strong>）。当之后依据软链接访问文件，发现不存在时，此时可以删除符号链接</li>
<li>硬链接：删除文件，<strong>引用计数减一</strong>；若引用计数不为零，则不能删除所共享的文件</li>
</ul>
</li>
<li>例题（2009·408统考）<ul>
<li>F1 引用计数为 1 ，建立符号链接（软链接）F2 ，再建立硬链接 F3 ，删除 F1 ，则此时 F2 、F3 引用计数为</li>
<li>解答：建立 F2 ，由于是软链接，引用计数直接复制，为 1 ；再建立 F3 ，F1 和 F3 的引用计数都加一，为 2；删除 F1，不影响 F2 但影响 F3 ，故 F2 仍为 1 ，F3 要减掉一为 1 </li>
</ul>
</li>
</ul>
</li>
<li><p>混合索引中的计算</p>
<ul>
<li>相关概念<ul>
<li><strong>文件索引结点</strong>：存储索引地址。<strong>索引地址类型</strong>又分为<ul>
<li><strong>直接地址</strong>：此地址<strong>直接指向磁盘数据块</strong>。<ul>
<li>所以$磁盘数据块的块数 = 文件索引结点中含有直接地址项的项数$</li>
</ul>
</li>
<li><strong>一级间接地址索引</strong>：顶级索引节点（在这里便是<strong>文件索引结点</strong>）存放索引，通过这个索引找第二张表，才能找到指向磁盘数据块的地址<ul>
<li>因此$磁盘数据块的块数 = 磁盘索引块地址项的项数=\frac{磁盘索引块大小}{地址项大小}$</li>
</ul>
</li>
<li><strong>二级间接地址索引</strong>：顶级索引节点存放一级索引，通过这个索引找第二张表；找到二级索引，通过这个索引查第三张表才能找到指向磁盘数据块的地址<ul>
<li>故$磁盘数据块的块数 = 磁盘索引块地址项的项数^2=(\frac{磁盘索引块大小}{地址项大小})^2$</li>
</ul>
</li>
<li><strong>n 级间接地址索引</strong>，以此类推有$磁盘数据块的块数 = 磁盘索引块地址项的项数^n=(\frac{磁盘索引块大小}{地址项大小})^n$</li>
</ul>
</li>
</ul>
</li>
<li>典型例题<ul>
<li>（2010·408）文件索引结点 7 个地址项，其中 4 个直接地址、2个一级间接地址索引、 1 个 2 级间接地址索引，每个地址项大小为 4 B，磁盘索引块和磁盘数据块大小均为 256 B，则可表示的单个文件最大长度是<ul>
<li>分析：<ul>
<li>4 个 直接地址：4 × 256 B</li>
<li>2 个一级间接：2 × (256/4) × 256 B</li>
<li>1 个二级间接：1 × (256/4) × (256/4) × 256 B</li>
<li>总计：上述三项之和</li>
</ul>
</li>
</ul>
</li>
<li>文件系统二级索引分配，磁盘块大小 1KB，每个盘块号占 4B，单个文件最大长度为<ul>
<li>分析：<ul>
<li>依题意知，共有 1KB / 4B = 256 个 索引项</li>
<li>由于是二级索引，故最大文件长度为 256 × 256 × 1KB = 64 MB</li>
</ul>
</li>
<li>总结<ul>
<li>（公式补充）<ul>
<li>$索引项个数 =\frac{磁盘块大小}{盘块号大小}$</li>
<li>$文件长度= 索引项个数^{索引级数}\times 磁盘块大小$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>文件系统中， FCB 占 64 B，一个盘块大小为 1 KB，一级目录，设文件目录中有 3200 个目录项，则查找一个文件平均需要访问几次磁盘<ul>
<li>分析<ul>
<li>依题意知，共有 3200 × 64 B / 1 KB = 200 个盘块</li>
<li>一级目录，平均访问磁盘为 200 / 2 = 100 次</li>
</ul>
</li>
<li>总结：<ul>
<li>（公式补充）<ul>
<li>$目录项盘块数 = \frac{目录项项数\times FCB大小}​$</li>
<li>一级目录：$平均访问磁盘次数=\frac{目录项盘块数}{2}$（类似文件的顺序查找）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>（2015·408）文件索引结点中，10 个 直接、1个一级、1个二级，磁盘块大小 1 KB，索引指针大小 4 B 。若文件索引结点已经读入内存，则把该文件偏移量（按字节编址）为 1234 和 307400 处所在的磁盘块读入内存，需访问的盘块数分别是<ul>
<li>分析<ul>
<li>10 个 直接地址：10 × 1 KB = 10 KB</li>
<li>1 个一级间接：1 × ( 1 KB / 4 B ) × 1 KB = 256 KB</li>
<li>1 个二级间接：1 × ( 1 KB / 4 B ) × ( 1 KB / 4 B ) × 1 KB = 64 KB</li>
<li>1234 B &lt; 10 KB，地址可以直接得到，只需再访问 1 次磁盘，获取该地址的数据即可</li>
<li>10 KB + 256 KB &lt; 1234 B &lt; 64 MB，可知该文件内容在二级索引指针所指向的某个磁盘块中。访问 2 次磁盘，获得地址；再依此地址访问 1 次磁盘，获得数据。共需要 3 次</li>
</ul>
</li>
<li>总结<ul>
<li><strong>磁盘访问次数 = 索引级数</strong>（为了找到地址。P.S.直接地址当作 0  级）<strong>+ 1</strong>（为了找到数据：依地址，取数据）</li>
</ul>
</li>
</ul>
</li>
<li>设有一记录文件，采用链接分配方式，逻辑记录的固定长度为 100 B，在磁盘上存储时采用记录成组分解技术，盘块长度 为 512 B。若该文件的目录项已经读入内存，则对 22 个 逻辑记录完成修改后，共启动磁盘多少次<ul>
<li>分析<ul>
<li>第 22 条记录 的地址为 22 × 100 B = 2200 B</li>
<li>2200 B / 512 B = 4 还有剩余，故在第 5 个盘快上。</li>
<li>链接分配，要找到第五个盘块的地址，需要从第一个开始，依次寻找，需要 5 次此盘启动，才能拿到 第 22 个 逻辑记录的物理地址。之后依据这个物理地址，访存修改，还需要启动 1 次磁盘。所以共需 6 次</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>位示图相关</p>
<ul>
<li>（2015·408）文件系统中用位示图，位图位于 32 ~ 127 号块中，每个盘块占 1024 B，盘块和块内字节均从 0 号开始编号。假设要释放 盘块号为 409612 ，则位图中要修改的位所在的盘块号和块内字节序号分别是<ul>
<li>分析：<ul>
<li>$盘块号=起始块号+\lfloor\frac{盘块号}{盘块大小\times 8}\rfloor​$</li>
<li>$块内字节号 =\lfloor 盘块号\ mod\ (盘块大小\times 8)/8\rfloor $</li>
<li>数据带入公式，即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>计算机操作系统.汤小丹等</li>
<li>2020年操作系统考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习笔记4-设备管理</title>
    <url>/2019/09/14/cao-zuo-xi-tong-fu-xi-bi-ji-4-she-bei-guan-li/</url>
    <content><![CDATA[<h1 id="5．设备管理"><a href="#5．设备管理" class="headerlink" title="5．设备管理"></a>5．设备管理</h1><h2 id="I-O体系结构"><a href="#I-O体系结构" class="headerlink" title="I/O体系结构"></a>I/O体系结构</h2><p>从上至下依次为</p>
<ul>
<li><strong>用户层软件</strong>：产生 I/O 请求、格式化 I/O、Spooling</li>
<li><strong>设备独立性软件</strong>：映射、保护、分块、缓冲、分配</li>
<li><strong>设备驱动程序</strong>：设置设备寄存器、检查状态</li>
<li><strong>中断处理程序</strong></li>
<li><strong>硬件</strong>：执行 I/O 操作</li>
</ul>
<h2 id="I-O控制方法"><a href="#I-O控制方法" class="headerlink" title="I/O控制方法"></a>I/O控制方法</h2><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/14/IO-Control.png?raw=true" alt="IO控制流程对比"></p>
<ul>
<li>采用<strong>轮询</strong>的可编程 I/O 方式<ul>
<li>易于实现，但 CPU 和 I/O 设备只能串行工作，<strong>CPU效率较低</strong></li>
</ul>
</li>
<li>采用<strong>中断</strong>的可编程 I/O 方式<ul>
<li>比上一种方法有优势，但数据中的每一个字在存储器与 I/O 控制器之间的传输都要经过 CPU ，这就导致这种方式仍会<strong>消耗较多的 CPU 时间</strong></li>
</ul>
</li>
<li><strong>直接存储器访问（DMA）</strong>方式<ul>
<li>DMA 控制时，传输基本单位是<strong>数据块</strong>，只有<strong>传送开始和结束时</strong>才需要 CPU 的参与，CPU 利用率较高</li>
</ul>
</li>
<li>I/O <strong>通道</strong>方式（通道是一种特殊的<strong>硬件</strong>）<ul>
<li>I/O 通道传送基本单位是<strong>一组数据块</strong>，有更高的自主权，CPU 利用率更高</li>
</ul>
</li>
</ul>
<p>总结：整个 I/O 控制方法的发展，总的来说就是四个字——“简政放权”：减轻 CPU 对所有操作控制的压力，让合适的“人”（如其他专门硬件）去处理合适的“事”（如这里的 I/O 操作）。</p>
<h2 id="I-O分配中的数据结构和分配方法"><a href="#I-O分配中的数据结构和分配方法" class="headerlink" title="I/O分配中的数据结构和分配方法"></a>I/O分配中的数据结构和分配方法</h2><h3 id="设备分配中的数据结构"><a href="#设备分配中的数据结构" class="headerlink" title="设备分配中的数据结构"></a>设备分配中的数据结构</h3><h4 id="设备控制表-（DCT）"><a href="#设备控制表-（DCT）" class="headerlink" title="设备控制表 （DCT）"></a>设备控制表 （DCT）</h4><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/14/DCT.png?raw=true" alt="DCT"></p>
<h4 id="控制器控制表（COCT）、通道控制表（CHCT）、系统设备控制表（SDT）"><a href="#控制器控制表（COCT）、通道控制表（CHCT）、系统设备控制表（SDT）" class="headerlink" title="控制器控制表（COCT）、通道控制表（CHCT）、系统设备控制表（SDT）"></a>控制器控制表（COCT）、通道控制表（CHCT）、系统设备控制表（SDT）</h4><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/14/COCT-CHCT-SDT.png?raw=true" alt="COCT-CHCT-SDT"></p>
<h4 id="上述几种数据结构之间的关系"><a href="#上述几种数据结构之间的关系" class="headerlink" title="上述几种数据结构之间的关系"></a>上述几种数据结构之间的关系</h4><ul>
<li>DCT 与 COCT <strong>一一对应</strong></li>
<li>CHCT 与 COCT <strong>一对多</strong>（一个通道可谓多个设备控制器服务）</li>
<li>SDT 整个系统只有 <strong>一张</strong></li>
</ul>
<h3 id="分配方法"><a href="#分配方法" class="headerlink" title="分配方法"></a>分配方法</h3><p>设备分配的<strong>安全性</strong>指分配设备时<strong>防止发生死锁</strong></p>
<p>（具体见教材）</p>
<h2 id="通道和通道程序"><a href="#通道和通道程序" class="headerlink" title="通道和通道程序"></a>通道和通道程序</h2><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>（具体见教材）</p>
<h3 id="通道程序（★）"><a href="#通道程序（★）" class="headerlink" title="通道程序（★）"></a>通道程序（★）</h3><ul>
<li>通道程序由一系列通道指令构成。</li>
<li>通道指令构成如下<ul>
<li>操作码：包括 <strong>读</strong> <strong>写</strong> <strong>控制</strong> 等操作</li>
<li>内存地址：操作数据的<strong>内存首址</strong></li>
<li>计数：操作数据的<strong>字节数</strong>（与上一项 内存地址 相加，即可获得操作数据的内存范围）</li>
<li>通道程序结束位 <em>P</em> ：<em>P</em> = 1 表示本条指令是通道程序的最后一条指令</li>
<li>记录结束标志 <em>R</em> ：<em>R</em> = 0 表示本条指令和下一条指令处理的数据是<strong>同一条记录</strong>；<em>R</em> = 1 表示这是处理某条记录的最后一条指令</li>
</ul>
</li>
</ul>
<h2 id="设备独立性及其实现方法"><a href="#设备独立性及其实现方法" class="headerlink" title="设备独立性及其实现方法"></a>设备独立性及其实现方法</h2><h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><p>（具体见教材）</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>（具体见教材）</p>
<h2 id="虚拟设备和SPOOLing技术"><a href="#虚拟设备和SPOOLing技术" class="headerlink" title="虚拟设备和SPOOLing技术"></a>虚拟设备和SPOOLing技术</h2><h3 id="SPOOLing技术（★★★）"><a href="#SPOOLing技术（★★★）" class="headerlink" title="SPOOLing技术（★★★）"></a>SPOOLing技术（★★★）</h3><p>（具体见教材）</p>
<h2 id="缓冲管理（★★★★★）"><a href="#缓冲管理（★★★★★）" class="headerlink" title="缓冲管理（★★★★★）"></a>缓冲管理（★★★★★）</h2><p>假设一块数据</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">所需时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">磁盘 → 缓冲区</td>
<td align="center"><em>T</em></td>
</tr>
<tr>
<td align="center">缓冲区 → 用户区</td>
<td align="center"><em>M</em></td>
</tr>
<tr>
<td align="center">CPU 处理</td>
<td align="center"><em>C</em></td>
</tr>
</tbody></table>
<h3 id="单缓冲（★★★）"><a href="#单缓冲（★★★）" class="headerlink" title="单缓冲（★★★）"></a>单缓冲（★★★）</h3><ul>
<li>每块数据处理时间为<ul>
<li>max(<em>C</em>, <em>T</em>) + <em>M</em></li>
</ul>
</li>
</ul>
<h3 id="双缓冲（★★★）"><a href="#双缓冲（★★★）" class="headerlink" title="双缓冲（★★★）"></a>双缓冲（★★★）</h3><ul>
<li>每块数据处理时间为<ul>
<li>max(<em>C+M</em>, <em>T</em>) </li>
</ul>
</li>
</ul>
<p>时间计算小结：能并行的放在 max 内取大的，再和只能串行的任务时间相加</p>
<h3 id="环形缓冲"><a href="#环形缓冲" class="headerlink" title="环形缓冲"></a>环形缓冲</h3><p>（具体见教材）</p>
<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>（具体见教材）</p>
<h2 id="设备处理与I-O软件"><a href="#设备处理与I-O软件" class="headerlink" title="设备处理与I/O软件"></a>设备处理与I/O软件</h2><p>（具体见教材）</p>
<h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><p>（具体见教材）</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>计算机操作系统.汤小丹等</li>
<li>2020年操作系统考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习笔记3-内存管理</title>
    <url>/2019/09/10/cao-zuo-xi-tong-fu-xi-bi-ji-3-nei-cun-guan-li/</url>
    <content><![CDATA[<h1 id="4．内存管理"><a href="#4．内存管理" class="headerlink" title="4．内存管理"></a>4．内存管理</h1><h2 id="内存管理的基本概念"><a href="#内存管理的基本概念" class="headerlink" title="内存管理的基本概念"></a>内存管理的基本概念</h2><h3 id="链接与装入"><a href="#链接与装入" class="headerlink" title="链接与装入"></a>链接与装入</h3><p>（详见教材）</p>
<h3 id="逻辑地址与物理地址空间"><a href="#逻辑地址与物理地址空间" class="headerlink" title="逻辑地址与物理地址空间"></a>逻辑地址与物理地址空间</h3><p>（详见教材）</p>
<h3 id="对换与覆盖"><a href="#对换与覆盖" class="headerlink" title="对换与覆盖"></a>对换与覆盖</h3><p>（详见教材）</p>
<h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>（详见教材）</p>
<h2 id="内存分配方法"><a href="#内存分配方法" class="headerlink" title="内存分配方法"></a>内存分配方法</h2><h3 id="连续内存分配方法"><a href="#连续内存分配方法" class="headerlink" title="连续内存分配方法"></a>连续内存分配方法</h3><ul>
<li>单一连续分配<ul>
<li>简单，<strong>无外部碎片</strong></li>
<li>只能用于单用户、单任务的操作系统，<strong>有内部碎片</strong></li>
</ul>
</li>
<li>固定分区分配<ul>
<li><strong>无外部碎片</strong></li>
<li><strong>有内部碎片</strong>，存储空间利用率低</li>
</ul>
</li>
<li>动态分区分配<ul>
<li><strong>无内部碎片，有外部碎片</strong></li>
<li>动态分区的分配策略（★★★★★）<ul>
<li>首次适应（★★★★）：按<strong>地址从小到大</strong>依次寻找空闲分区，将第一个能满足要求的空闲分区分配给程序</li>
<li>最佳适应：按<strong>容量从小到大</strong>依次寻找空闲分区，将第一个能满足要求的空闲分区分配给程序</li>
<li>最坏适应（最大适应）：按<strong>容量从大到小</strong>依次寻找空闲分区，将第一个能满足要求的空闲分区分配给程序</li>
<li>邻近适应（循环首次适应）：与首次适应类似，但是<strong>查找开始位置</strong>为<strong>上一次查找结束的位置</strong></li>
</ul>
</li>
<li>动态分区的分配策略的比较<ul>
<li><strong>首次适应</strong>，简单，<strong>最好、最快</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="离散（非连续）内存分配方法（★★★★★）"><a href="#离散（非连续）内存分配方法（★★★★★）" class="headerlink" title="离散（非连续）内存分配方法（★★★★★）"></a>离散（非连续）内存分配方法（★★★★★）</h3><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><h5 id="逻辑地址到物理地址的转换"><a href="#逻辑地址到物理地址的转换" class="headerlink" title="逻辑地址到物理地址的转换"></a>逻辑地址到物理地址的转换</h5><h6 id="不含快表（两次访存）"><a href="#不含快表（两次访存）" class="headerlink" title="不含快表（两次访存）"></a>不含快表（两次访存）</h6><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/10/Page.png?raw=true" alt="不含快表分页地址变换机构"></p>
<ul>
<li>设页面大小为 <em>L</em> ，逻辑地址 <em>A</em> 到物理地址 <em>E</em> 的转换<ol>
<li><strong>分析出页号和页面偏移量（根据题设地址结构或者计算得出）</strong>：计算页号 <em>P</em> （ <em>P</em> = <em>A</em> / <em>L</em> ）和页面偏移量 <em>W</em> （<em>W</em> = <em>A</em> % <em>L</em>  ）</li>
<li><strong>判断页号合法性</strong>：比较页号 <em>P</em> 和页表长度 <em>M</em> ，若 <em>P</em> ≥ <em>M</em> ，则产生越界中断，否则继续执行。</li>
<li><strong>查页表，得块号</strong>：页表中页号 <em>P</em> 对应的页表项地址（<strong>目的是在内存中找到相应的页表项</strong>） = 页表始址 <em>F</em> + 页号 <em>P</em> × 页表项长度，取出该页表项内容 <em>b</em> ，即为物理块号。（注意区分<strong>页表长度</strong>和<strong>页表项长度</strong>。<strong>页表长度</strong>的值指一共有多少页，<strong>页表项长度</strong>是指页地址占多大的存储空间）</li>
<li><strong>拼接块号和页内偏移量</strong>：计算 <em>E</em> = <em>b</em> × <em>L</em> + <em>W</em> ，用得到的物理地址<em>E</em> 去访问内存</li>
</ol>
</li>
</ul>
<h6 id="含快表"><a href="#含快表" class="headerlink" title="含快表"></a>含快表</h6><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/10/Page-TLB.png?raw=true" alt="含快表分页地址变换机构"></p>
<ul>
<li>含快表的地址变换流程<ol>
<li>CPU 给出逻辑地址后，由硬件进行地址转换，将页号<strong>送入高速缓存寄存器</strong>，并<strong>将此页号与快表中的所有页号进行比较</strong></li>
<li>若能找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的块号，和页内偏移量拼接形成物理地址。（仅<strong>一次访存</strong>就可以存取数据）</li>
<li>若未找到，类似不含快表对逻辑地址进行转换，<strong>并把（页号，块号）对存入快表</strong>。若快表已满，则需依据相应的替换算法对快表中的元素进行替换</li>
</ol>
</li>
</ul>
<h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><ul>
<li><p>试和<strong>索引表</strong>比较一下</p>
</li>
<li><p>多级和一级的对比</p>
<ul>
<li>一级页表，其存储页号到块号的存储极限<strong>取决于其本身的长度</strong></li>
<li>多级页表，其存储页号到块号的存储极限<strong>取决于各级页表长度之积</strong></li>
<li>总结：乘法比加法更能压缩空间</li>
</ul>
</li>
<li><p>以二级为例，分析其中的数据关系（注意举一反三）（★★★★★）</p>
<ul>
<li>32 位 逻辑地址空间、页面大小 4 KB、页表项 4 B，以字节为编址单位，试确定满足二级页表的逻辑地址空间格式（即求哪几位代表一级页号、二级页号、页内偏移）<ul>
<li>页内偏移位数 = $log_2页面大小$ （本例即 $log_24K = 12$）</li>
<li>由于<strong>顶级页表最多一个页面</strong>，故顶级（一级）页表总共能容纳 $页面大小/页表项大小$ 个页表项（本例为 4KB/4B = 1K），所需位数为 $log_2(页表项个数)$ （本例为 $log_2(1K) = 10$）</li>
<li>剩下的 10 位，即为二级页号。</li>
<li>所以逻辑地址空间格式如下</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">一级页号（10位）</th>
<th align="center">二级页号（10位）</th>
<th align="center">页内偏移量（12位）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="分段（两次访存）"><a href="#分段（两次访存）" class="headerlink" title="分段（两次访存）"></a>分段（两次访存）</h4><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/10/Segment.png?raw=true" alt="分段地址变换机构"></p>
<ul>
<li>逻辑地址 <em>A</em> 到物理地址 <em>E</em> 的转换<ol>
<li><strong>提取段号和页内偏移量</strong>：逻辑地址 <em>A</em> 的结构：前几位是<strong>段号</strong>  <em>S</em> ，后几位是<strong>段内偏移</strong> <em>W</em> </li>
<li><strong>判断段号合法性</strong>：比较段号 <em>S</em> 和段表长度 <em>M</em> ，若 <em>S</em> ≥ <em>M</em> ，则产生越界中断，否则继续执行</li>
<li><strong>查段表，找到段基址、段长，并判段内偏移的合法性</strong>：段表中段号 <em>S</em> 对应的段表项地址 = 段表首址 <em>F</em> + 段号 <em>S</em> × 段表项长度，取出该段表项的前几位得到段长 <em>C</em> 。若段内偏移量 ≥ C，则产生越界中断，否则继续执行。</li>
<li><strong>取出段基地址，和段内偏移求和</strong>：取出段表项中该段的基址 <em>b</em> ，计算 <em>E</em> = <em>b</em> + <em>W</em> </li>
</ol>
</li>
</ul>
<h4 id="段页（三次访存）"><a href="#段页（三次访存）" class="headerlink" title="段页（三次访存）"></a>段页（三次访存）</h4><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/10/Segment-Page.png?raw=true" alt="段页地址变换机构"></p>
<ul>
<li>逻辑地址 <em>A</em> 到物理地址 <em>E</em> 的转换<ol>
<li>依据<strong>段号</strong>查段表，找到<strong>页表始址</strong></li>
<li>依据<strong>页表始址</strong>和<strong>页号</strong>查页表，得到<strong>块号</strong></li>
<li>将<strong>块号</strong>和<strong>页面偏移量</strong>拼接成物理地址</li>
</ol>
</li>
</ul>
<h2 id="虚拟内存分配方法"><a href="#虚拟内存分配方法" class="headerlink" title="虚拟内存分配方法"></a>虚拟内存分配方法</h2><h3 id="虚拟内存的概念"><a href="#虚拟内存的概念" class="headerlink" title="虚拟内存的概念"></a>虚拟内存的概念</h3><p>（详见教材）</p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>（详见教材）</p>
<h3 id="实现虚拟内存所需的硬件和软件支持"><a href="#实现虚拟内存所需的硬件和软件支持" class="headerlink" title="实现虚拟内存所需的硬件和软件支持"></a>实现虚拟内存所需的硬件和软件支持</h3><p>（详见教材）</p>
<h3 id="请求分页（段）管理"><a href="#请求分页（段）管理" class="headerlink" title="请求分页（段）管理"></a>请求分页（段）管理</h3><h4 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h4><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/10/Process.png?raw=true" alt="虚拟内存请求分页管理"></p>
<h3 id="页面置换算法（★★★★★）"><a href="#页面置换算法（★★★★★）" class="headerlink" title="页面置换算法（★★★★★）"></a>页面置换算法（★★★★★）</h3><h4 id="最佳（OPT）置换算法"><a href="#最佳（OPT）置换算法" class="headerlink" title="最佳（OPT）置换算法"></a>最佳（OPT）置换算法</h4><ul>
<li>置换标准：淘汰<strong>最长时间内不再被访问</strong>的页面</li>
<li>无法实现</li>
</ul>
<h4 id="先进先出（FIFO）置换算法"><a href="#先进先出（FIFO）置换算法" class="headerlink" title="先进先出（FIFO）置换算法"></a>先进先出（FIFO）置换算法</h4><ul>
<li>置换标准：淘汰<strong>最早进入内存</strong>的页面（用队列实现）</li>
<li>缺页率较高，会产生<strong>所分配的物理块数增大而页故障数反减</strong>的异常现象</li>
</ul>
<h4 id="最近最久未使用（LRU）置换算法"><a href="#最近最久未使用（LRU）置换算法" class="headerlink" title="最近最久未使用（LRU）置换算法"></a>最近最久未使用（LRU）置换算法</h4><ul>
<li>置换标准：淘汰<strong>最近最久未使用</strong>的页面</li>
<li>性能较好，但需要寄存器和栈的硬件支持。</li>
<li>手算思路<ul>
<li>假想一个链表，其最大长度为内存中能存下最多页面的个数。</li>
<li>若页面不在该链表中，且链表长度未超过最大长度，则将这个页面插入到链表头部</li>
<li>若页面不在该链表中，且链表长度超过最大长度，则将链表末尾元素删除，并将新个页面插入到链表头部</li>
<li>若页面在该链表中，则将新页面移动到链表头部，其他元素位置不变</li>
</ul>
</li>
</ul>
<h4 id="时钟（CLOCK）置换算法（NRU，最近未用）"><a href="#时钟（CLOCK）置换算法（NRU，最近未用）" class="headerlink" title="时钟（CLOCK）置换算法（NRU，最近未用）"></a>时钟（CLOCK）置换算法（NRU，最近未用）</h4><ul>
<li>置换标准：淘汰*<em>访问位为 0 *</em>的页面<ul>
<li>（具体算法流程详见教材）</li>
</ul>
</li>
<li>改进的 CLOCK 算法：多增一位修改位。<ul>
<li>假设 <em>A</em> 为访问位， <em>M</em> 为修改位，（<em>A</em>, <em>M</em>）所有可能取值，淘汰顺序为</li>
<li>(0, 0) (0, 1) (1, 0) (1, 1) （优先换出未使用的；若全部都已使用，再考虑优先换出未被修改的）</li>
<li>（具体算法流程详见教材）</li>
</ul>
</li>
</ul>
<h2 id="内存保护与共享"><a href="#内存保护与共享" class="headerlink" title="内存保护与共享"></a>内存保护与共享</h2><p>（详见教材）</p>
<h2 id="抖动的概念和处理方法"><a href="#抖动的概念和处理方法" class="headerlink" title="抖动的概念和处理方法"></a>抖动的概念和处理方法</h2><p>（详见教材）</p>
<h1 id="解题技巧及重要结论"><a href="#解题技巧及重要结论" class="headerlink" title="解题技巧及重要结论"></a>解题技巧及重要结论</h1><ul>
<li><strong>物理地址</strong> VS <strong>逻辑地址</strong><ul>
<li>物理地址（实地址），若其位数为 32 位，意味着实际物理内存为 $2^{32}B$</li>
<li>逻辑地址（虚地址），若其位数为 48 位，意味着对用户来说内存大小为 $2^{48}B$ （采用了虚拟内存技术）</li>
</ul>
</li>
<li>含多级页表的逻辑地址的划分中的公式总结（对照教材中多级页表理解）<ul>
<li>$页内偏移位数 =log_2页面大小$</li>
<li>$页号部分总位数 = 逻辑地址总位数 - 页内偏移位数$</li>
<li>$一级页号位数=\frac{页面大小}{页表项大小}$</li>
<li>$页表级数 =  \frac{页号部分总位数}{一级页号位数}$</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>计算机操作系统.汤小丹等</li>
<li>2020年操作系统考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习笔记2-进程管理</title>
    <url>/2019/09/04/cao-zuo-xi-tong-fu-xi-bi-ji-2-jin-cheng-guan-li/</url>
    <content><![CDATA[<h1 id="2．进程管理"><a href="#2．进程管理" class="headerlink" title="2．进程管理"></a>2．进程管理</h1><h2 id="前驱图以及程序顺序执行和并发执行的特点"><a href="#前驱图以及程序顺序执行和并发执行的特点" class="headerlink" title="前驱图以及程序顺序执行和并发执行的特点"></a>前驱图以及程序顺序执行和并发执行的特点</h2><h3 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h3><p>（详见教材）</p>
<h3 id="顺序执行的特点"><a href="#顺序执行的特点" class="headerlink" title="顺序执行的特点"></a>顺序执行的特点</h3><ul>
<li>顺序性</li>
<li>封闭性<ul>
<li>程序运行时<strong>独占全机资源</strong></li>
<li>执行结果<strong>不受外界因素影响</strong></li>
</ul>
</li>
<li>可再现性<ul>
<li>执行环境和初始条件相同，程序程序重复执行，最终结果相同。</li>
</ul>
</li>
</ul>
<h3 id="并发执行的特点"><a href="#并发执行的特点" class="headerlink" title="并发执行的特点"></a>并发执行的特点</h3><ul>
<li>间断性</li>
<li>失去封闭性</li>
<li>不可再现性</li>
</ul>
<p>（★）重要结论：程序在<strong>并发执行</strong>时，<strong>其计算结果和并发执行速度有关</strong></p>
<h2 id="进程的基本概念和思想"><a href="#进程的基本概念和思想" class="headerlink" title="进程的基本概念和思想"></a>进程的基本概念和思想</h2><p>（详见教材）</p>
<h2 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h2><p>（详见教材）</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/04/Five-State-of-Process.png?raw=true" alt="五种进程状态转换图"></p>
<h2 id="进程控制块及其作用"><a href="#进程控制块及其作用" class="headerlink" title="进程控制块及其作用"></a>进程控制块及其作用</h2><p>（详见教材）</p>
<h2 id="进程组织"><a href="#进程组织" class="headerlink" title="进程组织"></a>进程组织</h2><ul>
<li>进程控制块（PCB）</li>
<li>程序段</li>
<li>数据段</li>
</ul>
<h2 id="进程同步（★★★★★★★★）"><a href="#进程同步（★★★★★★★★）" class="headerlink" title="进程同步（★★★★★★★★）"></a>进程同步（★★★★★★★★）</h2><h3 id="进程同步的概念和同步原则"><a href="#进程同步的概念和同步原则" class="headerlink" title="进程同步的概念和同步原则"></a>进程同步的概念和同步原则</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>（详见教材）</p>
<h4 id="原则（★★★）"><a href="#原则（★★★）" class="headerlink" title="原则（★★★）"></a>原则（★★★）</h4><ul>
<li>空闲让进<ul>
<li>临界资源空闲，有人需要，给它。</li>
</ul>
</li>
<li>忙则等待<ul>
<li>临界资源正忙（被进程访问中），其他要使用临界资源的进程需要等待临界资源被释放，才能使用</li>
</ul>
</li>
<li>有限等待<ul>
<li>对待对临界资源有需求的进程，应该保证其在有限的时间内得到。以免陷入“死等”（“饥饿”）</li>
</ul>
</li>
<li>让权等待<ul>
<li>自己拿不到临界资源，就放弃处理机。以免陷入“忙等”</li>
</ul>
</li>
</ul>
<h3 id="临街资源和临界区的概念"><a href="#临街资源和临界区的概念" class="headerlink" title="临街资源和临界区的概念"></a>临街资源和临界区的概念</h3><p>（详见教材）</p>
<h3 id="信号量及其应用（★★★★★★）"><a href="#信号量及其应用（★★★★★★）" class="headerlink" title="信号量及其应用（★★★★★★）"></a>信号量及其应用（★★★★★★）</h3><h4 id="常见信号量的描述"><a href="#常见信号量的描述" class="headerlink" title="常见信号量的描述"></a>常见信号量的描述</h4><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P操作（或者称 wait(S) 原语）</span></span><br><span class="line"></span><br><span class="line">wait(S)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>)   <span class="comment">// 未遵循“让权等待”。当 S &lt;= 0 时，使得进程一直“忙等”</span></span><br><span class="line">        ;           <span class="comment">// 空操作</span></span><br><span class="line">    </span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// V 操作（或者称 signal(S) 原语）</span></span><br><span class="line"></span><br><span class="line">signal(S)</span><br><span class="line">&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="记录型"><a href="#记录型" class="headerlink" title="记录型"></a>记录型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span> *<span class="title">list</span>;</span></span><br><span class="line">&#125;semaphore;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P操作（或者称 wait(S) 原语）</span></span><br><span class="line"></span><br><span class="line">wait(semaphore *S)    <span class="comment">// 相当于申请资源</span></span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value &lt; <span class="number">0</span>)</span><br><span class="line">        block(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// V 操作（或者称 signal(S) 原语）</span></span><br><span class="line"></span><br><span class="line">signal(semaphore *S)  <span class="comment">// 相当于释放资源</span></span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">        wakeup(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="实现同步（★★★）"><a href="#实现同步（★★★）" class="headerlink" title="实现同步（★★★）"></a>实现同步（★★★）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P2 的 y 要调用 P1 的 x 的结果，所以需要先执行 P1 的 x 后再执行 P2 的 y</span></span><br><span class="line"></span><br><span class="line">semaphore S = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">P1()</span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    x;               <span class="comment">// x 语句</span></span><br><span class="line">    V(S);            <span class="comment">// 通知 P2，x 语句已完成</span></span><br><span class="line">    </span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()</span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    P(S);            <span class="comment">// 检查语句 x 是否完成</span></span><br><span class="line">    y;               <span class="comment">// 检查无误，运行 y</span></span><br><span class="line">    </span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现互斥（★★★）"><a href="#实现互斥（★★★）" class="headerlink" title="实现互斥（★★★）"></a>实现互斥（★★★）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">semaphore S = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">P1()</span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    P(S);            <span class="comment">// 准备访问前，对临界资源加锁</span></span><br><span class="line">    进入 P1 临界区;</span><br><span class="line">    V(S);            <span class="comment">// 访问结束，释放临界资源的锁</span></span><br><span class="line">    </span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()</span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    P(S);</span><br><span class="line">    进入 P2 临界区;</span><br><span class="line">    V(S);</span><br><span class="line">    </span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现前驱图关系"><a href="#实现前驱图关系" class="headerlink" title="实现前驱图关系"></a>实现前驱图关系</h5><ul>
<li><p>总思路</p>
<ul>
<li>进程<strong>前半段</strong>包含对<strong>前驱结点资源</strong>的 <strong>P</strong> 操作（想要前驱完成，才能继续本进程的继续向下运行）</li>
<li>进程<strong>后半段</strong>包含对<strong>自身结点资源</strong>的 <strong>V</strong> 操作（释放自身，通知其后继结点，我已完成）</li>
</ul>
</li>
</ul>
<h3 id="经典进程同步问题（★★★★★★★★）"><a href="#经典进程同步问题（★★★★★★★★）" class="headerlink" title="经典进程同步问题（★★★★★★★★）"></a>经典进程同步问题（★★★★★★★★）</h3><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者-消费者模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in  输入缓冲区中数据的位置</span></span><br><span class="line"><span class="comment">// out 输出缓冲区中数据的位置</span></span><br><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buffer 缓冲区</span></span><br><span class="line">item <span class="built_in">buffer</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutex 临界区互斥信号量。</span></span><br><span class="line"><span class="comment">// 若为 1，则临界区空闲；</span></span><br><span class="line"><span class="comment">// 若为 0，说明有一个进程在使用，另一个进程并未请求使用；</span></span><br><span class="line"><span class="comment">// 若为 -1，则临界区正被一个进程使用，并且有另一个进程在请求使用这个临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// empty 表示还剩下多少空闲缓冲区，初始化为 n。若为 0，则缓冲区已满</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// full  表示缓冲区已经使用的个数，初始化为 0。若为缓冲区的最大容量，则缓冲区已满。</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        produce an item nextp;</span><br><span class="line">        ...;</span><br><span class="line">        wait(empty);       <span class="comment">// 使用 wait(P操作) 检查是否还有空闲缓冲区资源</span></span><br><span class="line">                           <span class="comment">// 总结：要什么临界资源之前，先 P 一下</span></span><br><span class="line">        wait(mutex);       <span class="comment">// 互斥访问请求</span></span><br><span class="line">        <span class="built_in">buffer</span>[in] = nextp;<span class="comment">// 临界区操作</span></span><br><span class="line">        in = (in + <span class="number">1</span>) % n;</span><br><span class="line">        signal(mutex);     <span class="comment">// 互斥访问释放</span></span><br><span class="line">        signal(full);      <span class="comment">// 缓冲区已使用个数加 1(注意这里是 full )</span></span><br><span class="line">                           <span class="comment">// 总结：操作完成后，提供什么资源，要 V 一下</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(full);         <span class="comment">// 使用 wait(P操作) 检查缓冲区是否有资源（注意是检查 full ）</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        nextp = <span class="built_in">buffer</span>[out];</span><br><span class="line">        out = (out + <span class="number">1</span>) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);      <span class="comment">// 缓冲区空闲个数加 1(注意这里是 empty )</span></span><br><span class="line">        consume the item in nextp;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cobegin</span><br><span class="line">        producer();  consumer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此法可能导致死锁：每个人都拿起左手边的筷子，每个人都又申请右手边的筷子，此时产生死锁。</span></span><br><span class="line"></span><br><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">Pi()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        </span><br><span class="line">        ...;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// eat</span></span><br><span class="line">        </span><br><span class="line">        ...;</span><br><span class="line">        </span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">        signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        </span><br><span class="line">        ...;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// think</span></span><br><span class="line">        </span><br><span class="line">        ...;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改进方案：仅当一名哲学家左右两边的筷子都可用时，才允许拿筷子</span></span><br><span class="line"></span><br><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;                      <span class="comment">// 互斥取筷子</span></span><br><span class="line"></span><br><span class="line">Pi()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(mutex);</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        signal(mutex);                    <span class="comment">// 注意在此时释放互斥取筷子信号量</span></span><br><span class="line">        </span><br><span class="line">        ...;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// eat</span></span><br><span class="line">        </span><br><span class="line">        ...;</span><br><span class="line">        </span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">        signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        </span><br><span class="line">        ...;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// think</span></span><br><span class="line">        </span><br><span class="line">        ...;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rmutex 信号量用于多个 reader 进程互斥访问 readcount 这个临界资源</span></span><br><span class="line"><span class="comment">// wmutex 信号量用于 reader 和 writer 互斥访问</span></span><br><span class="line"></span><br><span class="line">semaphore rmutex = <span class="number">1</span>, wmutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">// 正式读之前，readcount 要增 1</span></span><br><span class="line">        wait(rmutex);</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            wait(wmutex);</span><br><span class="line">        readcount ++;</span><br><span class="line">        signal(rmutex);</span><br><span class="line">        </span><br><span class="line">        ...;</span><br><span class="line">        perform <span class="built_in">read</span> operation;</span><br><span class="line">        ...;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读完后，readcount 要减 1</span></span><br><span class="line">        wait(rmutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            signal(wmutex);</span><br><span class="line">        signal(rmutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(wmutex);</span><br><span class="line">        perform <span class="built_in">write</span> operation;</span><br><span class="line">        signal(wmutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程通信的基本概念和方法"><a href="#进程通信的基本概念和方法" class="headerlink" title="进程通信的基本概念和方法"></a>进程通信的基本概念和方法</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>指进程之间的<strong>信息交换</strong></li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="低级"><a href="#低级" class="headerlink" title="低级"></a>低级</h4><ul>
<li>PV 操作</li>
</ul>
<h4 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h4><ul>
<li>共享存储<ul>
<li>基于共享<strong>数据结构</strong></li>
<li>基于共享<strong>存储区</strong></li>
</ul>
</li>
<li>管道通信<ul>
<li><strong>半双工通信</strong>（某一时刻只能<strong>单向传输</strong>）</li>
</ul>
</li>
<li>消息传递<ul>
<li><strong>直接</strong>通信<ul>
<li>通过<strong>原语</strong>，发送端直接到接受端</li>
</ul>
</li>
<li><strong>间接</strong>通信<ul>
<li>通过共享中间实体（称作邮箱）进行消息收发</li>
</ul>
</li>
</ul>
</li>
<li>客户机-服务器系统<ul>
<li>套接字</li>
<li>远程过程调用和远程方法调用</li>
</ul>
</li>
</ul>
<h2 id="线程的概念和多线程模型"><a href="#线程的概念和多线程模型" class="headerlink" title="线程的概念和多线程模型"></a>线程的概念和多线程模型</h2><h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><p>（详见教材）</p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><h4 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h4><ul>
<li><strong>多个用户级</strong>线程映射到<strong>一个内核级</strong>线程</li>
<li>优点<ul>
<li>线程管理在用户空间进行，<strong>效率较高</strong></li>
</ul>
</li>
<li>缺点<ul>
<li><strong>一个</strong>线程在使用内核服务时被<strong>阻塞</strong>，<strong>整个</strong>进程都会被<strong>阻塞</strong></li>
<li>多个线程<strong>不能并行</strong>地运行在多处理机上</li>
</ul>
</li>
</ul>
<h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><ul>
<li><strong>一个用户级</strong>线程映射到<strong>一个内核级</strong>线程</li>
<li>优点<ul>
<li><strong>一个</strong>线程被阻塞，允许另一个线程继续执行，<strong>并发能力强</strong></li>
</ul>
</li>
<li>缺点<ul>
<li>这样<strong>创建线程</strong>，<strong>开销较大</strong>，<strong>影响程序性能</strong></li>
</ul>
</li>
</ul>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><ul>
<li><strong>n</strong> 个用户级线程映射到 <strong>m</strong> 个内核级线程（m ≤ n）</li>
<li>对比前两者，可谓<strong>集两者之所长，补两者之所短</strong></li>
</ul>
<h1 id="3．调度与死锁"><a href="#3．调度与死锁" class="headerlink" title="3．调度与死锁"></a>3．调度与死锁</h1><h2 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h2><p>（详见教材）</p>
<h2 id="调度队列模型"><a href="#调度队列模型" class="headerlink" title="调度队列模型"></a>调度队列模型</h2><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/09/04/Three-Levels-of-Scheduling.png?raw=true" alt="处理机的三级调度"></p>
<h2 id="调度的基本准则与方式"><a href="#调度的基本准则与方式" class="headerlink" title="调度的基本准则与方式"></a>调度的基本准则与方式</h2><h3 id="基本准则"><a href="#基本准则" class="headerlink" title="基本准则"></a>基本准则</h3><ul>
<li>CPU 利用率</li>
<li>系统吞吐量</li>
<li>（★★★）周转时间<ul>
<li>$周转时间 = 作业完成时间- 作业提交时间$</li>
<li>$平均周转时间= \frac{作业1周转时间+\cdots +作业 n周转时间}{n}$</li>
<li>$带权周转时间=\frac{作业周转时间}{作业实际运行时间}$</li>
<li>$平均带权周转时间=\frac{作业1带权周转时间+\cdots +作业 n带权周转时间}{n}$</li>
</ul>
</li>
<li>等待时间</li>
<li>响应时间</li>
</ul>
<h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><ul>
<li>非剥夺调度方式（非抢占式）</li>
<li>剥夺调度方式（抢占式）</li>
</ul>
<h2 id="（★★★★★）各种调度算法及其评价"><a href="#（★★★★★）各种调度算法及其评价" class="headerlink" title="（★★★★★）各种调度算法及其评价"></a>（★★★★★）各种调度算法及其评价</h2><h3 id="（★★★）先来先服务-FCFS"><a href="#（★★★）先来先服务-FCFS" class="headerlink" title="（★★★）先来先服务(FCFS)"></a>（★★★）先来先服务(FCFS)</h3><ul>
<li>调度标准：按作业<strong>提交时间</strong>，从前到后依次分配处理机</li>
<li>评价<ul>
<li><strong>简单</strong>，但<strong>效率低</strong>；</li>
<li><strong>对长作业有利</strong>，但对短作业不利（相对 SJF 和高响应比）；</li>
<li>有利于 <strong>CPU 繁忙型</strong>作业，不利于 I/O 繁忙型作业</li>
</ul>
</li>
</ul>
<h3 id="（★★★）短作业优先-SJF"><a href="#（★★★）短作业优先-SJF" class="headerlink" title="（★★★）短作业优先(SJF)"></a>（★★★）短作业优先(SJF)</h3><ul>
<li>调度标准：从后备队列中选择<strong>估计运行时间最短</strong>的作业</li>
<li>评价<ul>
<li><strong>平均等待时间、平均周转时间最少</strong></li>
<li>必须预知作业的运行时间</li>
<li>对<strong>长作业</strong>不利（可能会导致长作业“饥饿”）</li>
<li>未考虑作业的紧迫程度</li>
</ul>
</li>
</ul>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul>
<li>调度标准：基于作业的<strong>紧迫程度</strong>，保证紧迫性作业优先</li>
</ul>
<h3 id="（★）高响应比优先"><a href="#（★）高响应比优先" class="headerlink" title="（★）高响应比优先"></a>（★）高响应比优先</h3><ul>
<li>调度标准：<strong>响应比</strong>高的优先运行。其中响应比定义如下<ul>
<li>$响应比R_p=\frac{等待时间+要求服务时间}{要求服务时间}$</li>
</ul>
</li>
<li>评价<ul>
<li>作业等待时间相同，要求服务时间越短，响应比越高，有利于<strong>短作业</strong></li>
<li>要求服务时间相同，作业的响应比由其等待时间确定，等待时间越长，其响应比越高。因而实现了<strong>先来先服务</strong></li>
<li>对于长作业，作业的响应比随等待时间的增加而提高，等待时间足够长时，响应比便可升到很高，从而也可获得处理机。因此，<strong>克服了饥饿状态，兼顾了长作业</strong>。</li>
</ul>
</li>
</ul>
<h3 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h3><ul>
<li>调度标准：<strong>先来先服务</strong>，但<strong>仅能运行一个时间片</strong>。<ul>
<li>若一个时间片未完成，剥夺该进程处理机，并将这个进程挂到就绪队列末尾，将处理机分配给当前就绪队列的第一个进程。</li>
</ul>
</li>
</ul>
<h3 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h3><ul>
<li>调度标准：<strong>时间片轮转</strong>和<strong>优先级调度</strong><ul>
<li>多个队列，优先级不同，时间片也不同。<ul>
<li>总的来说，优先级越高的队列越先执行，但其时间片越短。</li>
<li>一个时间片未完成，降优先级</li>
<li>一个优先级队列都运行完后，才能运行下一个</li>
<li>若有高优先级来，则抢占资源</li>
</ul>
</li>
</ul>
</li>
<li>评价：<ul>
<li>融合了前几种算法的优点</li>
</ul>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul>
<li>多个进程相互竞争资源，形成一种<strong>相互等待</strong>的僵局</li>
</ul>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>竞争不可抢占性资源</li>
<li>竞争可消耗资源</li>
<li>进程推进顺序不当</li>
</ul>
<h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><ul>
<li>资源使用只能一个一个来</li>
</ul>
<h4 id="请求和保持"><a href="#请求和保持" class="headerlink" title="请求和保持"></a>请求和保持</h4><ul>
<li>占着已有的，想占还没有的</li>
</ul>
<h4 id="不可抢占"><a href="#不可抢占" class="headerlink" title="不可抢占"></a>不可抢占</h4><ul>
<li>一个进程占有的，不能被其他进程抢占，而只能由自己释放</li>
</ul>
<h4 id="循环等待"><a href="#循环等待" class="headerlink" title="循环等待"></a>循环等待</h4><ul>
<li>进程 i 需要的资源被进程 i + 1 占用，而进程 n 需要的资源被进程 0 占用。</li>
</ul>
<h3 id="死锁处理策略"><a href="#死锁处理策略" class="headerlink" title="死锁处理策略"></a>死锁处理策略</h3><h4 id="预防（破环死锁必要条件）"><a href="#预防（破环死锁必要条件）" class="headerlink" title="预防（破环死锁必要条件）"></a>预防（破环死锁必要条件）</h4><ul>
<li>互斥：无法破坏</li>
<li>请求和保持：一次分配所有需要的资源</li>
<li>不可抢占：得不到新的，便先放弃旧的</li>
<li>循环等待：按序分配</li>
</ul>
<h4 id="预防（防止系统进入不安全的状态）"><a href="#预防（防止系统进入不安全的状态）" class="headerlink" title="预防（防止系统进入不安全的状态）"></a>预防（防止系统进入不安全的状态）</h4><h5 id="（★★★★★★）银行家算法"><a href="#（★★★★★★）银行家算法" class="headerlink" title="（★★★★★★）银行家算法"></a>（★★★★★★）银行家算法</h5><ul>
<li>流程简述<ul>
<li>计算 Need 矩阵<ul>
<li>情形1：题设可能已经直接给出</li>
<li>情形2：根据表格提取 Max 矩阵和 Allocation 矩阵。用<strong>Max</strong> 减掉 <strong>Allocation</strong>，得到 Need</li>
</ul>
</li>
<li>对比 Need 和 Available<ul>
<li>找到比 Available 小的行（若没有，则当前状态不安全，赶紧另寻其他安全序列），选择一个其中一行，将这行对应的进程暂时加入到安全序列</li>
</ul>
</li>
<li>释放加入安全序列进程对应的资源<ul>
<li>将加入安全序列进程对应的 <strong>Allocation</strong> 行，加到 <strong>Available</strong> ，更新 Available </li>
<li>并在 Need 矩阵中划掉对应的行</li>
</ul>
</li>
<li>从步骤 2 开始向下重复，看能否得到一个安全序列</li>
</ul>
</li>
</ul>
<h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><ul>
<li>利用对<strong>资源分配图</strong>进行化简</li>
</ul>
<h4 id="解除"><a href="#解除" class="headerlink" title="解除"></a>解除</h4><p>通常有以下方法</p>
<ul>
<li>资源剥夺</li>
<li>撤销进程</li>
<li>进程回退</li>
</ul>
<h1 id="解题技巧及重要结论"><a href="#解题技巧及重要结论" class="headerlink" title="解题技巧及重要结论"></a>解题技巧及重要结论</h1><ul>
<li><p>优先级调度算法中<strong>优先级设置的一般原则</strong></p>
<ul>
<li>系统 &gt; 用户</li>
<li>交互式 &gt; 非交互式（或者说 前台 &gt; 后台）</li>
<li><strong>I/O</strong> &gt; <strong>计算</strong></li>
</ul>
</li>
<li><p>（★★★★★★★★★）有关调度算法的平局周转时间的计算方法</p>
<ul>
<li><p>依据调度算法画出运行过程中的甘特图，再依据甘特图计算。</p>
<ul>
<li>注意画甘特图时最好列出下表（特别要标注好，当前时刻未完成的进程的<strong>剩余时间</strong>），做好判断</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>时刻</th>
<th>进程名（剩余时间）</th>
<th>进程名（剩余时间）</th>
<th>···</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>（★★★★★）有关信号量大小的实际意义</p>
<ul>
<li>S.value &gt; 0，表示某类资源<strong>可用的数量</strong>。</li>
<li>S.value &lt;= 0，表示某类资源已经没有，或者说还有因请求该资源而被阻塞的进程。</li>
<li>S.value &lt;= 0时的<strong>绝对值</strong>，<strong>表示等待进程数目</strong>。</li>
</ul>
</li>
<li><p>有关信号量的初始值</p>
<ul>
<li><strong>互斥</strong>信号量：一般初始化为<strong>1</strong></li>
<li><strong>同步</strong>信号量<ul>
<li>若<strong>期望的信息未产生</strong>，初始化为 <strong>0</strong></li>
<li>若<strong>期望的消息已存在</strong>，初始化为<strong>一个非 0 的正整数</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>（★★★★★）有关死锁极端情况的分析</p>
<ul>
<li>3 个并发进程，都需要 4 个同类资源，必然不会发生死锁的最少资源为 ？<ul>
<li>考虑死锁情况：每个进程分配了 3 个资源，都拿不到第 4 个，形成死锁。此时有 9 个资源</li>
<li>在上述死锁条件下，加一个资源，则必有一个进程可以先拿到 4 个，完成后释放，使得其他进程也能完成。</li>
<li>所以最少 10 个</li>
</ul>
</li>
<li>11 个磁带机， X 个进程共享，每个最多请求 3 台，必然不会死锁的 X 的最大值为 ？<ul>
<li>考虑死锁情况：每个进程分配了 2 个资源，都拿不到第 3 个，形成死锁。此时有 2X 个资源</li>
<li>2X + 1 个则不会</li>
<li>2X + 1 = 11，解得 X = 5</li>
</ul>
</li>
<li>8 个打印机， K 个进程竞争使用，每个最多请求 3 台，可能发生死锁的 X 的最小值为 ？<ul>
<li>考虑死锁情况：每个进程分配了 2 个资源，都拿不到第 3 个，形成死锁。此时有 2K 个资源</li>
<li>2K = 8，解得 K = 4</li>
</ul>
</li>
<li>n 台互斥使用的同类设备，三个并发进程，分别需要 3、4、5 台，确保不发生死锁的 n 最小值为 ？<ul>
<li>考虑死锁情况：三个进程分别拿到 2、3、4 个资源，都拿不到它们所期望的最后一个资源，形成死锁。此时有 9 个资源</li>
<li>再加一个，就不会有死锁了。即 10 个满足题意</li>
</ul>
</li>
<li><strong>总结</strong>：考虑这样一种死锁情况，即每个并发进程分配的<strong>资源数为给它所需要资源数减一</strong>。若要不死锁，那么在上述已分配资源数之和的基础上<strong>加上一</strong>即可。</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>计算机操作系统.汤小丹等</li>
<li>2020年操作系统考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习笔记1-概述</title>
    <url>/2019/09/04/cao-zuo-xi-tong-fu-xi-bi-ji-1-gai-shu/</url>
    <content><![CDATA[<h1 id="1．操作系统概述"><a href="#1．操作系统概述" class="headerlink" title="1．操作系统概述"></a>1．操作系统概述</h1><h2 id="操作系统的概念、特征、功能和提供的服务"><a href="#操作系统的概念、特征、功能和提供的服务" class="headerlink" title="操作系统的概念、特征、功能和提供的服务"></a>操作系统的概念、特征、功能和提供的服务</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>（详见教材）</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>并发（<strong>最基本</strong>）<ul>
<li>概念辨析：并发 VS 并行<ul>
<li>并发：<strong>同一时间间隔</strong></li>
<li>并行：<strong>同一时刻</strong></li>
</ul>
</li>
</ul>
</li>
<li>共享（<strong>最基本</strong>）</li>
<li>虚拟</li>
<li>异步</li>
</ul>
<h3 id="功能和提供服务"><a href="#功能和提供服务" class="headerlink" title="功能和提供服务"></a>功能和提供服务</h3><ul>
<li>计算机系统资源的管理者</li>
<li>用户与计算机系统之间的接口<ul>
<li>命令接口<ul>
<li>终端交互式命令行（联机）</li>
<li>批处理指令（脱机）</li>
</ul>
</li>
<li>程序接口<ul>
<li>系统调用（又称<strong>广义指令</strong>）</li>
</ul>
</li>
<li>GUI</li>
</ul>
</li>
<li>扩充机器</li>
</ul>
<h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><ul>
<li>手工操作（此时无操作系统）</li>
<li>批处理<ul>
<li>单道</li>
<li>多道</li>
</ul>
</li>
<li>分时</li>
<li>实时</li>
<li>网络及分布式</li>
<li>个人</li>
</ul>
<h2 id="操作系统的基本结构"><a href="#操作系统的基本结构" class="headerlink" title="操作系统的基本结构"></a>操作系统的基本结构</h2><h3 id="大内核"><a href="#大内核" class="headerlink" title="大内核"></a>大内核</h3><p>（详见教材）</p>
<h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>（详见教材）</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>计算机操作系统.汤小丹等</li>
<li>2020年操作系统考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构复习笔记8-排序</title>
    <url>/2019/08/29/shu-ju-jie-gou-fu-xi-bi-ji-8-pai-xu/</url>
    <content><![CDATA[<h1 id="9．内部排序"><a href="#9．内部排序" class="headerlink" title="9．内部排序"></a>9．内部排序</h1><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待排序的存储结构</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20              <span class="comment">// 顺序表最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;            <span class="comment">// 定义关键字类型为整数类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    KeyType  key;               <span class="comment">// 关键字项</span></span><br><span class="line">    InfoType otherinfo;         <span class="comment">// 其他数据项</span></span><br><span class="line">&#125;RedType;                       <span class="comment">// 记录类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    RedType r[MAXSIZE + <span class="number">1</span>];     <span class="comment">// r[0] 闲置或做哨兵单元</span></span><br><span class="line">    <span class="keyword">int</span> length;                 <span class="comment">// 顺序表长度</span></span><br><span class="line">&#125;SqList;                        <span class="comment">// 顺序表类型</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 10.1</span></span><br><span class="line"><span class="comment">// 对顺序表 L 作直接插入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= L,length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(LT(L.r[i].key, L.r[i<span class="number">-1</span>].key))<span class="comment">// “小于”，需将L.r[i]插入到有序表（若大于，则无需以下操作，注意这个判定条件）</span></span><br><span class="line">        &#123;</span><br><span class="line">            L.r[<span class="number">0</span>] = L.r[i];            <span class="comment">// 复制为“哨兵”</span></span><br><span class="line">            L.r[i] = L.r[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(j = i - <span class="number">2</span>; LT(L.r[<span class="number">0</span>].key, L.r[j].key); --j)</span><br><span class="line">                L.r[j + <span class="number">1</span>] = L.r[j];    <span class="comment">// 记录后移</span></span><br><span class="line">            L.r[j + <span class="number">1</span>] = L.r[<span class="number">0</span>];        <span class="comment">// 插入到正确的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="折半插入"><a href="#折半插入" class="headerlink" title="折半插入"></a>折半插入</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 10.2</span></span><br><span class="line"><span class="comment">// 对顺序表 L 作折半插入排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= L.length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L.r[<span class="number">0</span>] = L.r[i];         <span class="comment">// 哨兵</span></span><br><span class="line">        low = <span class="number">1</span>;    high = i - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)       <span class="comment">// 在r[low...high]中折半查找有序插入的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            m = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(LT(L.r[<span class="number">0</span>].key, L.r[m].key))</span><br><span class="line">                high = m - <span class="number">1</span>;              <span class="comment">// 插入点在低半区</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = m + <span class="number">1</span>;               <span class="comment">// 插入点在高半区</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; --j)</span><br><span class="line">            L.r[j + <span class="number">1</span>] = L.r[j];           <span class="comment">// 记录后移</span></span><br><span class="line">        </span><br><span class="line">        L.r[high + <span class="number">1</span>] = L.r[<span class="number">0</span>];            <span class="comment">// 插入（注意插入位置为 high + 1）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>性能分析<ul>
<li>空间复杂度：$O(1)$</li>
<li>时间复杂度：$O(n)$</li>
</ul>
</li>
</ul>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 10.4</span></span><br><span class="line"><span class="comment">// 对顺序表 L 做一趟希尔插入排序。本算法和一趟直接插入排序相比，</span></span><br><span class="line"><span class="comment">// 做了如下修改</span></span><br><span class="line"><span class="comment">// 1. 前后记录位置的增量是 dk，而不是 1</span></span><br><span class="line"><span class="comment">// 2. r[0] 知识暂存单元，不是哨兵。当 j &lt;= 0 时，插入位置已找到</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> dk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = dk + <span class="number">1</span>; i &lt;= L.length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(LT(L.r[i],key, L.r[i - dk],key))  <span class="comment">// 需将 L.r[i] 插入到有序表</span></span><br><span class="line">        &#123;</span><br><span class="line">            L.r[<span class="number">0</span>] = L.r[i];             <span class="comment">// 暂存在 L,r[0]</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; LT(L.r[<span class="number">0</span>].key, L.r[j].key); j -= dk)</span><br><span class="line">                L.r[j + dk] = L.r[j];    <span class="comment">// 记录后移，查找插入位置</span></span><br><span class="line">            </span><br><span class="line">            L.r[j+dk] = L.r[<span class="number">0</span>];          <span class="comment">// 插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 10.5</span></span><br><span class="line"><span class="comment">// 按增量序列 dlta[0...t-1]对顺序表 L 做希尔排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList &amp;L. <span class="keyword">int</span> dlta[], <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; t; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        ShellInsert(L, dlta[k]);    <span class="comment">// 一趟增量为 dlta[k]的插入排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用冒泡排序法将序列 A 中的元素按从小到大顺序排列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;               <span class="comment">// 表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt; i; j--)    <span class="comment">// 一趟排序的过程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>].key &gt; A[j].key) <span class="comment">// 若为逆序</span></span><br><span class="line">            &#123;</span><br><span class="line">                swap(A[j<span class="number">-1</span>], A[j]);   <span class="comment">// 交换</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag = <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span> ;              <span class="comment">//（注意！！！） 本次遍历后没有发生交换，说明表已经有序。直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 10.6(b)</span></span><br><span class="line"><span class="comment">// 交换顺序表 L 中子表 r[low..high]的记录，枢轴记录到位，</span></span><br><span class="line"><span class="comment">// 并返回其所在位置，此时在它之前（后）的记录均不大（小）于它</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.r[<span class="number">0</span>] = L.r[low];</span><br><span class="line">    pivotkey = L.r[low].key;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)              <span class="comment">// 从表的两端交替地向中间扫描</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey)</span><br><span class="line">            --high;</span><br><span class="line">        </span><br><span class="line">        L.r[low] = L.r[high];      <span class="comment">// 将比枢轴记录小的记录移到低端</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey)</span><br><span class="line">            ++low;</span><br><span class="line">        </span><br><span class="line">        L.r[high] = L.r[low];      <span class="comment">// 将比枢轴记录大的记录移到高端</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    L.r[low] = L.r[<span class="number">0</span>];             <span class="comment">// 枢轴记录到位</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> low;                    <span class="comment">// 返回枢轴位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)                           <span class="comment">// 长度大于 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        pivotloc = Partition(L, low, high);  <span class="comment">// 将 L.r[low..high] 一分为二</span></span><br><span class="line">        QSort(L, low, pivotloc - <span class="number">1</span>);         <span class="comment">// 对低子表递归排序，pivotloc 是枢轴位置</span></span><br><span class="line">        QSort(L, pivotloc + <span class="number">1</span>, high);        <span class="comment">// 对高子表递归排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择"><a href="#简单选择" class="headerlink" title="简单选择"></a>简单选择</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 10.9</span></span><br><span class="line"><span class="comment">// 对顺序表 L 作简单选择排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; L.length; ++i)    <span class="comment">// 选择第 i 小的记录并交换到位</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">min</span> = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++)   <span class="comment">// 在 L.r[i..L.length]中选择 key 最小的记录</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L.r[j].key &lt; L.r[<span class="built_in">min</span>].key)</span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span> != i)                 <span class="comment">// 交换</span></span><br><span class="line">            swap(L[i], L[<span class="built_in">min</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SqList HeapType;    <span class="comment">// 堆采用顺序表存储表示</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 10.10</span></span><br><span class="line"><span class="comment">// 已知H.r[s..m]中记录的关键字除H.r[s].key之外均满足堆的定义，</span></span><br><span class="line"><span class="comment">// 本函数调整 H.r[s]的关键字，使H.r[s..m]成为一个大顶堆</span></span><br><span class="line"><span class="comment">//（对其中记录的关键字而言）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType &amp;H, <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rc = H.r[s];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span>)       <span class="comment">// 沿 key 较大的孩子结点向下筛选</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; m &amp;&amp; LT(H.r[j].key, H[j+<span class="number">1</span>].key))</span><br><span class="line">            ++j;                         <span class="comment">// j 为 key 较大的记录的下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(! LT(rc.key, H.r[j].key))     <span class="comment">// rc 应插入在位置 s 记录的下标</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        H.r[s] = H.r[j];</span><br><span class="line">        s = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    H.r[s] = rc;                         <span class="comment">// 插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 10.11</span></span><br><span class="line"><span class="comment">// 对顺序表 H 进行堆排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(HeapType &amp;H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = H.length / <span class="number">2</span>; i &gt; <span class="number">0</span>; --i)     <span class="comment">// 把 H.r[1..H.length] 建成大顶堆</span></span><br><span class="line">    &#123;</span><br><span class="line">        HeapAdjust(H, i, H.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = H.length; i &gt; <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(H.r[<span class="number">1</span>], H.r[i]);             <span class="comment">// 将堆顶记录和当前未经排序子序列 H.r[1..i] 中最后一个记录相互交换        </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    HeapAdjust(H, <span class="number">1</span>, i - <span class="number">1</span>);              <span class="comment">// 将 H.r[1..i-1] 重新调整为大顶堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 10.12</span></span><br><span class="line"><span class="comment">// 将有序的 SR[i..m] 和 SR[m+1..n] 归并为有序的 TR[i..n]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(RcdType SR[], RcdType &amp;TR[], <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = m + <span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; ++k)<span class="comment">// 将 SR 中记录由小到大地并入 TR</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注: LQ 表示 ≤</span></span><br><span class="line">        <span class="keyword">if</span>(LQ(SR[i].key, SR[j].key))</span><br><span class="line">            TR[k] = SR[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TR[k] = SR[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i &lt;= m)    TR[k..n] = SR[i..m];          <span class="comment">// 将剩余的 SR[i..m] 复制到 TR</span></span><br><span class="line">    <span class="keyword">if</span>(j &lt;= n)    TR[k..n] = SR[j..n];          <span class="comment">// 将剩余的 SR[j..n] 复制到 TR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 10.13</span></span><br><span class="line"><span class="comment">// 将 SR[s..t] 归并排序为 TR1[s..t]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(RcdType SR[], RcdType &amp;TR1[], <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t)</span><br><span class="line">        TR1[s] = SR[s];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m = (s + t) / <span class="number">2</span>;           <span class="comment">// 平分</span></span><br><span class="line">        MSort(SR, TR2, s, m);      <span class="comment">// 递归排序</span></span><br><span class="line">        MSort(SR, TR2, m + <span class="number">1</span>, t);  <span class="comment">// 递归排序</span></span><br><span class="line">        Merge(TR2, TR1, s, m, t);  <span class="comment">// 合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ul>
<li>主要思想：依据关键字的各个位的大小依次排序</li>
</ul>
<h2 id="内部排序算法的比较和应用"><a href="#内部排序算法的比较和应用" class="headerlink" title="内部排序算法的比较和应用"></a>内部排序算法的比较和应用</h2><table>
<thead>
<tr>
<th align="center">算法种类</th>
<th align="center">最好时间复杂度</th>
<th align="center">平均时间复杂度</th>
<th align="center">最坏时间复杂度</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">直接插入</td>
<td align="center">$O(n)$（待排序序列为<strong>正序</strong>）</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$（待排序序列为<strong>逆序</strong>）</td>
<td align="center">$O(1)$</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">冒泡</td>
<td align="center">$O(n)$（待排序序列为<strong>正序</strong>）</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$（待排序序列为<strong>逆序</strong>）</td>
<td align="center">$O(1)$</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">简单选择</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">希尔</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">$O(1)$</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">快排</td>
<td align="center">$O(nlog_2n)$（每次的枢轴划分把表等分为<strong>长度相近</strong>的两个子表）</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(n^2)$（待排序序列<strong>有序</strong>或<strong>基本有序</strong>）</td>
<td align="center">$O(log_2n)$</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(1)$</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">2 路归并</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(n)$</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">基数</td>
<td align="center">$O(d(n+r))$</td>
<td align="center">$O(d(n+r))$</td>
<td align="center">$O(d(n+r))$</td>
<td align="center">$O(r)$</td>
<td align="center">是</td>
</tr>
</tbody></table>
<h1 id="部分算法手算小结"><a href="#部分算法手算小结" class="headerlink" title="部分算法手算小结"></a>部分算法手算小结</h1><h2 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入-1"><a href="#直接插入-1" class="headerlink" title="直接插入"></a>直接插入</h3><ul>
<li>把这个过程想象成抓牌，对牌排序的过程<ul>
<li>抓牌</li>
<li>比较：和当前最后一个牌比较<ul>
<li>若大于，则插在当前有序表最后（算法流程中，此步不做）</li>
<li>若小于，则进入下一步</li>
</ul>
</li>
<li>查找插入位置，并插入：有序表中<strong>从后往前</strong>顺序查找新抓到的牌在有序表中合适的位置，在此过程中融入了移动元素。找到位置后，元素也移动完了，可以直接插入。</li>
</ul>
</li>
</ul>
<h3 id="折半插入-1"><a href="#折半插入-1" class="headerlink" title="折半插入"></a>折半插入</h3><ul>
<li>和直接插入不同，折半插入将<strong>比较查找</strong>和<strong>移动元素</strong>分离。</li>
<li>整个流程概括如下：<ul>
<li>在当前有序表中<strong>折半查找</strong>新元素待插入的的位置（请关注一下算法中的<strong>插入位置</strong>）。</li>
<li>以此插入位置，确定需要移动元素的范围，将元素移动到位。</li>
<li>插入新元素</li>
</ul>
</li>
</ul>
<h3 id="希尔排序-1"><a href="#希尔排序-1" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul>
<li>以间隔将待排序列分组，组内直接插入排序</li>
<li>缩小间隔，重复上述操作，直至间隔为 1。</li>
</ul>
<h2 id="交换排序-1"><a href="#交换排序-1" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>每趟<strong>从后往前</strong>，若相邻元素为<strong>逆序</strong>，则交换。</li>
</ul>
<h3 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h3><ul>
<li>划分<ul>
<li>对照算法，手算模拟</li>
</ul>
</li>
<li>排序<ul>
<li>递归的进行</li>
</ul>
</li>
</ul>
<h2 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择-1"><a href="#简单选择-1" class="headerlink" title="简单选择"></a>简单选择</h3><ul>
<li>在未有序序列部分，选择最小【从小到大排列】（或最大【从大到小】），依次与当前未有序的头部元素交换，完成一趟简单选择排序</li>
</ul>
<h3 id="堆排序（★★★★★★★★）"><a href="#堆排序（★★★★★★★★）" class="headerlink" title="堆排序（★★★★★★★★）"></a>堆排序（★★★★★★★★）</h3><ul>
<li>在理解堆排序之前，先来理解以下堆的几个基本操作<ul>
<li>堆的建立</li>
<li>堆的插入</li>
<li>堆的删除</li>
</ul>
</li>
</ul>
<h4 id="堆的建立（利用堆的向下调整）"><a href="#堆的建立（利用堆的向下调整）" class="headerlink" title="堆的建立（利用堆的向下调整）"></a>堆的建立（利用堆的向下调整）</h4><ul>
<li>从堆的<strong>最后一个结点</strong>（即完全二叉树的最后一个叶子结点）开始循环，依次进行如下操作：<ul>
<li>找到其父亲结点（设为 <em>P</em> ）</li>
<li>比较 <em>P</em> 和其两个孩子结点的大小关系（下述流程和<strong>向下调整</strong>（父和子比较，父向下调整）类似）<ul>
<li>如果满足堆的定义，则进行下一轮迭代（在向下调整中，此步直接 break，即对结点 <em>P</em> 的调整结束）</li>
<li>如果不满足<ul>
<li>小根堆情况：选择 key 值<strong>较小</strong>的孩子（设为 <em>C</em> ），与父亲<em>P</em> 交换</li>
<li>大根堆情况：选择 key 值<strong>较大</strong>的孩子（设为 <em>C</em> ），与父亲<em>P</em> 交换</li>
<li>（！！！）注意事项：经过此次交换，可能引起交换后父亲结点所在的那个结点（也就是交换前的孩子结点，即为 C ）所在子树不满足堆的定义。此时，要进一步检查 <em>P</em> 和其左右子树的关系，依据条件进行交换操作，直至检查到叶子结点。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="堆的插入（利用堆的向上调整）"><a href="#堆的插入（利用堆的向上调整）" class="headerlink" title="堆的插入（利用堆的向上调整）"></a>堆的插入（利用堆的向上调整）</h4><ul>
<li>将新结点插入到堆的<strong>末端</strong>，利用<strong>向上调整</strong>，使满足堆的定义。</li>
<li>向上调整（子和父比较，子向上调整）流程简述<ul>
<li>从新插入的结点开始循环，依次比较其与其父结点的大小关系<ul>
<li>若不满足，则交换位置</li>
<li>否则，结束循环，当前位置即为新插入结点的满足堆定义的位置。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="堆的删除（利用堆的向下调整）"><a href="#堆的删除（利用堆的向下调整）" class="headerlink" title="堆的删除（利用堆的向下调整）"></a>堆的删除（利用堆的向下调整）</h4><ul>
<li>交换<strong>堆顶元素</strong>（即是完全二叉树的根）和<strong>堆的最后一个元素</strong>（及完全二叉树的最后一个叶子结点）（或者是删除堆顶的元素，用堆的最后一个元素补位）</li>
<li>对当前堆（除最后一个元素）进行向下调整（类似堆的建立，但是开始结点和调整范围不同，这里的向下调整的结点范围是从 1 到 n - 1，即是<strong>从头向后</strong>，进行调整），使满足堆的定义</li>
</ul>
<h4 id="利用堆的建立、删除理解堆排序"><a href="#利用堆的建立、删除理解堆排序" class="headerlink" title="利用堆的建立、删除理解堆排序"></a>利用堆的建立、删除理解堆排序</h4><ul>
<li>初始建堆</li>
<li>依次对堆顶元素进行删除操作（选择交换元素，而非删除元素）</li>
<li>最终对堆的完全二叉树进行层序遍历，即可得到有序序列。</li>
</ul>
<h2 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li>仅讨论二路归并<ul>
<li>首先，将待排序序列分为两两一组，然后使得组内有序；</li>
<li>接着，将上述有序组，两两一组，有序合并；</li>
<li>重复第二步，直至所有序列合并成一组</li>
</ul>
</li>
</ul>
<h1 id="解题技巧及重要结论"><a href="#解题技巧及重要结论" class="headerlink" title="解题技巧及重要结论"></a>解题技巧及重要结论</h1><ul>
<li>已知希尔排序某一趟排序后的序列，如何确定本次使用的增量？<ul>
<li>抓住<strong>组内有序（从小到大或者从大到小）</strong>这个关键点，从间隔为 1 开始依次验证，直至找到满足的最小间隔，即为本趟希尔排序使用的增量。</li>
</ul>
</li>
<li>快排的重要性质<ul>
<li>第 <em>i</em> 趟排序完成时，会有 <em>i</em> 个以上的数<strong>出现在它最终将要出现的位置</strong>（这个位置就是排序<strong>最终结果的位置</strong>），即<strong>它左边的数都比它小，它右边的数都比它大</strong>。（可用于判定某一序列是否是某趟快排后的序列）</li>
</ul>
</li>
<li>在含有 <em>n</em> 个关键字的<strong>小根堆</strong>中，关键字<strong>最大</strong>的记录可能存储在什么位置？<ul>
<li>小根堆 + 关键字最大的条件意味着，该记录在堆的<strong>叶子节点</strong>。</li>
<li>而堆是一棵<strong>完全二叉树</strong>，其叶子结点位置范围为 $[\lfloor\frac{n}{2}\rfloor+1, n]$</li>
<li>在叶子结点位置范围中的点都可能</li>
</ul>
</li>
<li>向一个具有 <em>n</em> 个结点的堆中插入一个新元素的时间复杂度为 $O(log_2n)$ ，删除一个元素的时间复杂度为 $O(log_2n)$ </li>
<li>构建 <em>n</em> 个记录的初始堆，时间复杂度为 $O(n)$ （<strong>对比上条</strong>）；对 <em>n</em> 个记录进行堆排序，最坏情况下其时间复杂度为 $O(nlog_2n)$</li>
<li>初始序列<strong>基本有序</strong>时，<strong>插入排序</strong>比较次数较少。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>数据结构（C语言版）.严蔚敏等</li>
<li>2020年数据结构考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构复习笔记7-查找</title>
    <url>/2019/08/21/shu-ju-jie-gou-fu-xi-bi-ji-7-cha-zhao/</url>
    <content><![CDATA[<h1 id="8．查找"><a href="#8．查找" class="headerlink" title="8．查找"></a>8．查找</h1><h2 id="顺序表查找；有序表查找；索引顺序表查找"><a href="#顺序表查找；有序表查找；索引顺序表查找" class="headerlink" title="顺序表查找；有序表查找；索引顺序表查找"></a>顺序表查找；有序表查找；索引顺序表查找</h2><h3 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 9.1</span></span><br><span class="line"><span class="comment">// 在顺序表 ST 中顺序查找其关键字等于 key 的数据元素。若找到，</span></span><br><span class="line"><span class="comment">// 则函数值为该元素在表中的位置，否则为 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>].key = key;      <span class="comment">// “哨兵”</span></span><br><span class="line">                               <span class="comment">// 从后往前找</span></span><br><span class="line">    <span class="keyword">for</span>(i - ST.length; !EQ(ST.elem[i].key, key); --i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i;                  <span class="comment">// 找不到时， i 为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 9.2</span></span><br><span class="line"><span class="comment">// 在有序表 ST 中折半查找其关键字等于 key 的数据元素。若找到，</span></span><br><span class="line"><span class="comment">// 则函数值为该元素在表中的位置，否则为 0 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low = <span class="number">1</span>; high = ST.length;            <span class="comment">// 置区间初值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(EQ(key, ST.elem[mid],key))</span><br><span class="line">            <span class="keyword">return</span> mid;                   <span class="comment">// 找到待查元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(LT(key, ST.elem[mid].key))<span class="comment">// 在前半部分找</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>                              <span class="comment">// 在后半部分找</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="索引顺序表查找"><a href="#索引顺序表查找" class="headerlink" title="索引顺序表查找"></a>索引顺序表查找</h3><ul>
<li>存储结构：原表 + 索引表<ul>
<li>索引表的建立：对表进行从前到到后按原来的顺序分块，每块找出<strong>最大值</strong>（作为索引表的关键字），和块在表中的范围（如<strong>块起始地址</strong>）一起存储在另一个表中（这个表便叫做<strong>索引表</strong>）。对索引表按关键字排序，则可使得原表分块有序。</li>
</ul>
</li>
<li>查找流程：<ol>
<li>先在索引表中查找（顺序、二分均可），根据待查关键字和索引的比较，确定下一步在原表中查找范围。</li>
<li>然后在上一步得到的范围基础上在原表对应位置区间顺序查找。</li>
</ol>
</li>
</ul>
<h2 id="二叉排序树；平衡二叉树；B-树"><a href="#二叉排序树；平衡二叉树；B-树" class="headerlink" title="二叉排序树；平衡二叉树；B-树"></a>二叉排序树；平衡二叉树；B-树</h2><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>定义：二叉排序树或者是一棵空树，或者是一棵具有下列特性的非空二叉树：<ul>
<li>若左子树非空，则左子树上所有结点的关键字值均<strong>小于</strong>根节点的关键字值</li>
<li>若右子树非空，则右子树上所有结点的关键字值均<strong>大于</strong>根节点的关键字值</li>
<li>左、右子树本身也分别是一棵二叉排序树</li>
</ul>
</li>
<li>重要结论（★★★）：对二叉排序树进行<strong>中序遍历</strong>，可得到一个<strong>递增有序</strong>的序列</li>
</ul>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">SearchBST</span><span class="params">(BiTree T,KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 在根指针T所指二叉排序树中递归地查找某关键字等于key的数据元素， */</span></span><br><span class="line">    <span class="comment">/* 若查找成功，则返回指向该数据元素结点的指针,否则返回空指针。算法9.5(a) */</span></span><br><span class="line">    <span class="keyword">if</span>((!T)||EQ(key,T-&gt;data.key))</span><br><span class="line">        <span class="keyword">return</span> T; <span class="comment">/* 查找结束 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> LT(key,T-&gt;data.key) <span class="comment">/* 在左子树中继续查找 */</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild,key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild,key); <span class="comment">/* 在右子树中继续查找 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SearchBST1</span><span class="params">(BiTree *T,KeyType key,BiTree f,BiTree *p,Status *flag)</span> <span class="comment">/* 算法9.5(b)改 */</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 在根指针T所指二叉排序树中递归地查找其关键字等于key的数据元素，若查找 */</span></span><br><span class="line">    <span class="comment">/* 成功，则指针p指向该数据元素结点，并返回TRUE，否则指针p指向查找路径上 */</span></span><br><span class="line">    <span class="comment">/* 访问的最后一个结点并返回FALSE,指针f指向T的双亲，其初始调用值为NULL */</span></span><br><span class="line">    <span class="keyword">if</span>(!*T) <span class="comment">/* 查找不成功 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        *p=f;</span><br><span class="line">        *flag=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> EQ(key,(*T)-&gt;data.key) <span class="comment">/*  查找成功 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        *p=*T;</span><br><span class="line">        *flag=TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> LT(key,(*T)-&gt;data.key)</span><br><span class="line">        SearchBST1(&amp;(*T)-&gt;lchild,key,*T,p,flag); <span class="comment">/* 在左子树中继续查找 */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        SearchBST1(&amp;(*T)-&gt;rchild,key,*T,p,flag); <span class="comment">/*  在右子树中继续查找 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree *T, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 当二叉排序树T中不存在关键字等于e.key的数据元素时，插入e并返回TRUE， */</span></span><br><span class="line">    <span class="comment">/* 否则返回FALSE。算法9.6(改) */</span></span><br><span class="line">    BiTree p,s;</span><br><span class="line">    Status flag;</span><br><span class="line">    SearchBST1(T,e.key,<span class="literal">NULL</span>,&amp;p,&amp;flag);</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="comment">/* 查找不成功 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        s=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        s-&gt;data=e;</span><br><span class="line">        s-&gt;lchild=s-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">            *T=s; <span class="comment">/* 被插结点*s为新的根结点 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> LT(e.key,p-&gt;data.key)</span><br><span class="line">            p-&gt;lchild=s; <span class="comment">/* 被插结点*s为左孩子 */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;rchild=s; <span class="comment">/* 被插结点*s为右孩子 */</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE; <span class="comment">/* 树中已有关键字相同的结点，不再插入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(BiTree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 从二叉排序树中删除结点p，并重接它的左或右子树。算法9.8 */</span></span><br><span class="line">    BiTree q,s;</span><br><span class="line">    <span class="keyword">if</span>(!(*p)-&gt;rchild) <span class="comment">/* 右子树空则只需重接它的左子树（待删结点是叶子也走此分支） */</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=*p;</span><br><span class="line">        *p=(*p)-&gt;lchild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(*p)-&gt;lchild) <span class="comment">/* 只需重接它的右子树 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=*p;</span><br><span class="line">        *p=(*p)-&gt;rchild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 左右子树均不空 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=*p;</span><br><span class="line">        s=(*p)-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild) <span class="comment">/* 转左，然后向右到尽头（找待删结点的前驱） */</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=s;</span><br><span class="line">            s=s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        (*p)-&gt;data=s-&gt;data; <span class="comment">/* s指向被删结点的＂前驱＂（将被删结点前驱的值取代被删结点的值） */</span></span><br><span class="line">        <span class="keyword">if</span>(q!=*p)</span><br><span class="line">            q-&gt;rchild=s-&gt;lchild; <span class="comment">/* 重接*q的右子树 */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lchild=s-&gt;lchild; <span class="comment">/* 重接*q的左子树 */</span></span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree *T,KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点， */</span></span><br><span class="line">    <span class="comment">/* 并返回TRUE；否则返回FALSE。算法9.7 */</span></span><br><span class="line">    <span class="keyword">if</span>(!*T) <span class="comment">/* 不存在关键字等于key的数据元素 */</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> EQ(key,(*T)-&gt;data.key) <span class="comment">/* 找到关键字等于key的数据元素 */</span></span><br><span class="line">            Delete(T);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> LT(key,(*T)-&gt;data.key)</span><br><span class="line">            DeleteBST(&amp;(*T)-&gt;lchild,key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            DeleteBST(&amp;(*T)-&gt;rchild,key);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/08/21/RightEmpty.jpg?raw=true" alt="右子树空"></p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/08/21/LeftEmpty.jpg?raw=true" alt="左子树空"></p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/08/21/NotNULL.jpg?raw=true" alt="左右均不空"></p>
<h3 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>任意节点的左、右子树高度差的绝对值不超过 1 的排序二叉树。</li>
</ul>
<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><ul>
<li><p>插入流程类似排序二叉树，但插入过程中需要保证其平衡，所以可能需要对树进行旋转。下面列举了各种旋转的情况：</p>
<ol>
<li><p>LL 平衡旋转</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/08/21/LL.jpg?raw=true" alt="LL平衡旋转"></p>
</li>
<li><p>RR 平衡旋转</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/08/21/RR.jpg?raw=true" alt="RR平衡旋转"></p>
</li>
<li><p>LR 平衡旋转</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/08/21/LR.jpg?raw=true" alt="LR平衡旋转"></p>
</li>
<li><p>RL 平衡旋转</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/08/21/RL.jpg?raw=true" alt="RL平衡旋转"></p>
</li>
</ol>
</li>
</ul>
<h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><ul>
<li>查找过程与排序查找树类似</li>
<li>（★★★★★）重要结论 1 ：假设以 $n_h$ 表示深度为 $h$ 的平衡树中含有的<strong>最少结点数</strong>，则有</li>
</ul>
<p>$$<br>n_0 = 0,n_1 = 1,n_2 =2<br>$$</p>
<p>并且<br>$$<br>n_h=n_{h-1}+n_{h-2}+1<br>$$</p>
<ul>
<li>（★★★★★）重要结论 2 ：含有 $n$ 个结点的平衡二叉树的最大深度为 $O(log_2n)$ </li>
</ul>
<h3 id="B-树（部分书上写成-B-树）"><a href="#B-树（部分书上写成-B-树）" class="headerlink" title="B-树（部分书上写成 B 树）"></a>B-树（部分书上写成 B 树）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul>
<li>一棵 m 阶 B 树或为空树，或为满足如下特性的 m 叉树<ol>
<li>树的每个结点至多有 m 棵子树（即<strong>至多有 m-1 个关键字</strong>）</li>
<li>若<strong>根</strong>结点不是终端结点，则<strong>至少有两棵子树</strong>（即<strong>至少有 1 个关键字</strong>）</li>
<li>除<strong>根结点</strong>外的所有非叶子结点至少有 $\lceil \frac{m}{2}\rceil$ 棵子树（即<strong>至少有 $\lceil \frac{m}{2}\rceil -1$ 个关键字</strong>）</li>
<li>所有非叶子结点结构如下：</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">n</th>
<th align="center">$P_0$</th>
<th align="center">$K_1$</th>
<th align="center">$P_1$</th>
<th align="center">$K_2$</th>
<th align="center">$P_2$</th>
<th align="center">$\cdots$</th>
<th align="center">$P_n$</th>
<th align="center">$K_n$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关键字个数</td>
<td align="center">指向子树的根结点指针 0</td>
<td align="center">关键字 1</td>
<td align="center">指向子树的根结点指针 1</td>
<td align="center">关键字 2</td>
<td align="center">指向子树的根结点指针 2</td>
<td align="center"></td>
<td align="center">指向子树的根结点指针 n</td>
<td align="center">关键字 n</td>
</tr>
</tbody></table>
<p>其中 $K_i&lt;K_j, 当i&lt;j​$ </p>
<p>$P_{i-1}$ 所指子树中的所有结点的关键字均<strong>小于</strong> $K_i$ </p>
<p>$P_i​$ 所指子树中的所有结点的关键字均<strong>大于</strong> $K_i​$ </p>
<p>（★★★★★）$\lceil \frac{m}{2}\rceil -1\le n\le  m-1​$</p>
<h4 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h4><ul>
<li><strong>不包括</strong>最后的不带任何信息的叶结点所处的那一层</li>
<li>（★★★★★）取值范围</li>
</ul>
<p>$$<br>log_m(n+1)\le h \le log_{\lceil \frac{m}{2}\rceil}(\frac{n+1}{2})+1<br>$$</p>
<h4 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h4><ul>
<li>类似二叉查找树，只不过有多路分支</li>
</ul>
<h4 id="（★★★★★）插入"><a href="#（★★★★★）插入" class="headerlink" title="（★★★★★）插入"></a>（★★★★★）插入</h4><ul>
<li>插入流程<ul>
<li>定位：找到利用查找算法找到插入位置</li>
<li>插入<ul>
<li>若插入后<strong>结点关键字个数 &lt; m</strong>，可直接插入</li>
<li>若插入后<strong>结点关键字个数 &gt; m - 1</strong>，则需<strong>分裂</strong><ul>
<li>（★★★★★）分裂方法<ul>
<li>在插入位置处新建一个兄弟节点，从中间位置($\lceil \frac{m}{2}\rceil$) 将关键字分为左右部分</li>
<li>左部分放在原结点，右部分放在新结点，中间的结点放在父结点</li>
<li>若此时使得父结点关键字也超过了上限，那么以此类推，直至传到根结点。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/08/21/Divide.jpg?raw=true" alt="分裂"></p>
<h4 id="（★★★★★）删除"><a href="#（★★★★★）删除" class="headerlink" title="（★★★★★）删除"></a>（★★★★★）删除</h4><ul>
<li>当所删除的关键字 <em>k</em> 不在终端结点（这里的终端结点指最底层非叶子结点，下同）<ol>
<li>若<strong>小于</strong> <em>k</em> 的子树中关键字个数 &gt; $\lceil \frac{m}{2}\rceil -1​$ ，则找出（中序）<strong>前驱值</strong> <em>k’</em> ，并用 <em>k’</em> 取代 <em>k</em> ，再递归地删除 <em>k’</em> 即可</li>
<li>若<strong>大于</strong> <em>k</em> 的子树中关键字个数 &gt; $\lceil \frac{m}{2}\rceil -1$ ，则找出（中序）<strong>后继值</strong> <em>k’</em> ，并用 <em>k’</em> 取代 <em>k</em> ，再递归地删除 <em>k’</em> 即可（前两点貌似与二叉排序树中的删除类似）</li>
<li>若前后两个子树中关键字个数 均为 $\lceil \frac{m}{2}\rceil -1$ ，则直接将两个子结点合并，再直接删除 <em>k</em> 即可（如下图）</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/08/21/Merge.jpg?raw=true" alt="非终端合并"></p>
<ul>
<li>当所删除的关键字 <em>k</em> 在终端结点<ol>
<li>若被删除关键字所在结点的关键字个数 &gt; $\lceil \frac{m}{2}\rceil -1$ ，则直接删除</li>
<li>兄弟够借（如下图）</li>
<li>兄弟不够借（如下图）</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/08/21/EndPoint.jpg?raw=true" alt="终端兄弟借"></p>
<h2 id="哈希表的构造和冲突处理方法"><a href="#哈希表的构造和冲突处理方法" class="headerlink" title="哈希表的构造和冲突处理方法"></a>哈希表的构造和冲突处理方法</h2><h3 id="哈希表的构造"><a href="#哈希表的构造" class="headerlink" title="哈希表的构造"></a>哈希表的构造</h3><ul>
<li>这里的构造通常指哈希函数的构造。下面是几种构造方法<ol>
<li><strong>直接定址法</strong>：取关键字或关键字的某个线性函数值为哈希地址</li>
<li><strong>数字分析法</strong>：设关键字是 <em>r</em> 进制数，而 <em>r</em> 个数码在各位上出现的频率不一定相同。此时应该选取数码<strong>分布较为均匀的若干位</strong>作为散列地址。此法适用于<strong>已知关键字集合</strong>的情况。若换了关键字，则需重新构造散列函数</li>
<li><strong>平方取中法</strong>：取关键字<strong>平方后的中间几位</strong>为哈希地址</li>
<li><strong>折叠法</strong>：将关键字分割成位数相同的几部分，然后取这几个部分的叠加和（舍去进位）作为哈希地址。这种方法适用于<strong>关键字位数很多、而且关键字中每一位上数字分布大致均匀</strong>的情况</li>
<li><strong>除留余数法</strong>：取<strong>关键字被某个不大于哈希表长的 p 除后所得余数</strong>作为哈希地址</li>
<li><strong>随机数法</strong></li>
</ol>
</li>
</ul>
<h3 id="哈希冲突处理方法"><a href="#哈希冲突处理方法" class="headerlink" title="哈希冲突处理方法"></a>哈希冲突处理方法</h3><ol>
<li><strong>开放定址法</strong> $H_i=(H(key)+d_i)%m$<ol>
<li>$d_i=0，1，2，\cdots$时，称为<strong>线性探测法</strong></li>
<li>$d_i=0^2,1^2,-1^2,2^2,-2^2，\cdots$时，称为<strong>平方探测法</strong></li>
<li>$d_i=Hash_2(key)$ 时，称为<strong>再散列</strong>，此时 $H_i=(H(key)+i\times Hash_2(key )%m$</li>
<li>$d_i$ 为伪随机数序列时，称为<strong>伪随机序列法</strong></li>
</ol>
</li>
<li><strong>拉链法</strong><ul>
<li>即把冲突的同义词连成一个链表。链表表头构成一个数组</li>
</ul>
</li>
</ol>
<h1 id="解题技巧小结及结论补充"><a href="#解题技巧小结及结论补充" class="headerlink" title="解题技巧小结及结论补充"></a>解题技巧小结及结论补充</h1><ul>
<li>折半查找<strong>在查找不成功</strong>和<strong>给定值进行关键字的比较次数最多</strong>这两种情况，都是在求<strong>树的高度</strong>，即$\lceil log_2(n+1)\rceil$ </li>
<li>折半查找中平局查找长度的计算（画<strong>判定树</strong>求解）<ul>
<li>查找<strong>成功</strong>的平均查找长度<ul>
<li>$ASL=\frac{\sum每层结点数\times 当前层数(从1取)}{总判定树结点数}​$</li>
</ul>
</li>
<li>查找<strong>失败</strong>的平均查找长度<ul>
<li>$ASL=\frac{\sum 判定失败的结点数\times 当前层数}{总判定失败结点数}​$</li>
</ul>
</li>
</ul>
</li>
<li>（★★★★★）顺序查找<strong>成功</strong>的平均查找长度公式<ul>
<li>$ASL=\frac{n+1}{2}$ ，其中 <em>n</em> 为元素个数</li>
</ul>
</li>
<li><em>n</em> 个记录的索引顺序表最理想的块长为 $\sqrt{n}$ </li>
<li>索引顺序表的平均查找长度的计算<ul>
<li>$ASL= 块间顺序查找+快内顺序查找$ </li>
<li>根据上述公式，将对应部分的元素个数带入公式即可</li>
</ul>
</li>
<li>如何判定序列满足<strong>折半查找</strong>或者<strong>二叉排序树</strong>序列？<ul>
<li>注意到两者的序列都可以表示成对一棵树的从根结点沿着某一路径一直访问到叶子结点。</li>
<li>其中，这棵树满足<strong>任一节点大于</strong>其<strong>左子树</strong>的任意一个结点，<strong>小于</strong>其<strong>右子树</strong>的任意一个结点。</li>
<li>根据序列<strong>第一个元素</strong>，确定<strong>根结点</strong>；根据下一个元素和当前位置的<strong>大小关系</strong>，确定下一个元素相对于当前元素的位置（<strong>左子树</strong>还是<strong>右子树</strong>）。确定位置后，注意检查，是否满足树的要求（即上述第二点的性质）</li>
</ul>
</li>
<li>对 <em>B-</em> 树的正确理解<ul>
<li>5 阶 <em>B-</em> 树中各个结点包含的关键字为 2 时，也满足要求（不要误以为要至少存在一个含关键字 4 [ $5-1$ ] 个的结点才满足）。也就是每个结点的个数在 $\lceil \frac{m}{2}\rceil -1\le n\le  m-1$ 范围内即可（其中，<em>m</em> 为阶数）</li>
</ul>
</li>
<li>在开址法中散列到同一地址二引起的“堆积”问题是由于<strong>同义词之间或非同义词之间发生冲突</strong>引起的（<strong>非同义词</strong>！！！）</li>
<li>在开放定址法解决冲突的散列表查找中，发生聚集的原因主要是<strong>解决冲突的方法选择不当</strong></li>
<li>在散列表中，<strong>平局查找长度</strong>与<strong>装填因子</strong> $\alpha$ 直接相关，不依赖于已有表项数或表长。若散列表中存放的都是某个地址的同义词，则平均查找长度为 $O(n)$ </li>
<li>用逐点法插入构造二叉树时，若先后插入的关键字<strong>有序</strong>，则二叉排序树<strong>深度最大</strong>。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>数据结构（C语言版）.严蔚敏等</li>
<li>2020年数据结构考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构复习笔记6-图</title>
    <url>/2019/08/06/shu-ju-jie-gou-fu-xi-bi-ji-6-tu/</url>
    <content><![CDATA[<h1 id="7．图"><a href="#7．图" class="headerlink" title="7．图"></a>7．图</h1><h2 id="图的基本概念；图的存储表示：邻接矩阵、邻接表"><a href="#图的基本概念；图的存储表示：邻接矩阵、邻接表" class="headerlink" title="图的基本概念；图的存储表示：邻接矩阵、邻接表"></a>图的基本概念；图的存储表示：邻接矩阵、邻接表</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>详细见教材 7.1 节</p>
<h3 id="存储表示"><a href="#存储表示" class="headerlink" title="存储表示"></a>存储表示</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><ul>
<li>存储</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图的邻接矩阵存储表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用矩阵来存储顶点之间的连接关系</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY        INT_MAX              <span class="comment">// 最大值 正无穷</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM  20                   <span class="comment">// 最大顶点个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG, DN, UDG, UDN&#125; GraphKind;   <span class="comment">// &#123;有向图，有向网，无向图。无向网&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcCell</span>&#123;</span></span><br><span class="line">    VRType    adj;                           <span class="comment">// VRType 是顶点关系类型</span></span><br><span class="line">                                             <span class="comment">// 对无权图：</span></span><br><span class="line">                                             <span class="comment">// 用 1，0 代表相邻否</span></span><br><span class="line">                                             <span class="comment">// 对带权图：</span></span><br><span class="line">                                             <span class="comment">// 为权值类型</span></span><br><span class="line">    InfoType  *info;                         <span class="comment">// 该弧相关信息指针</span></span><br><span class="line">&#125;ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VEXTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType vexs[MAX_VERTEX_NUM];         <span class="comment">// 顶点向量</span></span><br><span class="line">    AdjMatrix  arcs;                         <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span>        vexnum, arcnum;               <span class="comment">// 图的当前顶点数和弧数</span></span><br><span class="line">    GraphKind  kind;                         <span class="comment">// 图的种类标志</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p>更适合存储<strong>稠密图</strong>，容易判定任意两个顶点是否有边连接</p>
</li>
<li><p>顶点度的计算</p>
<ul>
<li>无向图：</li>
</ul>
<p>$$<br>TD(v_i) = \sum^{n-1}_{j=0}{A[i][j]},n = MAX_VERTEX_NUM（即第 i 行元素之和）<br>$$</p>
<ul>
<li>有向图</li>
</ul>
<p>$$<br>OD(v_i) = \sum^{n-1}_{j=0}{A[i][j]},n = MAX_VERTEX_NUM（即第 i 行元素之和）<br>$$</p>
<p>$$<br>ID(v_j) = \sum_{i=0}^{n-1}A[i][j],n = MAX_VERTEX_NUM（即第 j 列元素之和）<br>$$</p>
<ul>
<li>对于<strong>网</strong>，对应度的大小，便是数对应位置的的<strong>非 $\infty$ 的个数</strong></li>
</ul>
</li>
</ul>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图的邻接表存储表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对图的每一个顶点建立一个单链表，其后连接与之相邻接的顶点</span></span><br><span class="line"><span class="comment">// 每个顶点的单链表的头存储在一个数组中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>            adjvex;         <span class="comment">// 该弧所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span>       <span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">    InfoType       *info;          <span class="comment">// 该弧相关信息的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组定义（用于存储单链表的头）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    VertexType    data;            <span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode       *firstarc;       <span class="comment">// 指向第一条依附该顶点的弧的指针</span></span><br><span class="line">&#125;VNode, AdjList[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表图的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList       vertices;</span><br><span class="line">    <span class="keyword">int</span>           vexnum, arcnum;  <span class="comment">// 图的当前顶点数和弧数</span></span><br><span class="line">    <span class="keyword">int</span>           kind;            <span class="comment">// 图的种类标志</span></span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>更适合存储<strong>稀疏图</strong>，容易寻找任意一个顶点的第一个邻接点和下一个邻接点。</li>
<li>顶点度的计算<ul>
<li>无向图：顶点 $v_i​$ 的度为第 $i​$ 个链表中的结点数（头节点本身不算）</li>
<li>有向图：顶点 $v_i$ 的<strong>出度</strong>为第 $i$ 个链表中的结点数（头节点本身不算）；<strong>入度</strong>则要遍历整个图</li>
<li>对于<strong>网</strong>，与上述方法对应相同</li>
</ul>
</li>
</ul>
<h2 id="图的遍历与连通性"><a href="#图的遍历与连通性" class="headerlink" title="图的遍历与连通性"></a>图的遍历与连通性</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面两个算法用到的全局变量</span></span><br><span class="line"></span><br><span class="line">Boolean visited[MAX];         <span class="comment">// 访问标志数组</span></span><br><span class="line">Status (*VisitFunc)(<span class="keyword">int</span> v);   <span class="comment">// 函数变量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 7.4</span></span><br><span class="line"><span class="comment">// 对图 G 做深度优先遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G, Status(* Visit)(<span class="keyword">int</span> v))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VisitFunc = Visit;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; ++v)    visited[v] = FALSE; <span class="comment">// 标志数组初始化</span></span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; V &lt; G.vexnum; ++ v)</span><br><span class="line">        <span class="keyword">if</span>(! visited[v])</span><br><span class="line">            DFS(G, v);                                   <span class="comment">// 对未访问的顶点调用 DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 7.5</span></span><br><span class="line"><span class="comment">// 从第 v 个结点出发，递归的深度优先遍历图 G</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[v] = TRUE;    VisitFunc(v);       <span class="comment">// 访问第 v 个顶点</span></span><br><span class="line">    <span class="keyword">for</span>(w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = nextAdjVex(G, v, w))</span><br><span class="line">        <span class="keyword">if</span>(! visited[w])</span><br><span class="line">            DFS(G, v);                        <span class="comment">// 对 v 尚未访问的邻接顶点 w 递归调用 DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>性能分析<ul>
<li>空间复杂度：$O( |V| )​$，其中$ |V|​$ 为顶点数，下同</li>
<li>时间复杂度<ul>
<li>邻接矩阵存储：$O( |V|^2 )$</li>
<li>邻接表存储：$O(|V|+|E|)$ ，其中 $|E|​$ 为边数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 7.6</span></span><br><span class="line"><span class="comment">// 按广度优先非递归遍历图 G。使用辅助队列 Q 和访问数组 visited</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G, Status(* Visit)(<span class="keyword">int</span> v))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; ++v)    visited[v] = FALSE;</span><br><span class="line">    InitQueue(Q);                    <span class="comment">// 置空的辅助队列 Q</span></span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        <span class="keyword">if</span>( !visited[v])             <span class="comment">// v 未被访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            visited[v] = TRUE;    Visit(v);</span><br><span class="line">            EnQueue(Q, v);           <span class="comment">// v 入队</span></span><br><span class="line">            <span class="keyword">while</span>(! QueueEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                DeQueue(Q, u);       <span class="comment">// 出队，并置为 u</span></span><br><span class="line">                <span class="keyword">for</span>(w = FirstAdjVex(G, u); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, u, w))</span><br><span class="line">                    <span class="keyword">if</span>(! visited[w]) <span class="comment">// w 为 u 的尚未访问的邻接顶点</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        visited[w] = TRUE;</span><br><span class="line">                        Visit(w);</span><br><span class="line">                        EnQueue(Q, w);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>性能分析（与 DFS 相同）</li>
</ul>
<h3 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><ul>
<li>通过遍历，可以判断图的连通性<ul>
<li>无向图<ul>
<li>若<strong>连通</strong>，从任意一个顶点出发，只需<strong>一次遍历</strong>就能访问到途中<strong>所有顶点</strong></li>
<li>若<strong>非连通</strong>，从某一顶点出发，一次遍历只能访问到该顶点<strong>所在连通分量</strong>的所有顶点</li>
</ul>
</li>
<li>有向图<ul>
<li>若初始点到图中所有顶点都有路径，则能够访问到图中所有的顶点；否则不能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="普里姆（Prim）算法"><a href="#普里姆（Prim）算法" class="headerlink" title="普里姆（Prim）算法"></a>普里姆（Prim）算法</h3><ul>
<li>流程简述<ul>
<li>初始化：向空树 $T=(V_T,E_T)$ 中添加图 $G=(V,E)$ 的任一顶点 $u_0$ ，使 $V_T = {u_0}$ ， $E_T=\varnothing​$ </li>
<li>循环（重复下列操作至 $V_T=V$）：从图 $G$ 中选择满足 ${(u,v)|u\in V_T, v\in V-V_T}$ 且具有最小权值的边 $(u,v)$ ，并置 $V_T=V_T\cup {v}$ ， $E_T=E_T\cup {(u,v)}​$</li>
</ul>
</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(G, T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = 空集;                 <span class="comment">// 初始化空树</span></span><br><span class="line">    U = &#123;w&#125;;                 <span class="comment">// 添加任一顶点 w</span></span><br><span class="line">    <span class="keyword">while</span>((V-U) != 空集)      <span class="comment">// 若树中不含全部顶点</span></span><br><span class="line">    &#123;</span><br><span class="line">        设 (u,v) 是使 u∈U 与 v∈(V-U)，且权值最小的边;</span><br><span class="line">        T = T∪&#123;(u, v)&#125;;     <span class="comment">// 边归入树</span></span><br><span class="line">        U = U∪&#123;v&#125;;          <span class="comment">// 顶点归入树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>性能分析<ul>
<li>时间复杂度：$O( |V| ^2)$</li>
</ul>
</li>
<li>适用于求解<strong>边稠密</strong>的图的最小生成树</li>
</ul>
<h3 id="克鲁斯卡尔（Kruskal）算法"><a href="#克鲁斯卡尔（Kruskal）算法" class="headerlink" title="克鲁斯卡尔（Kruskal）算法"></a>克鲁斯卡尔（Kruskal）算法</h3><ul>
<li>流程简述<ul>
<li>初始化： $V_T = V ​$ ， $E_T=\varnothing​$ 。即每个顶点构成一颗独立的树， $T​$ 此时是一个仅含 $|V|​$ 个顶点的森林</li>
<li>循环（重复下列操作至 $T$ 是一棵树）：按 $G$ 的边权值递增的顺序依次从 $E-E_T$ 中选择一条边，若这条边加入 $T$ 后不构成回路，则将其加入 $E_T$ ，否则舍弃，直到 $E_T$ 中含有 $n-1$ 条边</li>
</ul>
</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(V, T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = V;                  <span class="comment">// 初始化树 T，仅含顶点</span></span><br><span class="line">    numS = n;               <span class="comment">// 连通分量数</span></span><br><span class="line">    <span class="keyword">while</span>(numS &gt; <span class="number">1</span>)         <span class="comment">// 若连通分量数大于 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        从 E 中取出权值最小的边 (v,u);</span><br><span class="line">        <span class="keyword">if</span>(v 和 u 属于 T 中不同的连通分量)</span><br><span class="line">        &#123;</span><br><span class="line">            T = T∪&#123;(v, u)&#125;; <span class="comment">// 边归入树</span></span><br><span class="line">            numS--;          <span class="comment">// 连通分量减1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>性能分析<ul>
<li>时间复杂度：$O(|E|log|E|)​$</li>
</ul>
</li>
<li>适用于求解<strong>边稀疏</strong>而<strong>顶点较多</strong>的图的最小生成树</li>
</ul>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul>
<li>流程简述<ul>
<li>在有向图中选择一个没有前驱的顶点并输出</li>
<li>从图中删除该顶点和以它为尾的弧</li>
<li>重复以上两步，直至全部顶点均以输出</li>
</ul>
</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TopologicalSort</span><span class="params">(ALGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 有向图G采用邻接表存储结构。若G无回路,则输出G的顶点的一个拓扑序列并返回OK, */</span></span><br><span class="line">    <span class="comment">/* 否则返回ERROR。算法7.12 */</span></span><br><span class="line">    <span class="keyword">int</span> i,k,count,indegree[MAX_VERTEX_NUM];</span><br><span class="line">    SqStack S;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    FindInDegree(G,indegree); <span class="comment">/* 对各顶点求入度indegree[0..vernum-1] */</span></span><br><span class="line">    InitStack(&amp;S); <span class="comment">/* 初始化栈 */</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i) <span class="comment">/* 建零入度顶点栈S */</span></span><br><span class="line">        <span class="keyword">if</span>(!indegree[i])</span><br><span class="line">            Push(&amp;S,i); <span class="comment">/* 入度为0者进栈 */</span></span><br><span class="line">    count=<span class="number">0</span>; <span class="comment">/* 对输出顶点计数 */</span></span><br><span class="line">    <span class="keyword">while</span>(!StackEmpty(S))</span><br><span class="line">    &#123; <span class="comment">/* 栈不空 */</span></span><br><span class="line">        Pop(&amp;S,&amp;i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>,G.vertices[i].data); <span class="comment">/* 输出i号顶点并计数 */</span></span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)</span><br><span class="line">        &#123; <span class="comment">/* 对i号顶点的每个邻接点的入度减1 */</span></span><br><span class="line">            k=p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[k])) <span class="comment">/* 若入度减为0,则入栈 */</span></span><br><span class="line">                Push(&amp;S,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;G.vexnum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"此有向图有回路\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"为一个拓扑序列。\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>性能分析<ul>
<li>时间复杂度：$O(|V|+|E|)$ </li>
</ul>
</li>
</ul>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TopologicalOrder</span><span class="params">(ALGraph G,SqStack *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 算法7.13  有向网G采用邻接表存储结构,求各顶点事件的最早发生时间ve */</span></span><br><span class="line">    <span class="comment">/* (全局变量)。T为拓扑序列顶点栈,S为零入度顶点栈。若G无回路,则用栈T */</span></span><br><span class="line">    <span class="comment">/* 返回G的一个拓扑序列,且函数值为OK,否则为ERROR */</span></span><br><span class="line">    <span class="keyword">int</span> j,k,count,indegree[MAX_VERTEX_NUM];</span><br><span class="line">    SqStack S;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    FindInDegree(G,indegree);<span class="comment">/*对各顶点求入度indegree[0..vernum-1] */</span></span><br><span class="line">    InitStack(&amp;S); <span class="comment">/* 初始化栈 */</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;++j) <span class="comment">/* 建零入度顶点栈S */</span></span><br><span class="line">        <span class="keyword">if</span>(!indegree[j])</span><br><span class="line">            Push(&amp;S,j); <span class="comment">/* 入度为0者进栈 */</span></span><br><span class="line">    InitStack(T); <span class="comment">/* 初始化拓扑序列顶点栈 */</span></span><br><span class="line">    count=<span class="number">0</span>; <span class="comment">/* 对输出顶点计数 */</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;++j) <span class="comment">/* 初始化ve[]=0 (最小值) */</span></span><br><span class="line">        ve[j]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!StackEmpty(S))</span><br><span class="line">    &#123; <span class="comment">/* 栈不空 */</span></span><br><span class="line">        Pop(&amp;S,&amp;j);</span><br><span class="line">        Push(T,j); <span class="comment">/* j号顶点入T栈并计数 */</span></span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[j].firstarc;p;p=p-&gt;nextarc)</span><br><span class="line">        &#123; <span class="comment">/* 对j号顶点的每个邻接点的入度减1 */</span></span><br><span class="line">            k=p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(--indegree[k]==<span class="number">0</span>) <span class="comment">/* 若入度减为0,则入栈 */</span></span><br><span class="line">                Push(&amp;S,k);</span><br><span class="line">            <span class="keyword">if</span>(ve[j]+*(p-&gt;info)&gt;ve[k])</span><br><span class="line">                ve[k]=ve[j]+*(p-&gt;info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;G.vexnum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"此有向网有回路\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CriticalPath</span><span class="params">(ALGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 算法7.14 G为有向网,输出G的各项关键活动 */</span></span><br><span class="line">    <span class="keyword">int</span> vl[MAX_VERTEX_NUM];</span><br><span class="line">    SqStack T;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,ee,el;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">char</span> dut,tag;</span><br><span class="line">    <span class="keyword">if</span>(!TopologicalOrder(G,&amp;T)) <span class="comment">/* 产生有向环 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    j=ve[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.vexnum;i++) <span class="comment">/* j=Max(ve[]) 完成点的值 */</span></span><br><span class="line">        <span class="keyword">if</span>(ve[i]&gt;j)</span><br><span class="line">            j=ve[i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++) <span class="comment">/* 初始化顶点事件的最迟发生时间(最大值) */</span></span><br><span class="line">        vl[i]=j; <span class="comment">/* 完成点的最早发生时间 */</span></span><br><span class="line">    <span class="keyword">while</span>(!StackEmpty(T)) <span class="comment">/* 按拓扑逆序求各顶点的vl值 */</span></span><br><span class="line">        <span class="keyword">for</span>(Pop(&amp;T,&amp;j),p=G.vertices[j].firstarc;p;p=p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            k=p-&gt;adjvex;</span><br><span class="line">            dut=*(p-&gt;info); <span class="comment">/* dut&lt;j,k&gt; */</span></span><br><span class="line">            <span class="keyword">if</span>(vl[k]-dut&lt;vl[j])</span><br><span class="line">                vl[j]=vl[k]-dut;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" j  k  dut  ee  el  tag\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;++j) <span class="comment">/* 求ee,el和关键活动 */</span></span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[j].firstarc;p;p=p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            k=p-&gt;adjvex;</span><br><span class="line">            dut=*(p-&gt;info);</span><br><span class="line">            ee=ve[j];</span><br><span class="line">            el=vl[k]-dut;</span><br><span class="line">            tag=(ee==el)?<span class="string">'*'</span>:<span class="string">' '</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d %2d %3d %3d %3d    %c\n"</span>,j,k,dut,ee,el,tag); <span class="comment">/* 输出关键活动 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"关键活动为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;++j) <span class="comment">/* 同上 */</span></span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[j].firstarc;p;p=p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            k=p-&gt;adjvex;</span><br><span class="line">            dut=*(p-&gt;info);</span><br><span class="line">            <span class="keyword">if</span>(ve[j]==vl[k]-dut)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s→%s\n"</span>,G.vertices[j].data,G.vertices[k].data); <span class="comment">/* 输出关键活动 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>性能分析<ul>
<li>时间复杂度：$O(|V|+|E|)​$ </li>
</ul>
</li>
</ul>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(MGraph G,<span class="keyword">int</span> v0,PathMatrix *P,ShortPathTable *D)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 用Dijkstra算法求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度 */</span></span><br><span class="line">    <span class="comment">/* D[v]。若P[v][w]为TRUE,则w是从v0到v当前求得最短路径上的顶点。 */</span></span><br><span class="line">    <span class="comment">/* final[v]为TRUE当且仅当v∈S,即已经求得从v0到v的最短路径 算法7.15 */</span></span><br><span class="line">    <span class="keyword">int</span> v,w,i,j,<span class="built_in">min</span>;</span><br><span class="line">    Status <span class="keyword">final</span>[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">final</span>[v]=FALSE;</span><br><span class="line">        (*D)[v]=G.arcs[v0][v].adj;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;++w)</span><br><span class="line">            (*P)[v][w]=FALSE; <span class="comment">/* 设空路径 */</span></span><br><span class="line">        <span class="keyword">if</span>((*D)[v]&lt;INFINITY)</span><br><span class="line">        &#123;</span><br><span class="line">            (*P)[v][v0]=TRUE;</span><br><span class="line">            (*P)[v][v]=TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (*D)[v0]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[v0]=TRUE; <span class="comment">/* 初始化,v0顶点属于S集 */</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.vexnum;++i) <span class="comment">/* 其余G.vexnum-1个顶点 */</span></span><br><span class="line">    &#123; <span class="comment">/* 开始主循环,每次求得v0到某个v顶点的最短路径,并加v到S集 */</span></span><br><span class="line">        <span class="built_in">min</span>=INFINITY; <span class="comment">/* 当前所知离v0顶点的最近距离 */</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;++w)</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">final</span>[w]) <span class="comment">/* w顶点在V-S中 */</span></span><br><span class="line">                <span class="keyword">if</span>((*D)[w]&lt;<span class="built_in">min</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    v=w;</span><br><span class="line">                    <span class="built_in">min</span>=(*D)[w];</span><br><span class="line">                &#125; <span class="comment">/* w顶点离v0顶点更近 */</span></span><br><span class="line">        <span class="keyword">final</span>[v]=TRUE; <span class="comment">/* 离v0顶点最近的v加入S集 */</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;++w) <span class="comment">/* 更新当前最短路径及距离 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">final</span>[w]&amp;&amp;<span class="built_in">min</span>&lt;INFINITY&amp;&amp;G.arcs[v][w].adj&lt;INFINITY&amp;&amp;(<span class="built_in">min</span>+G.arcs[v][w].adj&lt;(*D)[w]))</span><br><span class="line">            &#123; <span class="comment">/* 修改D[w]和P[w],w∈V-S */</span></span><br><span class="line">                (*D)[w]=<span class="built_in">min</span>+G.arcs[v][w].adj;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;++j)</span><br><span class="line">                    (*P)[w][j]=(*P)[v][j];</span><br><span class="line">                (*P)[w][w]=TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>性能分析<ul>
<li>时间复杂度：$O(|V|^2)​$ </li>
</ul>
</li>
</ul>
<h3 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_FLOYD</span><span class="params">(MGraph G,PathMatrix *P,DistancMatrix *D)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 用Floyd算法求有向网G中各对顶点v和w之间的最短路径P[v][w]及其 */</span></span><br><span class="line">    <span class="comment">/* 带权长度D[v][w]。若P[v][w][u]为TRUE,则u是从v到w当前求得最短 */</span></span><br><span class="line">    <span class="comment">/* 路径上的顶点。算法7.16 */</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w,i;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;v++) <span class="comment">/* 各对结点之间初始已知路径及距离 */</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)</span><br><span class="line">        &#123;</span><br><span class="line">            (*D)[v][w]=G.arcs[v][w].adj;</span><br><span class="line">            <span class="keyword">for</span>(u=<span class="number">0</span>;u&lt;G.vexnum;u++)</span><br><span class="line">                (*P)[v][w][u]=FALSE;</span><br><span class="line">            <span class="keyword">if</span>((*D)[v][w]&lt;INFINITY) <span class="comment">/* 从v到w有直接路径 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                (*P)[v][w][v]=TRUE;</span><br><span class="line">                (*P)[v][w][w]=TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(u=<span class="number">0</span>;u&lt;G.vexnum;u++)</span><br><span class="line">        <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;v++)</span><br><span class="line">            <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)</span><br><span class="line">                <span class="keyword">if</span>((*D)[v][u]+(*D)[u][w]&lt;(*D)[v][w]) <span class="comment">/* 从v经u到w的一条路径更短 */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    (*D)[v][w]=(*D)[v][u]+(*D)[u][w];</span><br><span class="line">                    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">                        (*P)[v][w][i]=(*P)[v][u][i]||(*P)[u][w][i];</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>性能分析<ul>
<li>时间复杂度：$O(|V|^3)​$ </li>
</ul>
</li>
</ul>
<h1 id="解题技巧小结及结论补充"><a href="#解题技巧小结及结论补充" class="headerlink" title="解题技巧小结及结论补充"></a>解题技巧小结及结论补充</h1><h2 id="图的应用相关算法手算流程小结"><a href="#图的应用相关算法手算流程小结" class="headerlink" title="图的应用相关算法手算流程小结"></a>图的应用相关算法手算流程小结</h2><h3 id="最小生成树-1"><a href="#最小生成树-1" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h4><ul>
<li>集合定义<ul>
<li>$V_T$ ：最小生成树中间结果的点集（初始化，任取一点，或题设给出）； </li>
<li>$V-V_T$ ：还未归入最小生成树的点集</li>
</ul>
</li>
<li>循环（直到 $V_T = V$）<ul>
<li>$V_T$ 中取一点 $u$ ， $V-V_T$ 中取一点 $v$ ，使得 $(u,v)$ 权值最小。</li>
<li>将 $v$ 并入集合 $V_T$</li>
</ul>
</li>
</ul>
<h4 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h4><ul>
<li>集合定义<ul>
<li>$V_T$ ：最小生成树的点集（初始化为 $V$ ，即包含所有图中的点）</li>
<li>$E_T$ ：存储最小生成树生成过程中边的集合（初始化为 $\varnothing$）</li>
</ul>
</li>
<li>循环（直至 $T​$ 是一棵树）<ul>
<li>按 $G$ 的边<strong>权值递增</strong>的顺序依次从 $E-E_T$ 中选择一条边，若这条边加入 $T$ 后<strong>不构成回路</strong>，则将其加入 $E_T$ ，否则舍弃，直到 $E_T$ 中含有 $n-1$ 条边</li>
</ul>
</li>
</ul>
<h3 id="最短路径-1"><a href="#最短路径-1" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h4><ul>
<li>利用表格法求解</li>
</ul>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2019/08/06/2016.png?raw=true" alt="2016统考真题"></p>
<ul>
<li>画下面的表格<ul>
<li>起点直接能到达的结点在表格中的位置处填入，路径和对应长度。</li>
<li>不能直接到达的填正无穷。</li>
<li>将这一列的路径使得路径长度最短的结点（该路径此时的终点），并入集合 S 中（起点默认已经并入）</li>
<li>基于上一步得到的路径，看其终点有没有与其他点（这里的其他点 $\in V-S$）之间相连。有的话，计算这个新的路径长度，并与上一个（对应行的左边一个）比较：若更小，则更新；否则照抄。</li>
<li>由此得到新的一列，继续比较路径大小。然后，选择最小的，将对应的结点并入 S 。</li>
<li>以此类推，得到以下表格：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">i=1</th>
<th align="center">i= 2</th>
<th align="center">i=3</th>
<th align="center">i=4</th>
<th align="center">i=5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1（起点）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">（1，2）、5</td>
<td align="center"><strong>（1，2）、5（小）</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">$\infty$</td>
<td align="center">$\infty$</td>
<td align="center"><strong>（1，2，3）、7（小）</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">$\infty$</td>
<td align="center">（1，5，4）、11</td>
<td align="center">（1，5，4）、11</td>
<td align="center">（1，5，4）、11</td>
<td align="center"><strong>（1，5，4）、11</strong></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><strong>（1，5）、4（小）</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">$\infty$</td>
<td align="center">（1，5，6）、9</td>
<td align="center">（1，5，6）、9</td>
<td align="center"><strong>（1，5，6）、9（小）</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">{1，<strong>5</strong>}</td>
<td align="center">{1，5，<strong>2</strong>}</td>
<td align="center">{1，5，2，<strong>3</strong>}</td>
<td align="center">{1，5，2，3，<strong>6</strong>}</td>
<td align="center">{1，5，2，3，6，<strong>4</strong>}</td>
</tr>
</tbody></table>
<h4 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h4><ul>
<li>初始化 $dis^{(-1)}$ 为图的邻接矩阵</li>
<li>循环（邻接矩阵有 n 阶，外层就循环 n 次【从 0 到 n - 1】，主要是为了取将要加入以下路径点的点，设为 $V_{intermediate}$）</li>
<li>内部再套两个循环（主要是为了取任意两个点的组合，设这两个点为</li>
</ul>
<p>$$<br>V_{source}和V_{end}<br>$$</p>
<p>​    ）比较<br>$$<br>(1)\ Weight(V_{source},V_{intermediate})+Weight(V_{intermediate}, V_{end})<br>$$</p>
<p>​    和<br>$$<br>(2)\ Weight(V_{source},V_{end})<br>$$<br>​    大小，若（1）式更小，则更新对应 $dis^{i}​$ （<em>i</em> 代表循环变量【从 0 开始】）的 </p>
<p>​    $V_{source}$所在<strong>行</strong>，</p>
<p>​    $V_{end}$所在<strong>列</strong>处的值</p>
<p>​    为 （1）式子的结果。</p>
<h3 id="拓扑排序-1"><a href="#拓扑排序-1" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul>
<li>较简单，具体见上</li>
</ul>
<h3 id="关键路径-1"><a href="#关键路径-1" class="headerlink" title="关键路径"></a>关键路径</h3><ul>
<li>几个时间的计算<ul>
<li>顶点相关<ul>
<li>事件 $v_k​$ 最早发生的时间 $v_e(k)​$<ul>
<li><strong>从前往后</strong>算，计算从源点到当前点最长的路径长度。</li>
<li><strong>入度＞1 要注意</strong>，要取<strong>和最大</strong></li>
</ul>
</li>
<li>事件 $v_k$ 最迟发生的时间$v_l(k)$<ul>
<li><strong>从后往前算</strong>（通常是后一个结点的最迟时间，减去这两点之间的权值）</li>
<li><strong>出度＞1 要注意</strong>，要取<strong>差最小</strong></li>
</ul>
</li>
</ul>
</li>
<li>弧相关<ul>
<li>活动 $a_i$ 最早开始时间 $e(i)$<ul>
<li>设 $a_i$ 夹在两个顶点 $v_k,v_j$ 之间，且 $v_k$ 在前，则$e(i) = v_e(k)​$ （即<strong>前一个顶点最早发生时间</strong>）</li>
</ul>
</li>
<li>活动 $a_i$ 最迟开始时间 $l(i)$<ul>
<li>设 $a_i$ 夹在两个顶点 $v_k,v_j$ 之间，且 $v_k$ 在前，则$l(i) = v_l(k)-Weight(v_k,v_j)$ （即<strong>后一个顶点最迟发生时间【减去】两点之间的权值</strong>）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="图的重要概念辨析及相关重要结论"><a href="#图的重要概念辨析及相关重要结论" class="headerlink" title="图的重要概念辨析及相关重要结论"></a>图的重要概念辨析及相关重要结论</h2><h3 id="重要概念辨析"><a href="#重要概念辨析" class="headerlink" title="重要概念辨析"></a>重要概念辨析</h3><h4 id="无向完全图-VS-有向完全图"><a href="#无向完全图-VS-有向完全图" class="headerlink" title="无向完全图 VS 有向完全图"></a>无向完全图 VS 有向完全图</h4><ul>
<li><strong>无向完全图</strong>：任意两个顶点都<strong>存在边</strong></li>
<li><strong>有向完全图</strong>：任意两个顶点都存在<strong>相反的两条弧</strong></li>
</ul>
<h4 id="强连通图-VS-连通图"><a href="#强连通图-VS-连通图" class="headerlink" title="强连通图 VS 连通图"></a>强连通图 VS 连通图</h4><ul>
<li><strong>强连通图</strong>：（针对<strong>有向图</strong>）任意一对顶点都是<strong>强连通的</strong>（若从顶点 <em>v</em> 到 <em>w</em> 和 <em>w</em> 到<em>v</em> 都有路径，则这两个顶点是<strong>强连通的</strong>）</li>
<li><strong>连通图</strong>：（针对<strong>无向图</strong>）任意两个顶点都是<strong>连通的</strong>（若从顶点 <em>v</em> 到 <em>w</em> 有路径，则这两个顶点是<strong>连通的</strong>）</li>
</ul>
<h4 id="强连通分量-VS-连通分量"><a href="#强连通分量-VS-连通分量" class="headerlink" title="强连通分量 VS 连通分量"></a>强连通分量 VS 连通分量</h4><ul>
<li><strong>强连通分量</strong>：（针对<strong>有向图</strong>）即为有向图中的<strong>极大强连通子图</strong></li>
<li><strong>连通分量</strong>：（针对<strong>无向图</strong>）即为无向图中的<strong>极大连通子图</strong></li>
</ul>
<h3 id="重要结论"><a href="#重要结论" class="headerlink" title="重要结论"></a>重要结论</h3><ul>
<li>非连通图的判定：$|V| = n\ 且\ |E| &lt;n-1$ </li>
<li>无向图顶点的度:</li>
</ul>
<p>$$<br>\sum^{n}<em>{i=1}TD(v</em>{i})=2|E|<br>$$</p>
<ul>
<li>有向图顶点的度:</li>
</ul>
<p>$$<br>\sum^{n}<em>{i=1}ID(v</em>{i})=\sum^{n}<em>{i=1}OD(v</em>{i})= |E|<br>$$</p>
<ul>
<li><strong>边数最少</strong>：对于<strong>连通无向图</strong>，即构成一棵树；对于<strong>强连通有向图</strong>，即构成一个<strong>有向环</strong></li>
<li>一些极端情况可以考虑<strong>完全图</strong>、<strong>环</strong>等作为排除选项的反例。</li>
<li>图与树遍历关系<ul>
<li><strong>广度优先搜索</strong>相当于二叉树中的<strong>层序遍历</strong></li>
<li><strong>深度优先搜索</strong>相当于树中的<strong>先序遍历</strong></li>
</ul>
</li>
<li>广度优先搜索可用于解决<strong>无权（或等权）单源最短路径</strong>问题</li>
<li><strong>遍历唯一性</strong><ul>
<li><strong>邻接矩阵</strong>存储：唯一</li>
<li><strong>邻接表</strong>存储：不唯一</li>
</ul>
</li>
<li>有向图中的<strong>回路判定</strong>方法<ul>
<li>拓扑排序</li>
<li><strong>深度优先搜索</strong>：如果遍历过程中，将要访问的结点<strong>已在栈中</strong>，则有回路。</li>
</ul>
</li>
<li>DFS入栈顺序<strong>拓扑有序</strong></li>
<li>一个连通图的<strong>生成树</strong>是图的<strong>极小</strong>连通子图</li>
<li>最小生成树的性质<ul>
<li><strong>一般形状不唯一</strong>（当图中<strong>各边权值互不相等</strong>，最小生成树唯一）</li>
<li><strong>权值和唯一</strong></li>
<li>（★★★）<strong>边数 = 顶点数 - 1</strong></li>
</ul>
</li>
<li>单源最短路径，使用 <strong>Dijkstra</strong> ；每对顶点的的最短路径，使用 <strong>Floyd</strong></li>
<li><strong>Dijkstra</strong> 不适用于带<strong>负权值</strong>；<strong>Floyd</strong> 不适用于包含<strong>带负权值的边组成回路</strong></li>
<li><em>n</em> 个顶点、<em>e</em> 条弧有向图采用邻接表存储，拓扑排序时间复杂度<strong>O(n+e)</strong>（排序过程中，先找入度为 0 的点，再删除，非嵌套！<strong>另一角度，拓扑排序即是最终删除所有顶点和边，有 <em>n</em> 个顶点，<em>e</em> 条边，故总时间复杂度为 O(n+e)</strong>）</li>
<li>若一有向图<strong>不能排成一个拓扑序列</strong>，则该图有<strong>环</strong></li>
<li>要<strong>缩短工期</strong>，则<strong>所有关键路径</strong>上的点（<strong>每个</strong>关键路径上<strong>至少挑选一个</strong>进行时间压缩）<strong>都要同时减少</strong>（步骤：①找关键结点，得到其路径长度【设为 <em>L</em>】；②找所有路径长度为 <em>L</em> 的路径；③找到几个点，他们能覆盖到所有关键路径）</li>
<li>若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为 0 。则该图的拓扑排序<strong>存在，但不唯一</strong>（ 2012 统考）</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>数据结构（C语言版）.严蔚敏等</li>
<li>2020年数据结构考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构复习笔记5-树与二叉树</title>
    <url>/2019/07/25/shu-ju-jie-gou-fu-xi-bi-ji-5-shu-yu-er-cha-shu/</url>
    <content><![CDATA[<h1 id="6．树与二叉树"><a href="#6．树与二叉树" class="headerlink" title="6．树与二叉树"></a>6．树与二叉树</h1><h2 id="二叉树的定义、性质和存储结构"><a href="#二叉树的定义、性质和存储结构" class="headerlink" title="二叉树的定义、性质和存储结构"></a>二叉树的定义、性质和存储结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>（见教材 P121 ）</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li><p>第 $i$ 层至多 $2^{i-1}$ 个结点</p>
</li>
<li><p>深度为 $k$ ，至多 $2^{k} - 1$ 个结点</p>
</li>
<li><p>设 $n_0$ 为终端（叶子）结点个数， $n_2$ 为度为 2 的结点个数，则 $n_0 = n_2 +1​$</p>
</li>
<li><p>具有 $n$ 个结点的<strong>完全二叉树</strong>（每一个结点都与深度为 $k$ 的满二叉树中的编号从 1 至 $n$ 的结点一一对应）的深度为 $\lfloor log_{2}n\rfloor + 1$ （普通二叉树不一定有此性质，下同）</p>
</li>
<li><p>具有 $n$ 个结点的<strong>完全二叉树</strong>，按层序编号，对任意结点 $i$ ，有</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">条件</th>
<th align="center">结论</th>
<th align="center">否则</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$i = 1$</td>
<td align="center">$i$ 是二叉树的根，无双亲</td>
<td align="center">PARENT( $i$ ) = $\lfloor i/2\rfloor$($i&gt;1$)</td>
</tr>
<tr>
<td align="center">$2i&gt;n$</td>
<td align="center">结点 $i$ 无左孩子（为叶子节点）</td>
<td align="center">LCHILD( $i$ ) = $2i$</td>
</tr>
<tr>
<td align="center">$2i+1&gt;n$</td>
<td align="center">结点 $i$ 无右孩子</td>
<td align="center">RCHILD( $i$ ) = $2i+1$</td>
</tr>
</tbody></table>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序存储结构</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100                       <span class="comment">// 二叉树的最大结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];      <span class="comment">// 0 号存储根结点</span></span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链式存储结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    TElemType     data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>, <span class="title">rchild</span>;</span>             <span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125;BiNode, *BiTree;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="线索存储"><a href="#线索存储" class="headerlink" title="线索存储"></a>线索存储</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉线索存储结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;Link, Thread&#125; PointerTag;      <span class="comment">// Link = 0：  指针</span></span><br><span class="line">                                            <span class="comment">// Thread = 1：线索</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>&#123;</span></span><br><span class="line">    TElemType        data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>      <span class="comment">// 左右孩子指针</span></span><br><span class="line">    PointerTag       LTag, RTag;            <span class="comment">// 左右标志</span></span><br><span class="line">&#125;BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p>（以<strong>链式存储的二叉树</strong>为例，顺序存储的二叉树的对应操作只需将相应的找左右孩子部分依据前述性质修改即可）</p>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><hr>
<blockquote>
<p>若二叉树不空，则</p>
<ol>
<li>访问根结点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ol>
</blockquote>
<hr>
<ul>
<li>递归实现</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">( BiTree bt )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( bt ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(bt-&gt;data);</span><br><span class="line">        PreOrderTraversal( bt-&gt;Left );</span><br><span class="line">        PreOrderTraversal( bt-&gt;Right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>非递归实现（★）</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关键是利用栈暂存右孩子。</span></span><br><span class="line"><span class="comment">/* 循环流程：</span></span><br><span class="line"><span class="comment">   打印当前结点;</span></span><br><span class="line"><span class="comment">   若该结点有右孩子，则将右孩子入栈</span></span><br><span class="line"><span class="comment">   若该结点有左孩子，则将指向当前结点的指针指向其左孩子；否则，指向出栈元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal_NonRecursive</span><span class="params">( BiTree bt )</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    SqStack S;</span><br><span class="line">    BiTree  P = bt;</span><br><span class="line">    InitStack(S);	</span><br><span class="line">    Push(S,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (P)</span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="built_in">printf</span>(P-&gt;data);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (P-&gt;rchild)</span><br><span class="line">            Push(S, P-&gt;rchild);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (P-&gt;lchild)</span><br><span class="line">            P = P-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            Pop(S,P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>通过先序遍历，建立二叉树</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 算法6.4:按先序次序输入二叉树中结点的值（一个字符），空格字符代表空树 */</span></span><br><span class="line">    <span class="comment">/* 构造二叉链表表示的二叉树T。 */</span></span><br><span class="line">    <span class="comment">/* 输入示例(这里用 # 代表空格)：-+a##*b##-c##d##/e##f## */</span></span><br><span class="line">    <span class="comment">/* 即可构建教材 P129 图 6.9 表达式 a+b*(c-d)-e/f 的二叉树*/</span></span><br><span class="line">    <span class="built_in">scanf</span>( &amp;ch );</span><br><span class="line">    </span><br><span class="line">    if(ch == '') /* 空 */</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode))))</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        </span><br><span class="line">        T-&gt;data = ch; <span class="comment">/* 生成根结点 */</span></span><br><span class="line">        CreateBiTree(T-&gt;lchild); <span class="comment">/* 构造左子树 */</span></span><br><span class="line">        CreateBiTree(T-&gt;rchild); <span class="comment">/* 构造右子树 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><hr>
<blockquote>
<p>若二叉树不空，则</p>
<ol>
<li>中序遍历左子树</li>
<li>访问根结点</li>
<li>中序遍历右子树</li>
</ol>
</blockquote>
<hr>
<ul>
<li>递归实现</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">( BiTree bt )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( bt ) </span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraversal( bt-&gt;Left );</span><br><span class="line">        <span class="built_in">printf</span>(bt-&gt;data);</span><br><span class="line">        InOrderTraversal( bt-&gt;Right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>非递归实现（★）</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在遍历左子树之前，先把根结点入栈，当左子树遍历结束后，从栈中弹出，访问，再遍历右子树</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InOrder_NonRecursive1</span><span class="params">(BiTree T, Status ( * Visit)( TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 采用二叉链表存储结构，Visit是对数据元素操作的应用函数。算法6.2 */</span></span><br><span class="line">    <span class="comment">/* 中序遍历二叉树T的非递归算法(利用栈)，对每个数据元素调用函数Visit */</span></span><br><span class="line">    SqStack S;</span><br><span class="line">    BiTree p;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    Push(&amp;S,T); <span class="comment">/* 根指针进栈 */</span></span><br><span class="line">    <span class="keyword">while</span>(!StackEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(GetTop(S,&amp;p)&amp;&amp;p)</span><br><span class="line">            Push(&amp;S,p-&gt;lchild); <span class="comment">/* 向左走到尽头 */</span></span><br><span class="line">        Pop(&amp;S,&amp;p); <span class="comment">/* 空指针退栈 */</span></span><br><span class="line">        <span class="keyword">if</span>(!StackEmpty(S))</span><br><span class="line">        &#123; <span class="comment">/* 访问结点,向右一步 */</span></span><br><span class="line">            Pop(&amp;S,&amp;p);</span><br><span class="line">            <span class="keyword">if</span>(!Visit(p-&gt;data))</span><br><span class="line">                <span class="keyword">return</span> ERROR;</span><br><span class="line">            Push(&amp;S,p-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InOrder_NonRecursive2</span><span class="params">(BiTree T, Status ( * Visit)( TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 采用二叉链表存储结构，Visit是对数据元素操作的应用函数。算法6.3 */</span></span><br><span class="line">    <span class="comment">/* 中序遍历二叉树T的非递归算法(利用栈)，对每个数据元素调用函数Visit */</span></span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    <span class="keyword">while</span>(T||!StackEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T)</span><br><span class="line">        &#123; <span class="comment">/* 根指针进栈,遍历左子树 */</span></span><br><span class="line">            Push(&amp;S,T);</span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">/* 根指针退栈,访问根结点,遍历右子树 */</span></span><br><span class="line">            Pop(&amp;S,&amp;T);</span><br><span class="line">            <span class="keyword">if</span>(!Visit(T-&gt;data))</span><br><span class="line">                <span class="keyword">return</span> ERROR;</span><br><span class="line">            T=T-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><hr>
<blockquote>
<p>若二叉树不空，则</p>
<ol>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根结点</li>
</ol>
</blockquote>
<hr>
<ul>
<li>递归实现</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">( BiTree bt )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( bt ) </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        PostOrderTraversal( bt-&gt;Left );</span><br><span class="line">        PostOrderTraversal( bt-&gt;Right );</span><br><span class="line">        <span class="built_in">printf</span>(bt-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>非递归实现（★）</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设定一个指针，指向 最近访问过的结点。</span></span><br><span class="line"><span class="comment">// 在退栈取出根结点时，需判断：</span></span><br><span class="line"><span class="comment">// 若根结点的右子树为空，或它的右子树非空，但已遍历完毕，</span></span><br><span class="line"><span class="comment">// 即它的右子树根结点恰好是最近一次访问过的结点时，应该遍历该根结点。</span></span><br><span class="line"><span class="comment">// 反之，该根结点应重新入栈，先遍历它的右子树。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal_NonRecursive</span><span class="params">( BiTree bt )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree p = bt, q = <span class="literal">NULL</span>;                 <span class="comment">//q 指向 最近访问过的结点</span></span><br><span class="line">    SqStack S;	</span><br><span class="line">    InitStack(S);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p || !StackEmpty(S))</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (p)                               <span class="comment">// 走到最左边</span></span><br><span class="line">        &#123;</span><br><span class="line">            Push(S,p);</span><br><span class="line">            p=p-&gt;lchild;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                 <span class="comment">// 向右</span></span><br><span class="line">        &#123;</span><br><span class="line">            GetTop(S, p);                    <span class="comment">// 取栈顶结点</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild &amp;&amp; p-&gt;rchild != q)  <span class="comment">// 若子树存在，且未被访问</span></span><br><span class="line">            &#123;</span><br><span class="line">            	p = p-&gt;rchild;               <span class="comment">// 转向右</span></span><br><span class="line">            	Push(S,p);                   <span class="comment">// 压入栈</span></span><br><span class="line">            	p = p-&gt;lchild;               <span class="comment">// 再走到最左</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                             <span class="comment">// 否则，弹出结点并访问</span></span><br><span class="line">            &#123;</span><br><span class="line">                Pop(S, p);                   <span class="comment">// 将结点弹出</span></span><br><span class="line">                Visit(p-&gt;data);              <span class="comment">// 访问该结点</span></span><br><span class="line">                q = p;                       <span class="comment">// 记录最近访问过的结点</span></span><br><span class="line">                p = <span class="literal">NULL</span>;                    <span class="comment">// 结点访问完后，重置p</span></span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先将根结点入队，然后出队，访问该结点，</span></span><br><span class="line"><span class="comment">// 若它有左子树，则将其左子树根结点入队；</span></span><br><span class="line"><span class="comment">// 若它有右子树，则将其右子树根结点入队；</span></span><br><span class="line"><span class="comment">// 然后出队，对出队结点访问，如此反复，直至队列为空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">( BiTree bt )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    </span><br><span class="line">    EnQueue(Q, bt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( ! IsEmpty(Q) )</span><br><span class="line">    &#123;</span><br><span class="line">        Dequeue(Q, p);</span><br><span class="line">        visit(p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q, p-&gt;lchild);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q, p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><ul>
<li>经常遍历或查找结点在遍历所得线性序列中的前驱和后继，则应使用线索链表作为存储结构。</li>
</ul>
<h4 id="遍历线索二叉树"><a href="#遍历线索二叉树" class="headerlink" title="遍历线索二叉树"></a>遍历线索二叉树</h4><p>教材和参考书只给出了中序</p>
<h5 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h5><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T,Status(*Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 中序遍历二叉线索树T(头结点)的非递归算法。算法6.5 */</span></span><br><span class="line">    BiThrTree p;</span><br><span class="line">    p=T-&gt;lchild; <span class="comment">/* p指向根结点 */</span></span><br><span class="line">    <span class="keyword">while</span>(p!=T)</span><br><span class="line">    &#123; <span class="comment">/* 空树或遍历结束时,p==T */</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;LTag==Link)</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span>(!Visit(p-&gt;data)) <span class="comment">/* 访问其左子树为空的结点 */</span></span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;RTag==Thread&amp;&amp;p-&gt;rchild!=T)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">            Visit(p-&gt;data); <span class="comment">/* 访问后继结点 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h4><h5 id="中序-1"><a href="#中序-1" class="headerlink" title="中序"></a>中序</h5><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderThreading</span><span class="params">(BiThrTree *Thrt,BiThrTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 中序遍历二叉树T,并将其中序线索化,Thrt指向头结点。算法6.6 */</span></span><br><span class="line">    *Thrt=(BiThrTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode));</span><br><span class="line">    <span class="keyword">if</span>(!*Thrt)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    (*Thrt)-&gt;LTag=Link; <span class="comment">/* 建头结点 */</span></span><br><span class="line">    (*Thrt)-&gt;RTag=Thread;</span><br><span class="line">    (*Thrt)-&gt;rchild=*Thrt; <span class="comment">/* 右指针回指 */</span></span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="comment">/* 若二叉树空，则左指针回指 */</span></span><br><span class="line">        (*Thrt)-&gt;lchild=*Thrt;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        (*Thrt)-&gt;lchild=T;</span><br><span class="line">        pre=*Thrt;</span><br><span class="line">        InThreading(T); <span class="comment">/* 中序遍历进行中序线索化 */</span></span><br><span class="line">        pre-&gt;rchild=*Thrt;</span><br><span class="line">        pre-&gt;RTag=Thread; <span class="comment">/* 最后一个结点线索化 */</span></span><br><span class="line">        (*Thrt)-&gt;rchild=pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 中序遍历进行中序线索化。算法6.7 */</span></span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        InThreading(p-&gt;lchild); <span class="comment">/* 递归左子树线索化 */</span></span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;lchild) <span class="comment">/* 没有左孩子 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;LTag=Thread; <span class="comment">/* 前驱线索 */</span></span><br><span class="line">            p-&gt;lchild=pre; <span class="comment">/* 左孩子指针指向前驱 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;rchild) <span class="comment">/* 前驱没有右孩子 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;RTag=Thread; <span class="comment">/* 后继线索 */</span></span><br><span class="line">            pre-&gt;rchild=p; <span class="comment">/* 前驱右孩子指针指向后继(当前结点p) */</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre=p; <span class="comment">/* 保持pre指向p的前驱 */</span></span><br><span class="line">        InThreading(p-&gt;rchild); <span class="comment">/* 递归右子树线索化 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="树的定义和存储结构"><a href="#树的定义和存储结构" class="headerlink" title="树的定义和存储结构"></a>树的定义和存储结构</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>（见教材 P118 ）</p>
<h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><ul>
<li>便于找爹（常数时间内），不易找孩子（可能需要遍历整个树）</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双亲存储表示</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span>             <span class="comment">// 结点结构</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">int</span>       parent;              <span class="comment">// 双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                    <span class="comment">// 树结构</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span>    r,n;                    <span class="comment">// 根的位置和结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><ul>
<li>便于找孩子，不易找爹</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 孩子链表存储表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span>            <span class="comment">// 孩子节点</span></span><br><span class="line">    <span class="keyword">int</span>           child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr  firstchild;         <span class="comment">// 孩子链表头指针</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span>   r, n;                   <span class="comment">// 根的位置和结点数</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>

<hr>
<p>变种：带双亲的孩子链表</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 孩子链表存储表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span>            <span class="comment">// 孩子节点</span></span><br><span class="line">    <span class="keyword">int</span>           child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr  firstchild;         <span class="comment">// 孩子链表头指针</span></span><br><span class="line">    <span class="keyword">int</span>       parent;             <span class="comment">// 增添双亲位置域</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span>   r, n;                   <span class="comment">// 根的位置和结点数</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><ul>
<li>便于实现各种操作</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 孩子-兄弟（二叉链表）存储表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h2><ul>
<li>存储结构</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 赫夫曼树和赫夫曼编码的存储表示 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> parent,lchild,rchild;</span><br><span class="line">&#125;HTNode,*HuffmanTree; <span class="comment">/* 动态分配数组存储赫夫曼树 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> **HuffmanCode; <span class="comment">/* 动态分配数组存储赫夫曼编码表 */</span></span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>求赫夫曼编码</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree *HT,HuffmanCode *HC,<span class="keyword">int</span> *w,<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    <span class="comment">/* 算法6.12 */</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* w存放n个字符的权值(均&gt;0),构造赫夫曼树HT,并求出n个字符的赫夫曼编码HC */</span></span><br><span class="line">    <span class="keyword">int</span> m,i,s1,s2,start;</span><br><span class="line">    <span class="keyword">unsigned</span> c,f;</span><br><span class="line">    HuffmanTree p;</span><br><span class="line">    <span class="keyword">char</span> *cd;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    m=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">    *HT=(HuffmanTree)<span class="built_in">malloc</span>((m+<span class="number">1</span>)*<span class="keyword">sizeof</span>(HTNode)); <span class="comment">/* 0号单元未用 */</span></span><br><span class="line">    <span class="keyword">for</span>(p=*HT+<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=n;++i,++p,++w)</span><br><span class="line">    &#123;</span><br><span class="line">        (*p).weight=*w;</span><br><span class="line">        (*p).parent=<span class="number">0</span>;</span><br><span class="line">        (*p).lchild=<span class="number">0</span>;</span><br><span class="line">        (*p).rchild=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=m;++i,++p)</span><br><span class="line">        (*p).parent=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n+<span class="number">1</span>;i&lt;=m;++i) <span class="comment">/* 建赫夫曼树 */</span></span><br><span class="line">    &#123; <span class="comment">/* 在HT[1~i-1]中选择parent为0且weight最小的两个结点,其序号分别为s1和s2 */</span></span><br><span class="line">        select(*HT,i<span class="number">-1</span>,&amp;s1,&amp;s2);</span><br><span class="line">        (*HT)[s1].parent=(*HT)[s2].parent=i;</span><br><span class="line">        (*HT)[i].lchild=s1;</span><br><span class="line">        (*HT)[i].rchild=s2;</span><br><span class="line">        (*HT)[i].weight=(*HT)[s1].weight+(*HT)[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 从叶子到根逆向求每个字符的赫夫曼编码 */</span></span><br><span class="line">    *HC=(HuffmanCode)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">    <span class="comment">/* 分配n个字符编码的头指针向量([0]不用) */</span></span><br><span class="line">    cd=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">char</span>)); <span class="comment">/* 分配求编码的工作空间 */</span></span><br><span class="line">    cd[n<span class="number">-1</span>]=<span class="string">'\0'</span>; <span class="comment">/* 编码结束符 */</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123; <span class="comment">/* 逐个字符求赫夫曼编码 */</span></span><br><span class="line">        start=n<span class="number">-1</span>; <span class="comment">/* 编码结束符位置 */</span></span><br><span class="line">        <span class="keyword">for</span>(c=i,f=(*HT)[i].parent;f!=<span class="number">0</span>;c=f,f=(*HT)[f].parent)</span><br><span class="line">            <span class="comment">/* 从叶子到根逆向求编码 */</span></span><br><span class="line">            <span class="keyword">if</span>((*HT)[f].lchild==c)</span><br><span class="line">                cd[--start]=<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cd[--start]=<span class="string">'1'</span>;</span><br><span class="line">        (*HC)[i]=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>((n-start)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="comment">/* 为第i个字符编码分配空间 */</span></span><br><span class="line">        <span class="built_in">strcpy</span>((*HC)[i],&amp;cd[start]); <span class="comment">/* 从cd复制编码(串)到HC */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cd); <span class="comment">/* 释放工作空间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree *HT,HuffmanCode *HC,<span class="keyword">int</span> *w,<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    <span class="comment">/* 前半部分为算法6.12 */</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* w存放n个字符的权值(均&gt;0),构造赫夫曼树HT,并求出n个字符的赫夫曼编码HC */</span></span><br><span class="line">    <span class="keyword">int</span> m,i,s1,s2; <span class="comment">/* 此句与上面的不同 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> c,cdlen; <span class="comment">/* 此句与上面的不同 */</span></span><br><span class="line">    HuffmanTree p;</span><br><span class="line">    <span class="keyword">char</span> *cd;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    m=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">    *HT=(HuffmanTree)<span class="built_in">malloc</span>((m+<span class="number">1</span>)*<span class="keyword">sizeof</span>(HTNode)); <span class="comment">/* 0号单元未用 */</span></span><br><span class="line">    <span class="keyword">for</span>(p=*HT+<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=n;++i,++p,++w)</span><br><span class="line">    &#123;</span><br><span class="line">        (*p).weight=*w;</span><br><span class="line">        (*p).parent=<span class="number">0</span>;</span><br><span class="line">        (*p).lchild=<span class="number">0</span>;</span><br><span class="line">        (*p).rchild=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=m;++i,++p)</span><br><span class="line">        (*p).parent=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n+<span class="number">1</span>;i&lt;=m;++i) <span class="comment">/* 建赫夫曼树 */</span></span><br><span class="line">    &#123; <span class="comment">/* 在HT[1~i-1]中选择parent为0且weight最小的两个结点,其序号分别为s1和s2 */</span></span><br><span class="line">        select(*HT,i<span class="number">-1</span>,&amp;s1,&amp;s2);</span><br><span class="line">        (*HT)[s1].parent=(*HT)[s2].parent=i;</span><br><span class="line">        (*HT)[i].lchild=s1;</span><br><span class="line">        (*HT)[i].rchild=s2;</span><br><span class="line">        (*HT)[i].weight=(*HT)[s1].weight+(*HT)[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 以下为算法6.13，无栈非递归遍历赫夫曼树,求赫夫曼编码，以上同算法6.12 */</span></span><br><span class="line">    *HC=(HuffmanCode)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">    <span class="comment">/* 分配n个字符编码的头指针向量([0]不用) */</span></span><br><span class="line">    cd=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">char</span>)); <span class="comment">/* 分配求编码的工作空间 */</span></span><br><span class="line">    c=m;</span><br><span class="line">    cdlen=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        (*HT)[i].weight=<span class="number">0</span>; <span class="comment">/* 遍历赫夫曼树时用作结点状态标志 */</span></span><br><span class="line">    <span class="keyword">while</span>(c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((*HT)[c].weight==<span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">/* 向左 */</span></span><br><span class="line">            (*HT)[c].weight=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>((*HT)[c].lchild!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c=(*HT)[c].lchild;</span><br><span class="line">                cd[cdlen++]=<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((*HT)[c].rchild==<span class="number">0</span>)</span><br><span class="line">            &#123; <span class="comment">/* 登记叶子结点的字符的编码 */</span></span><br><span class="line">                (*HC)[c]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>((cdlen+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">                cd[cdlen]=<span class="string">'\0'</span>;</span><br><span class="line">                <span class="built_in">strcpy</span>((*HC)[c],cd); <span class="comment">/* 复制编码(串) */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((*HT)[c].weight==<span class="number">1</span>)</span><br><span class="line">        &#123; <span class="comment">/* 向右 */</span></span><br><span class="line">            (*HT)[c].weight=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((*HT)[c].rchild!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c=(*HT)[c].rchild;</span><br><span class="line">                cd[cdlen++]=<span class="string">'1'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">/* HT[c].weight==2,退回 */</span></span><br><span class="line">            (*HT)[c].weight=<span class="number">0</span>;</span><br><span class="line">            c=(*HT)[c].parent;</span><br><span class="line">            --cdlen; <span class="comment">/* 退到父结点,编码长度减1 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="解题技巧小结及结论补充"><a href="#解题技巧小结及结论补充" class="headerlink" title="解题技巧小结及结论补充"></a>解题技巧小结及结论补充</h1><ol>
<li>求解树<strong>结点</strong>与<strong>度</strong>之间的关系有（★★★★★）<ul>
<li><strong>总结点数</strong> = $n_0 +n_1+n_2+\cdots+n_m$ （其中 $n_i$ 表示度为 $i$ 的结点个数）</li>
<li><strong>总分支数</strong> = $1n_1+2n_2+\cdots+mn_m$</li>
<li><strong>总结点数</strong> = <strong>总分支数</strong> + 1</li>
</ul>
</li>
<li><strong>完全二叉树</strong>的一个重要特征：若有<strong>度为 1 的结点</strong>，则<strong>只可能有一个</strong>，且该结点<strong>只有左孩子</strong>而无右孩子</li>
<li>在含有<strong>$n$ 个结点</strong>的二叉链表中，含有<strong>$n+1$ 个空链域</strong></li>
<li>由遍历序列构造二叉树（★★★★★）<ul>
<li>先序 + 中序（唯一确定）<ul>
<li>确定步骤<ol>
<li>先序第一个为<strong>根</strong>，找其在中序中的位置，这个位置的<strong>左边为左子树的中序序列</strong>，<strong>右边为右子树中序序列</strong></li>
<li>根据这上述两个子序列，找到在先序中的对应子序列。左子序列的<strong>第一个元素</strong>为左子树的<strong>根</strong>，右子序列的<strong>第一个元素</strong>为右子树的<strong>根</strong>。这样递归的找下去，即可</li>
</ol>
</li>
<li>举例说明：<ul>
<li>先序：A B C D E F G</li>
<li>中序：C B E D A F G<ol>
<li>A 为根，C B E D 为左，F G 为右</li>
<li>C B E D 在先序中为  B C D E，B 为左子树的根；B 中序分割，其左为 C，右为  E D；F G 在先序中为 F G，F 为右子树的根；F 中序分割，其左为空，其右为 G</li>
<li>以此类推···</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>中序 + 后序（唯一确定）<ul>
<li>确定步骤<ol>
<li>后序最后一个为<strong>根</strong>，找其在中序中的位置，这个位置的<strong>左边为左子树的中序序列</strong>，<strong>右边为右子树中序序列</strong></li>
<li>根据这上述两个子序列，找到在后序中的对应子序列。左子序列的<strong>最后一个</strong>元素为左子树的<strong>根</strong>，右子序列的<strong>最后一个</strong>元素为右子树的<strong>根</strong>。这样递归的找下去，即可</li>
</ol>
</li>
</ul>
</li>
<li>层序 + 中序（唯一确定）<ul>
<li>确定步骤<ol>
<li>层序第一个为<strong>根</strong>，找其在中序中的位置，这个位置的<strong>左边为左子树的中序序列</strong>，<strong>右边为右子树中序序列</strong></li>
<li>当上述<strong>左右</strong>子树的<strong>中序</strong>序列<strong>都非空</strong>时，层序遍历<strong>第二个</strong>为<strong>左</strong>子树的<strong>根</strong>，<strong>第三个</strong>为<strong>右</strong>子树的<strong>根</strong>；当有<strong>一个子树为空</strong>时，层序<strong>第二个</strong>为<strong>对应非空子树的根</strong>；根据根在中序中找其左右子树。以此类推，即可。</li>
</ol>
</li>
</ul>
</li>
<li>先序 + 后序（<strong>不行</strong>）<ul>
<li>但可确定二叉树中结点的祖先关系：当先序序列为 XY ，后序序列为 YX 时，则 X 为 Y 的祖先。</li>
<li>解题时，可任画一个满足的二叉树，对选项进行判断</li>
</ul>
</li>
</ul>
</li>
<li>二叉树的先序、中序、后序序列，叶子结点的先后顺序<strong>完全相同</strong></li>
<li>先序遍历和中序遍历的关系：<strong>先序</strong>序列为<strong>入栈</strong>次序，<strong>中序</strong>序列为<strong>出栈</strong>次序。对于 $n$ 个不同元素进栈，出栈序列的个数为$\frac{1}{n+1}C_{2n}^{n}$</li>
<li>线索二叉树是一种<strong>物理</strong>结构</li>
<li><strong>后序线索二叉树</strong>的遍历仍需要栈的支持（★★★★★，加深对线索二叉树和二叉树遍历的理解）<ul>
<li>遍历不需要栈的关键：从当前访问的结点开始，通过左右指针，能够找到下一个结点</li>
<li>叶子结点：其左右指针都用于<strong>线索</strong>，故一定能找到下一个结点</li>
<li>非叶子节点：<ol>
<li>先序情况<ol>
<li>当前访问结点的左子树非空，下一个节点为当前左子树的根</li>
<li>当前访问结点的左子树为空（意味着右子树不空，否则该节点为叶子节点），下一个节点为当前右子树的根</li>
</ol>
</li>
<li>中序情况<ul>
<li>找当前结点右子树的最左结点</li>
</ul>
</li>
<li>后序情况<ul>
<li>一个特例：设根节点的右子树的根的左右子树非空（即根的右子树的根的两个指针域全部用于指向其左右孩子），当遍历到根结点的右子树的根时，下一个应该遍历的应该是根结点，而此时无法通过当前节点的左右指针找到该根结点，故后序线索二叉树的遍历需要栈。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>在 <em>n</em> 个结点的树中，有<em>n-1</em> 条边。那么对于每棵树，其结点数比边数多一。<strong>森林中，结点数比边数多 <em>x</em> ，则有 <em>x</em> 棵树。</strong></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>数据结构（C语言版）.严蔚敏等</li>
<li>2020年数据结构考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构复习笔记4-数组和广义表</title>
    <url>/2019/07/22/shu-ju-jie-gou-fu-xi-bi-ji-4-shu-zu-he-guang-yi-biao/</url>
    <content><![CDATA[<h1 id="5．数组和广义表"><a href="#5．数组和广义表" class="headerlink" title="5．数组和广义表"></a>5．数组和广义表</h1><h2 id="数组的顺序存储表示"><a href="#数组的顺序存储表示" class="headerlink" title="数组的顺序存储表示"></a>数组的顺序存储表示</h2><ul>
<li>存储</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的顺序存储表示</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdarg.h&gt;      // 标准头文件，提供宏 va_start、va_arg、va_end</span></span></span><br><span class="line">                        <span class="comment">// 用于存储变长参数表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ARRAY_DIM 8 <span class="comment">// 假设数组维数的最大值为 8</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *base;     <span class="comment">// 数组元素基址，由 InitArray 分配</span></span><br><span class="line">    <span class="keyword">int</span>      dim;       <span class="comment">// 数组维数</span></span><br><span class="line">    <span class="keyword">int</span>      *bounds;   <span class="comment">// 数组维界地址，由 InitArray 分配</span></span><br><span class="line">    <span class="keyword">int</span>      *constants;<span class="comment">// 数组映像函数常量基址，由 InitArray 分配</span></span><br><span class="line">&#125;Array;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>操作</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造数组</span></span><br><span class="line"><span class="comment">// 若维数 dim 和各维长度合法，则构造相应的数组 A，并返回 OK</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitArray</span><span class="params">(Array &amp;A, <span class="keyword">int</span> dim, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dim &lt; <span class="number">1</span> || dim &gt; MAX_ARRAY_DIM)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    A.dim = dim;</span><br><span class="line">    A.bounds = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(dim * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(! A.bounds)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若各维度长度合法，则存入 A.bounds,并求出 A 的元素总数 elemtotal</span></span><br><span class="line">    elemtotal = <span class="number">1</span>;</span><br><span class="line">    va_start(ap, dim);  <span class="comment">// ap 为 va_list类型，是存放变长参数表信息的数组</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; dim; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A.bounds[i] = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">if</span>(A.bounds[i] &lt; <span class="number">0</span>)	<span class="keyword">return</span> UNDERFLOW;</span><br><span class="line">        elemtotal *= A.bounds[i];</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">    </span><br><span class="line">    A.base = (ElemType *)<span class="built_in">malloc</span>(elemtotal * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(! A.base)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    </span><br><span class="line">    A.constants = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(dim * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(! A.constants)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    </span><br><span class="line">    A.constants[dim - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = dim - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意以下的公式</span></span><br><span class="line">        A.constants[i] = A.bounds[i + <span class="number">1</span>] * A.constants[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组销毁</span></span><br><span class="line"><span class="comment">// 销毁数组 A</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyArray</span><span class="params">(Array &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(! A.base)	<span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="built_in">free</span>(A.base);	A.base = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(! A.bounds)	<span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="built_in">free</span>(A.bounds);	A.bounds = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(! A.constants)	<span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="built_in">free</span>(A.constants);	A.constants = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定位元素的相对地址</span></span><br><span class="line"><span class="comment">// 若 ap 指示的各下标合法，则求出该元素在 A 中的相对地址 off</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Locate</span><span class="params">(Array A, va_list ap, <span class="keyword">int</span> &amp;off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    off = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; A.dim; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ind = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt;= A.bounds[i])	<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">        </span><br><span class="line">        off += A.constants[i] * ind;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取给定下标元素的值</span></span><br><span class="line"><span class="comment">// A 是 n 维数组，e 为元素变量，随后是 n 个下标值</span></span><br><span class="line"><span class="comment">// 若各下标不越界，则 e 赋值为所指定 A 的元素值，并返回 OK</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Value</span><span class="params">(Array A, ElemType &amp;e, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_start(ap, e);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((result = Locate(A, ap, off)) &lt;= <span class="number">0</span>)	<span class="keyword">return</span> result; <span class="comment">// 失败</span></span><br><span class="line">    </span><br><span class="line">    e = *(A.base + off);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给指定下标的元素赋值</span></span><br><span class="line"><span class="comment">// A 是 n 维数组，e 为元素变量，随后是 n 个下标值</span></span><br><span class="line"><span class="comment">// 若各下标不越界，则将 e 赋给所指定 A 的元素值，并返回 OK</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Assign</span><span class="params">(Array &amp; A, Elemtype e, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_start(ap, e);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((result = Locate(A, ap, off)) &lt;= <span class="number">0</span>)	<span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    *(A.base + off) = e;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="矩阵的压缩存储：特殊矩阵、稀疏矩阵"><a href="#矩阵的压缩存储：特殊矩阵、稀疏矩阵" class="headerlink" title="矩阵的压缩存储：特殊矩阵、稀疏矩阵"></a>矩阵的压缩存储：特殊矩阵、稀疏矩阵</h2><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><p>（以下推导请见王道 3.4.3 节）</p>
<p><strong>注意下标</strong>（以下推导基于矩阵元素 a 从 <strong>(1, 1)</strong> 开始，但存储从 <strong>0</strong> 号开始）（题目会以此设置陷阱）</p>
<h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><ul>
<li><p>存储结构：一维数组 <code>sa[n*(n+1)/2]</code>，（行序为主序，仅仅存储下三角）</p>
</li>
<li><p>存储下标 <code>k</code> 与矩阵逻辑位置 <code>(i, j)</code> 的关系<br>$$<br>k =<br>\left {<br>\begin{aligned}</p>
<pre><code>&amp;  \frac{i(i-1)}{2}+j-1, &amp;i \ge j\\
&amp;  \frac{j(j-1)}{2}+i-1, &amp;i &lt; j \\</code></pre><p>\end{aligned}<br>\right.<br>$$</p>
</li>
</ul>
<h4 id="下三角矩阵"><a href="#下三角矩阵" class="headerlink" title="下三角矩阵"></a>下三角矩阵</h4><ul>
<li><p>存储结构：一维数组 <code>sa[n*(n+1)/2 + 1]</code>，（行序为主序，存储下三角及上三角的常量【存储在数组最后一个位置】）</p>
</li>
<li><p>存储下标 <code>k</code> 与矩阵逻辑位置 <code>(i, j)</code> 的关系</p>
</li>
</ul>
<p>$$<br>k =<br>\left {<br>\begin{aligned}<br>             &amp;  \frac{i(i-1)}{2}+j-1, &amp;i \ge j &amp;(存储下三角和主对角线)\<br>             &amp;  \frac{n(n+1)}{2}, &amp;i &lt; j      &amp;(存储常量的位置)\<br>\end{aligned}<br>\right.<br>$$</p>
<h4 id="上三角矩阵"><a href="#上三角矩阵" class="headerlink" title="上三角矩阵"></a>上三角矩阵</h4><ul>
<li><p>存储结构：一维数组 <code>sa[n*(n+1)/2 + 1]</code>，（行序为主序，存储上三角及下三角的常量【存储在数组最后一个位置】）</p>
</li>
<li><p>存储下标 <code>k</code> 与矩阵逻辑位置 <code>(i, j)</code> 的关系</p>
</li>
</ul>
<p>$$<br>k =<br>\left {<br>\begin{aligned}<br>             &amp;  \frac{(i-1)(2n-i+2)}{2}+j-i, &amp;i \le j &amp;(存储上三角和主对角线)\<br>             &amp;  \frac{n(n+1)}{2}, &amp;i &gt; j      &amp;(存储常量的位置)\<br>\end{aligned}<br>\right.<br>$$</p>
<h4 id="三对角矩阵"><a href="#三对角矩阵" class="headerlink" title="三对角矩阵"></a>三对角矩阵</h4><ul>
<li><p>描述：所有非 0 元素都集中在以主对角线为中心的 3 条对角线区域，其余元素为 0</p>
</li>
<li><p>存储结构：一维数组 <code>sa[3n-2]</code>，（按行优先，依次存入一维数组中）</p>
</li>
<li><p>存储下标 <code>k</code> 与矩阵逻辑位置 <code>(i, j)</code> 的关系</p>
</li>
</ul>
<p>$$<br>k = 2i + j -3<br>$$</p>
<p>$$<br>\begin{align}<br>&amp; i = \lfloor(k+1)/3+1\rfloor \<br>&amp; j = k-2i+3<br>\end{align}<br>$$</p>
<h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><h4 id="三元组顺序表"><a href="#三元组顺序表" class="headerlink" title="三元组顺序表"></a>三元组顺序表</h4><ul>
<li>存储</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 稀疏矩阵的三元组顺序表存储表示</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 12500                <span class="comment">// 非零元个数的最大值</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j;                        <span class="comment">// 非零元的行下标和列下标</span></span><br><span class="line">    ElemType e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Triple data[MAXSIZE + <span class="number">1</span>];        <span class="comment">// 非零元三元组表，data[0]未用</span></span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu;                  <span class="comment">// 矩阵的行数、列数、非零元个数</span></span><br><span class="line">&#125;TSMatrix;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>操作</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 5.1</span></span><br><span class="line"><span class="comment">// 矩阵的转置</span></span><br><span class="line"><span class="comment">// 采用三元组表存储表示，求稀疏矩阵 M 的转置矩阵</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(nu·tu)，适用于【tu 远小于 mu × nu】的情况</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TransposeSMatrix</span><span class="params">(TSMatrix M, TSMatrix &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T.mu = M.mu; T.nu = M.nu; T.tu = M.tu;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(T.tu)</span><br><span class="line">    &#123;</span><br><span class="line">        q = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">1</span>; col &lt; M.nu; col++)</span><br><span class="line">            <span class="keyword">for</span>(p = <span class="number">1</span>; p &lt; M.tu; p++)</span><br><span class="line">                <span class="keyword">if</span>(M.data[p].j == col)</span><br><span class="line">                &#123;</span><br><span class="line">                    T.data[q].i = M.data[p].j;</span><br><span class="line">                    T.data[q].j = M.data[p].i;</span><br><span class="line">                    T.data[q].e = M.data[p].e;</span><br><span class="line">                    ++q;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 5.2</span></span><br><span class="line"><span class="comment">// 更快的转置算法</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">FastTransposeMatrix</span><span class="params">(TSMatrix M, TSMatrix &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T.mu = M.mu; T.nu = M.nu; T.tu = M.tu;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(T.tu)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">1</span>; col &lt;= M.nu; ++col)	num[col] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(t = <span class="number">1</span>; t &lt;= M.tu; ++t)	++num[M.data[t].j];</span><br><span class="line">        </span><br><span class="line">        cpot[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">2</span>; col &lt;= M.nu; ++col)</span><br><span class="line">            cpot[col] = cpot[col - <span class="number">1</span>] + num[col - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(p = <span class="number">1</span>; p &lt;= M.tu; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            col = M.data[p].j;	q = cpot[col];</span><br><span class="line">            T.data[q].i = M.data[p].j;</span><br><span class="line">            T.data[q].j = M.data[p].i;</span><br><span class="line">            T.data[q].e = M.data[p].e;</span><br><span class="line">            ++cpot[col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="行逻辑连接顺序表"><a href="#行逻辑连接顺序表" class="headerlink" title="行逻辑连接顺序表"></a>行逻辑连接顺序表</h4><ul>
<li>存储</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 行逻辑连接顺序表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Triple data[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> rpos[MAXRC + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu;</span><br><span class="line">&#125;RLSMatrix;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>操作</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 5.3</span></span><br><span class="line"><span class="comment">// 矩阵乘法</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">MultSMatrix</span><span class="params">(RLSMatrix M,RLSMatrix N,RLSMatrix *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arow,brow,p,q,ccol,ctemp[MAXRC+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(M.nu!=N.mu) <span class="comment">/* 矩阵M的列数应和矩阵N的行数相等 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    (*Q).mu=M.mu; <span class="comment">/* Q初始化 */</span></span><br><span class="line">    (*Q).nu=N.nu;</span><br><span class="line">    (*Q).tu=<span class="number">0</span>;</span><br><span class="line">    M.rpos[M.mu+<span class="number">1</span>]=M.tu+<span class="number">1</span>; <span class="comment">/* 为方便后面的while循环临时设置 */</span></span><br><span class="line">    N.rpos[N.mu+<span class="number">1</span>]=N.tu+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(M.tu*N.tu!=<span class="number">0</span>) <span class="comment">/* M和N都是非零矩阵 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(arow=<span class="number">1</span>;arow&lt;=M.mu;++arow)</span><br><span class="line">        &#123; <span class="comment">/* 从M的第一行开始，到最后一行，arow是M的当前行 */</span></span><br><span class="line">            <span class="keyword">for</span>(ccol=<span class="number">1</span>;ccol&lt;=(*Q).nu;++ccol)</span><br><span class="line">                ctemp[ccol]=<span class="number">0</span>; <span class="comment">/* Q的当前行的各列元素累加器清零 */</span></span><br><span class="line">            (*Q).rpos[arow]=(*Q).tu+<span class="number">1</span>; <span class="comment">/* Q当前行的第1个元素位于上1行最后1个元素之后 */</span></span><br><span class="line">            <span class="keyword">for</span>(p=M.rpos[arow];p&lt;M.rpos[arow+<span class="number">1</span>];++p)</span><br><span class="line">            &#123; <span class="comment">/* 对M当前行中每一个非零元 */</span></span><br><span class="line">                brow=M.data[p].j; <span class="comment">/* 找到对应元在N中的行号(M当前元的列号) */</span></span><br><span class="line">                <span class="keyword">for</span>(q=N.rpos[brow];q&lt;N.rpos[brow+<span class="number">1</span>];++q)</span><br><span class="line">                &#123;</span><br><span class="line">                    ccol=N.data[q].j; <span class="comment">/* 乘积元素在Q中列号 */</span></span><br><span class="line">                    ctemp[ccol]+=M.data[p].e*N.data[q].e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">/* 求得Q中第arow行的非零元 */</span></span><br><span class="line">            <span class="keyword">for</span>(ccol=<span class="number">1</span>;ccol&lt;=(*Q).nu;++ccol) <span class="comment">/* 压缩存储该行非零元 */</span></span><br><span class="line">                <span class="keyword">if</span>(ctemp[ccol])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(++(*Q).tu&gt;MAXSIZE)</span><br><span class="line">                        <span class="keyword">return</span> ERROR;</span><br><span class="line">                    (*Q).data[(*Q).tu].i=arow;</span><br><span class="line">                    (*Q).data[(*Q).tu].j=ccol;</span><br><span class="line">                    (*Q).data[(*Q).tu].e=ctemp[ccol];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="十字链表存储"><a href="#十字链表存储" class="headerlink" title="十字链表存储"></a>十字链表存储</h4><ul>
<li>存储</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 稀疏矩阵的十字链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i,j; <span class="comment">/* 该非零元的行和列下标 */</span></span><br><span class="line">    ElemType e; <span class="comment">/* 非零元素值 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">right</span>,*<span class="title">down</span>;</span> <span class="comment">/* 该非零元所在行表和列表的后继链域 */</span></span><br><span class="line">&#125;OLNode,*OLink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    OLink *rhead,*chead; <span class="comment">/* 行和列链表头指针向量基址,由CreatSMatrix_OL()分配 */</span></span><br><span class="line">    <span class="keyword">int</span> mu,nu,tu; <span class="comment">/* 稀疏矩阵的行数、列数和非零元个数 */</span></span><br><span class="line">&#125;CrossList;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>操作</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 5.4</span></span><br><span class="line"><span class="comment">// 创建稀疏矩阵，十字链表存储表示</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateSMatrix</span><span class="params">(CrossList *M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 创建稀疏矩阵M,采用十字链表存储表示。算法5.4 */</span></span><br><span class="line">    <span class="keyword">int</span> i,j,k,m,n,t;</span><br><span class="line">    ElemType e;</span><br><span class="line">    OLNode *p,*q;</span><br><span class="line">    <span class="keyword">if</span>((*M).rhead)</span><br><span class="line">        DestroySMatrix(M);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入稀疏矩阵的行数 列数 非零元个数: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;m,&amp;n,&amp;t);</span><br><span class="line">    (*M).mu=m;</span><br><span class="line">    (*M).nu=n;</span><br><span class="line">    (*M).tu=t;</span><br><span class="line">    (*M).rhead=(OLink*)<span class="built_in">malloc</span>((m+<span class="number">1</span>)*<span class="keyword">sizeof</span>(OLink));</span><br><span class="line">    <span class="keyword">if</span>(!(*M).rhead)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    (*M).chead=(OLink*)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(OLink));</span><br><span class="line">    <span class="keyword">if</span>(!(*M).chead)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=m;k++) <span class="comment">/* 初始化行头指针向量;各行链表为空链表 */</span></span><br><span class="line">        (*M).rhead[k]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++) <span class="comment">/* 初始化列头指针向量;各列链表为空链表 */</span></span><br><span class="line">        (*M).chead[k]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请按任意次序输入%d个非零元的行 列 元素值:\n"</span>,(*M).tu);</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;t;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;i,&amp;j,&amp;e);</span><br><span class="line">        p=(OLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode));</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        p-&gt;i=i; <span class="comment">/* 生成结点 */</span></span><br><span class="line">        p-&gt;j=j;</span><br><span class="line">        p-&gt;e=e;</span><br><span class="line">        <span class="keyword">if</span>((*M).rhead[i]==<span class="literal">NULL</span>||(*M).rhead[i]-&gt;j&gt;j) <span class="comment">/* p插在该行的第一个结点处 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;right=(*M).rhead[i];</span><br><span class="line">            (*M).rhead[i]=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* 寻查在行表中的插入位置 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(q=(*M).rhead[i];q-&gt;right&amp;&amp;q-&gt;right-&gt;j&lt;j;q=q-&gt;right);</span><br><span class="line">            p-&gt;right=q-&gt;right; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">            q-&gt;right=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((*M).chead[j]==<span class="literal">NULL</span>||(*M).chead[j]-&gt;i&gt;i) <span class="comment">/* p插在该列的第一个结点处 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;down=(*M).chead[j];</span><br><span class="line">            (*M).chead[j]=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* 寻查在列表中的插入位置 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(q=(*M).chead[j];q-&gt;down&amp;&amp;q-&gt;down-&gt;i&lt;i;q=q-&gt;down);</span><br><span class="line">            p-&gt;down=q-&gt;down; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">            q-&gt;down=p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩阵加法</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">AddSMatrix</span><span class="params">(CrossList M,CrossList N,CrossList *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M与N的行数和列数对应相等。 */</span></span><br><span class="line">    <span class="comment">/* 操作结果: 求稀疏矩阵的和Q=M+N */</span></span><br><span class="line">    <span class="keyword">int</span> i,k;</span><br><span class="line">    OLink p,pq,pm,pn;</span><br><span class="line">    OLink *col;</span><br><span class="line">    <span class="keyword">if</span>(M.mu!=N.mu||M.nu!=N.nu)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"两个矩阵不是同类型的,不能相加\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    &#125;</span><br><span class="line">    (*Q).mu=M.mu; <span class="comment">/* 初始化Q矩阵 */</span></span><br><span class="line">    (*Q).nu=M.nu;</span><br><span class="line">    (*Q).tu=<span class="number">0</span>; <span class="comment">/* 元素个数的初值 */</span></span><br><span class="line">    (*Q).rhead=(OLink*)<span class="built_in">malloc</span>(((*Q).mu+<span class="number">1</span>)*<span class="keyword">sizeof</span>(OLink));</span><br><span class="line">    <span class="keyword">if</span>(!(*Q).rhead)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    (*Q).chead=(OLink*)<span class="built_in">malloc</span>(((*Q).nu+<span class="number">1</span>)*<span class="keyword">sizeof</span>(OLink));</span><br><span class="line">    <span class="keyword">if</span>(!(*Q).chead)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=(*Q).mu;k++) <span class="comment">/* 初始化Q的行头指针向量;各行链表为空链表 */</span></span><br><span class="line">        (*Q).rhead[k]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=(*Q).nu;k++) <span class="comment">/* 初始化Q的列头指针向量;各列链表为空链表 */</span></span><br><span class="line">        (*Q).chead[k]=<span class="literal">NULL</span>;</span><br><span class="line">    col=(OLink*)<span class="built_in">malloc</span>(((*Q).nu+<span class="number">1</span>)*<span class="keyword">sizeof</span>(OLink)); <span class="comment">/* 生成指向列的最后结点的数组 */</span></span><br><span class="line">    <span class="keyword">if</span>(!col)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=(*Q).nu;k++) <span class="comment">/* 赋初值 */</span></span><br><span class="line">        col[k]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=M.mu;i++) <span class="comment">/* 按行的顺序相加 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        pm=M.rhead[i]; <span class="comment">/* pm指向矩阵M的第i行的第1个结点 */</span></span><br><span class="line">        pn=N.rhead[i]; <span class="comment">/* pn指向矩阵N的第i行的第1个结点 */</span></span><br><span class="line">        <span class="keyword">while</span>(pm&amp;&amp;pn) <span class="comment">/* pm和pn均不空 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pm-&gt;j&lt;pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列小于矩阵N当前结点的列 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                p=(OLink)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">                <span class="keyword">if</span>(!p)</span><br><span class="line">                    <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">                (*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">                p-&gt;i=i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">                p-&gt;j=pm-&gt;j;</span><br><span class="line">                p-&gt;e=pm-&gt;e;</span><br><span class="line">                p-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">                pm=pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pm-&gt;j&gt;pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列大于矩阵N当前结点的列 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                p=(OLink)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">                <span class="keyword">if</span>(!p)</span><br><span class="line">                    <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">                (*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">                p-&gt;i=i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">                p-&gt;j=pn-&gt;j;</span><br><span class="line">                p-&gt;e=pn-&gt;e;</span><br><span class="line">                p-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">                pn=pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pm-&gt;e+pn-&gt;e) <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之和不为0 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                p=(OLink)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">                <span class="keyword">if</span>(!p)</span><br><span class="line">                    <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">                (*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">                p-&gt;i=i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">                p-&gt;j=pn-&gt;j;</span><br><span class="line">                p-&gt;e=pm-&gt;e+pn-&gt;e;</span><br><span class="line">                p-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">                pm=pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">                pn=pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之和为0 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                pm=pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">                pn=pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((*Q).rhead[i]==<span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">                (*Q).rhead[i]=pq=p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                pq-&gt;right=p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">                pq=pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((*Q).chead[p-&gt;j]==<span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">                (*Q).chead[p-&gt;j]=col[p-&gt;j]=p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;]所指结点之后 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                col[p-&gt;j]-&gt;down=p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">                col[p-&gt;j]=col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pm) <span class="comment">/* 将矩阵M该行的剩余元素插入矩阵Q */</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=(OLink)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">            <span class="keyword">if</span>(!p)</span><br><span class="line">                <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">            (*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">            p-&gt;i=i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">            p-&gt;j=pm-&gt;j;</span><br><span class="line">            p-&gt;e=pm-&gt;e;</span><br><span class="line">            p-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">            pm=pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">            <span class="keyword">if</span>((*Q).rhead[i]==<span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">                (*Q).rhead[i]=pq=p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                pq-&gt;right=p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">                pq=pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((*Q).chead[p-&gt;j]==<span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">                (*Q).chead[p-&gt;j]=col[p-&gt;j]=p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                col[p-&gt;j]-&gt;down=p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">                col[p-&gt;j]=col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pn) <span class="comment">/* 将矩阵N该行的剩余元素插入矩阵Q */</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=(OLink)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">            <span class="keyword">if</span>(!p)</span><br><span class="line">                <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">            (*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">            p-&gt;i=i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">            p-&gt;j=pn-&gt;j;</span><br><span class="line">            p-&gt;e=pn-&gt;e;</span><br><span class="line">            p-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">            pn=pn-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">            <span class="keyword">if</span>((*Q).rhead[i]==<span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">                (*Q).rhead[i]=pq=p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                pq-&gt;right=p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">                pq=pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((*Q).chead[p-&gt;j]==<span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">                (*Q).chead[p-&gt;j]=col[p-&gt;j]=p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                col[p-&gt;j]-&gt;down=p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">                col[p-&gt;j]=col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=(*Q).nu;k++)</span><br><span class="line">        <span class="keyword">if</span>(col[k]) <span class="comment">/* k列有结点 */</span></span><br><span class="line">            col[k]-&gt;down=<span class="literal">NULL</span>; <span class="comment">/*  令该列最后一个结点的down指针为空 */</span></span><br><span class="line">    <span class="built_in">free</span>(col);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="广义表的定义和存储结构"><a href="#广义表的定义和存储结构" class="headerlink" title="广义表的定义和存储结构"></a>广义表的定义和存储结构</h2><ul>
<li>存储</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* 广义表的头尾链表存储表示 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;ATOM,LIST&#125;ElemTag; <span class="comment">/* ATOM==0:原子,LIST==1:子表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTag tag; <span class="comment">/* 公共部分,用于区分原子结点和表结点 */</span></span><br><span class="line">    <span class="keyword">union</span> <span class="comment">/* 原子结点和表结点的联合部分 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        AtomType atom; <span class="comment">/* atom是原子结点的值域,AtomType由用户定义 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>,*<span class="title">tp</span>;</span></span><br><span class="line">        &#125;ptr; <span class="comment">/* ptr是表结点的指针域,prt.hp和ptr.tp分别指向表头和表尾 */</span></span><br><span class="line">    &#125;a;</span><br><span class="line">&#125;*GList,GLNode; <span class="comment">/* 广义表类型 */</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 广义表的扩展线性链表存储表示 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;ATOM,LIST&#125;ElemTag; <span class="comment">/* ATOM==0:原子,LIST==1:子表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTag tag; <span class="comment">/* 公共部分,用于区分原子结点和表结点 */</span></span><br><span class="line">    <span class="keyword">union</span> <span class="comment">/* 原子结点和表结点的联合部分 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        AtomType atom; <span class="comment">/* 原子结点的值域 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>;</span> <span class="comment">/* 表结点的表头指针 */</span></span><br><span class="line">    &#125;a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">tp</span>;</span> <span class="comment">/* 相当于线性链表的next,指向下一个元素结点 */</span></span><br><span class="line">&#125;*GList,GLNode; <span class="comment">/* 广义表类型GList是一种扩展的线性链表 */</span></span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>操作</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 5.5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GListDepth</span><span class="params">(GList L)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 采用头尾链表存储结构,求广义表L的深度。算法5.5 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>,dep;</span><br><span class="line">    GList pp;</span><br><span class="line">    <span class="keyword">if</span>(!L)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* 空表深度为1 */</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;tag==ATOM)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 原子深度为0 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">max</span>=<span class="number">0</span>,pp=L;pp;pp=pp-&gt;a.ptr.tp)</span><br><span class="line">    &#123;</span><br><span class="line">        dep=GListDepth(pp-&gt;a.ptr.hp); <span class="comment">/* 求以pp-&gt;a.ptr.hp为头指针的子表深度 */</span></span><br><span class="line">        <span class="keyword">if</span>(dep&gt;<span class="built_in">max</span>)</span><br><span class="line">            <span class="built_in">max</span>=dep;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>+<span class="number">1</span>; <span class="comment">/* 非空表的深度是各元素的深度的最大值加1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 5.6</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CopyGList</span><span class="params">(GList *T,GList L)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 采用头尾链表存储结构,由广义表L复制得到广义表T。算法5.6 */</span></span><br><span class="line">    <span class="keyword">if</span>(!L) <span class="comment">/* 复制空表 */</span></span><br><span class="line">        *T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T=(GList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode)); <span class="comment">/* 建表结点 */</span></span><br><span class="line">        <span class="keyword">if</span>(!*T)</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        (*T)-&gt;tag=L-&gt;tag;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;tag==ATOM)</span><br><span class="line">            (*T)-&gt;a.atom=L-&gt;a.atom; <span class="comment">/* 复制单原子 */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            CopyGList(&amp;((*T)-&gt;a.ptr.hp),L-&gt;a.ptr.hp);</span><br><span class="line">            <span class="comment">/* 复制广义表L-&gt;ptr.hp的一个副本T-&gt;ptr.hp */</span></span><br><span class="line">            CopyGList(&amp;((*T)-&gt;a.ptr.tp),L-&gt;a.ptr.tp);</span><br><span class="line">            <span class="comment">/* 复制广义表L-&gt;ptr.tp的一个副本T-&gt;ptr.tp */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 5.7</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateGList</span><span class="params">(GList *L,SString S)</span> <span class="comment">/* 算法5.7 */</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 采用头尾链表存储结构,由广义表的书写形式串S创建广义表L。设emp="()" */</span></span><br><span class="line">    SString sub,hsub,emp;</span><br><span class="line">    GList p,q;</span><br><span class="line">    StrAssign(emp,<span class="string">"()"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!StrCompare(S,emp))</span><br><span class="line">        *L=<span class="literal">NULL</span>; <span class="comment">/* 创建空表 */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *L=(GList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">        <span class="keyword">if</span>(!*L) <span class="comment">/* 建表结点 */</span></span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        <span class="keyword">if</span>(StrLength(S)==<span class="number">1</span>) <span class="comment">/* S为单原子 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            (*L)-&gt;tag=ATOM;</span><br><span class="line">            (*L)-&gt;a.atom=S[<span class="number">1</span>]; <span class="comment">/* 创建单原子广义表 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            (*L)-&gt;tag=LIST;</span><br><span class="line">            p=*L;</span><br><span class="line">            SubString(sub,S,<span class="number">2</span>,StrLength(S)<span class="number">-2</span>); <span class="comment">/* 脱外层括号 */</span></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123; <span class="comment">/* 重复建n个子表 */</span></span><br><span class="line">                sever(sub,hsub); <span class="comment">/* 从sub中分离出表头串hsub */</span></span><br><span class="line">                CreateGList(&amp;p-&gt;a.ptr.hp,hsub);</span><br><span class="line">                q=p;</span><br><span class="line">                <span class="keyword">if</span>(!StrEmpty(sub)) <span class="comment">/* 表尾不空 */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p=(GLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">                    <span class="keyword">if</span>(!p)</span><br><span class="line">                        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">                    p-&gt;tag=LIST;</span><br><span class="line">                    q-&gt;a.ptr.tp=p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">while</span>(!StrEmpty(sub));</span><br><span class="line">            q-&gt;a.ptr.tp=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 5.8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sever</span><span class="params">(SString str,SString hstr)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 将非空串str分割成两部分:hsub为第一个','之前的子串,str为之后的子串 */</span></span><br><span class="line">    <span class="keyword">int</span> n,k,i; <span class="comment">/* k记尚未配对的左括号个数 */</span></span><br><span class="line">    SString ch,c1,c2,c3;</span><br><span class="line">    n=StrLength(str);</span><br><span class="line">    StrAssign(c1,<span class="string">","</span>);</span><br><span class="line">    StrAssign(c2,<span class="string">"("</span>);</span><br><span class="line">    StrAssign(c3,<span class="string">")"</span>);</span><br><span class="line">    SubString(ch,str,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=n&amp;&amp;StrCompare(ch,c1)||k!=<span class="number">0</span>;++i)</span><br><span class="line">    &#123; <span class="comment">/* 搜索最外层的第一个逗号 */</span></span><br><span class="line">        SubString(ch,str,i,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!StrCompare(ch,c2))</span><br><span class="line">            ++k;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!StrCompare(ch,c3))</span><br><span class="line">            --k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        SubString(hstr,str,<span class="number">1</span>,i<span class="number">-2</span>);</span><br><span class="line">        SubString(str,str,i,n-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        StrCopy(hstr,str);</span><br><span class="line">        ClearString(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>数据结构（C语言版）.严蔚敏</li>
<li>2020年数据结构考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构复习笔记3-串</title>
    <url>/2019/07/19/shu-ju-jie-gou-fu-xi-bi-ji-3-chuan/</url>
    <content><![CDATA[<h1 id="4-串"><a href="#4-串" class="headerlink" title="4. 串"></a>4. 串</h1><h2 id="字符串的定义、存储和操作"><a href="#字符串的定义、存储和操作" class="headerlink" title="字符串的定义、存储和操作"></a>字符串的定义、存储和操作</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>串：是由零个或多个字符组成的有序序列，一般记为 s = ’$a_1a_2\cdots a_n$‘</li>
<li>长度：串中字符数目 $n$ 称为串的<strong>长度</strong></li>
<li>空串：零个字符的串称为<strong>空串</strong></li>
<li>子串：串中任意个连续的字符组成的子序列称为该串的<strong>子串</strong></li>
<li>主串：包含子串的串称为<strong>主串</strong></li>
<li>位置：字符在序列中的序号</li>
<li>相等：当且仅当两个串值相等（长度相等，对应位置的元素值相等）</li>
</ul>
<h3 id="存储与操作"><a href="#存储与操作" class="headerlink" title="存储与操作"></a>存储与操作</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 4.1</span></span><br><span class="line"><span class="comment">// 若 T 为非空串。若主串 S 中第 pos 个字符之后存在与 T 相等的子串</span></span><br><span class="line"><span class="comment">// 则返回第一个这样的子串在 S 中的位置，否则返回 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 若 pos 输入合法( &gt; 0 )，则转入第 2 步；否则返回 0 结束</span></span><br><span class="line"><span class="comment">2. 计算 S 的长度(记作 n )，T 的长度(记作 m )</span></span><br><span class="line"><span class="comment">3. 循环取 S 第 i 个位置起，长度为 T 的长度(即 m)的子串，并与 T 进行比较。</span></span><br><span class="line"><span class="comment">若相等，则返回位置 i ; 否则，继续循环</span></span><br><span class="line"><span class="comment">4. 循环结束后，还未找到，返回 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n = StrLength(S);	m = StrLength(T);	i = pos;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= n - m + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            SubString(sub, S, i, m);</span><br><span class="line">            <span class="keyword">if</span>(StrCompare(sub, T) != <span class="number">0</span>)	++i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="定长顺序存储表示"><a href="#定长顺序存储表示" class="headerlink" title="定长顺序存储表示"></a>定长顺序存储表示</h4><ul>
<li>存储</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 串的定长顺序表示</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSTRLEN 255                          <span class="comment">// 最大长度 255</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SString[MAXSTRLEN + <span class="number">1</span>];  <span class="comment">// 0 号单元存放串的长度</span></span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>操作</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 4.2 </span></span><br><span class="line"><span class="comment">// 串联接</span></span><br><span class="line"><span class="comment">// 用 T 返回由 S1 和 S2 联接而成的新串。若未截断，则返回 TRUE，否则，FALSE。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">判断三种情况，进行三种操作，具体如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">S1[0] + S2[0] &lt;= MAXSTRLEN：未截断，依次将 S1 和 S2 中的字符拷贝到 T 中，并修改 T 的长度（即令 T[0] = S1[0] + S2[0]）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">S1[0] &lt; MAXSTRLEN：截断（ S1 全部保留，S2 前一段保留），依次将 S1 全部和 S2 前一部分中的字符拷贝到 T 中，并修改 T 的长度（即令 T[0] = MAXSTRLEN）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else：截断（仅取 S1 ），依次将 S1 前一部分中的字符拷贝到 T 中，并修改 T 的长度（即令 T[0] = MAXSTRLEN）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(SString &amp;T, SString S1, SString S2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S1[<span class="number">0</span>] + S2[<span class="number">0</span>] &lt;= MAXSTRLEN)    <span class="comment">// 未截断</span></span><br><span class="line">    &#123;</span><br><span class="line">        T[<span class="number">1</span>, ..., S1[<span class="number">0</span>]] = S1[<span class="number">1</span>, ..., S1[<span class="number">0</span>]];</span><br><span class="line">        T[S1[<span class="number">0</span>]+<span class="number">1</span>, ..., S1[<span class="number">0</span>]+S2[<span class="number">0</span>]] = S2[<span class="number">1</span>, ..., S2[<span class="number">0</span>]];</span><br><span class="line">        T[<span class="number">0</span>] = S1[<span class="number">0</span>] + S2[<span class="number">0</span>];</span><br><span class="line">        uncut = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S1[<span class="number">0</span>] &lt; MAXSTRLEN)            <span class="comment">// 截断</span></span><br><span class="line">    &#123;</span><br><span class="line">        T[<span class="number">1</span>, ..., S1[<span class="number">0</span>]] = S1[<span class="number">1</span>, ..., S1[<span class="number">0</span>]];</span><br><span class="line">        T[S1[<span class="number">0</span>]+<span class="number">1</span>, ..., MAXSTRLEN] = S2[<span class="number">1</span>, ..., MAXSTRLEN - S1[<span class="number">0</span>]];</span><br><span class="line">        T[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line">        uncut = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                             <span class="comment">//截断（仅取 S1）</span></span><br><span class="line">    &#123;</span><br><span class="line">        T[<span class="number">1</span>, ..., MAXSTRLEN] = S1[<span class="number">1</span>, ..., MAXSTRLEN];</span><br><span class="line">        T[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line">        uncut = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> uncut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 4.3</span></span><br><span class="line"><span class="comment">// 求子串</span></span><br><span class="line"><span class="comment">// 用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串。</span></span><br><span class="line"><span class="comment">// 其中，1 ≤ pos ≤ StrLength(S) 且 0 ≤ len StrLength(S) - pos + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. pos 和 len 的合法性判断（具体范围见上）：若不满足，则返回错误；否则，第二步</span></span><br><span class="line"><span class="comment">2. 依次拷贝 S 中对应位置元素到 Sub 中，并修改 Sub 的长度（Sub[0] = len;），返回成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">SubString</span><span class="params">(SString &amp;Sub, SString S, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; StrLength(S) || len &lt; <span class="number">0</span> || len &gt; S[<span class="number">0</span>] -pos + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    Sub[<span class="number">1</span>, ..., len] = S[pos, ..., pos + len - <span class="number">1</span>];</span><br><span class="line">    Sub[<span class="number">0</span>] = len;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="堆分配存储表示"><a href="#堆分配存储表示" class="headerlink" title="堆分配存储表示"></a>堆分配存储表示</h4><hr>
<ul>
<li>存储</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 串的堆分配存储表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch;        <span class="comment">// 若是非空串，则按串长分配存储区，否则 ch 为 NULL；</span></span><br><span class="line">    <span class="keyword">int</span>  length;     <span class="comment">// 串长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>操作</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 4.4</span></span><br><span class="line"><span class="comment">// 1 ≤ pos ≤ StrLength(S)。在串 S 的第 pos 个字符之前插入串 T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. pos 合法性判断（具体范围见上）：若不满足，则返回错误；否则，第二步</span></span><br><span class="line"><span class="comment">2. 若 T 非空，则重新分配空间（长度为两个串长度之和）：若空间申请失败，则溢出，退出；否则，循环腾出插入位置，将 T 插入，并修改结果串的总长度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">StrInsert</span><span class="params">(HString &amp;S, <span class="keyword">int</span> pos, HString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; StrLength + <span class="number">1</span>)<span class="comment">// pos 不合法</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(T.length) <span class="comment">// T 非空，S 重新分配空间，将 T 插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(S.ch = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(S.ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(S.length + T.length))))<span class="comment">// 注意写法</span></span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i = S.length - <span class="number">1</span>; i &gt;= pos - <span class="number">1</span>; --i)<span class="comment">// 为插入T而腾出位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            S.ch[i + T.length] = S.ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">        S.ch[pos<span class="number">-1</span>, ..., pos + T.length - <span class="number">2</span>] = T[<span class="number">0</span>, ..., T.length - <span class="number">1</span>];<span class="comment">//插入 T</span></span><br><span class="line">        S.length += T.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>以下为基本操作（最小操作子集）</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 串的新建赋值</span></span><br><span class="line"><span class="comment">// 生成一个其值等于串常量 chars 的串 T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 若 T 的 ch 域非空，则释放原有空间</span></span><br><span class="line"><span class="comment">2. 计算 chars 的长度</span></span><br><span class="line"><span class="comment">3. 若 chars 的长度为为 0，则置 T 的 ch 域为空，length 为 0；</span></span><br><span class="line"><span class="comment">否则，申请新空间（若申请失败，则溢出，退出），依次复制 chars 中的字符到 T 的 ch 域的对应位置，并更新 T 的 length 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(HString &amp;T, <span class="keyword">char</span>* chars)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T.ch)	<span class="built_in">free</span>(T.ch);              <span class="comment">// 释放 T 原有的空间（注意别漏掉）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, c = chars; *c; ++i, ++c); <span class="comment">// 求 chars 的长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(! i)</span><br><span class="line">    &#123;</span><br><span class="line">        T.ch = <span class="literal">NULL</span>;</span><br><span class="line">        T.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(T.ch = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(i * <span class="keyword">sizeof</span>(<span class="keyword">char</span>))))</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        </span><br><span class="line">        T.ch[<span class="number">0</span>, ..., i - <span class="number">1</span>] = chars[<span class="number">0</span>, ..., i - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        T.length = i;<span class="comment">// 别漏掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 串的长度</span></span><br><span class="line"><span class="comment">// 返回 S 的元素个数，称为串的长度</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength</span><span class="params">(HString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 串的比较( 实现巧妙 )</span></span><br><span class="line"><span class="comment">// 若 S &gt; T ，则返回值 &gt; 0；</span></span><br><span class="line"><span class="comment">// 若 S = T ，则返回值 = 0；</span></span><br><span class="line"><span class="comment">// 若 S &lt; T ，则返回值 &lt; 0；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(HString S, HString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; S.length &amp;&amp; i &lt; T.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] != T.ch[i])	<span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> S.length &lt; T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 串的清空</span></span><br><span class="line"><span class="comment">// 将 S 清为空串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ClearString</span><span class="params">(HString &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(s.ch);</span><br><span class="line">        S.ch = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    S.length = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 串的联接</span></span><br><span class="line"><span class="comment">// 用 T 返回由 S1 和 S2 联接而成的新串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 若 T 的 ch 域非空，则释放原有空间</span></span><br><span class="line"><span class="comment">2. 为 T 的 ch 申请空间。若申请失败，溢出，退出；否则，转入第 3 步</span></span><br><span class="line"><span class="comment">3. 依次将 S1 、 S2 中的值复制到 T 的 ch 对应位置，并更新 T.length，返回成功。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Concat</span><span class="params">(HString &amp;T, HString S1, HString S2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T.ch)	<span class="built_in">free</span>(T.ch);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!(T.ch = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>((S1.length + S2.length) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>))))</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    </span><br><span class="line">    T.ch[<span class="number">0</span>, ..., S1.length - <span class="number">1</span>] = S1[<span class="number">0</span>, ..., S1.length - <span class="number">1</span>];</span><br><span class="line">    T.length = S1.length + S2.length;</span><br><span class="line">    T[S1.length + <span class="number">1</span>, ..., T.length - <span class="number">1</span>] = S2[<span class="number">1</span>, ..., S2.length - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求串的子串</span></span><br><span class="line"><span class="comment">// 用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串。</span></span><br><span class="line"><span class="comment">// 其中，1 ≤ pos ≤ StrLength(S) 且 0 ≤ len ≤ StrLength(S) - pos + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. pos 和 len 的合法性判断（具体范围见上）：若不满足，则返回错误；否则，第二步</span></span><br><span class="line"><span class="comment">2. 若 Sub 的 ch 域非空，则释放原有空间</span></span><br><span class="line"><span class="comment">3. 若 chars 的长度为为 0，则置 Sub 的 ch 域为空，length 为 0；</span></span><br><span class="line"><span class="comment">否则依次拷贝 S 中对应位置元素到 Sub 中，并修改 Sub 的长度（Sub.length = len;），返回成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SubString</span><span class="params">(HString &amp;Sub, HString S, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; S.length) || len &lt; <span class="number">0</span> || len &gt; S.length -pos + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Sub.ch)	<span class="built_in">free</span>(Sub.ch);</span><br><span class="line">    <span class="keyword">if</span>(! len)	</span><br><span class="line">    &#123;</span><br><span class="line">        Sub.ch = <span class="literal">NULL</span>;</span><br><span class="line">        Sub.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Sub.ch = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * len);</span><br><span class="line">        Sub.ch[<span class="number">0</span>, ..., len - <span class="number">1</span>] = S.ch[pos - <span class="number">1</span>, ..., pos + len - <span class="number">2</span>];</span><br><span class="line">        Sub.length = len;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="块链存储表示"><a href="#块链存储表示" class="headerlink" title="块链存储表示"></a>块链存储表示</h4><ul>
<li>存储</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 串的块链存储表示</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CHUNKSIZE 80       <span class="comment">// 块的大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>   ch[CHUNKSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Chunk *head, *tail;     <span class="comment">// 串的头尾指针（设置尾指针是为了方便联接操作）</span></span><br><span class="line">    <span class="keyword">int</span>   curlen;           <span class="comment">// 串的当前长度</span></span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>操作（与线性表相关操作类似）</li>
</ul>
<h2 id="字符串的模式匹配（★）"><a href="#字符串的模式匹配（★）" class="headerlink" title="字符串的模式匹配（★）"></a>字符串的模式匹配（★）</h2><p>（下面均以顺序存储结构为例）</p>
<h3 id="原始算法"><a href="#原始算法" class="headerlink" title="原始算法"></a>原始算法</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 4.5</span></span><br><span class="line"><span class="comment">// 利用模式串 T 的 next 函数求 T 在主串 S 中第 pos 个字符之后位置</span></span><br><span class="line"><span class="comment">// 若不存在，则函数值返回 0</span></span><br><span class="line"><span class="comment">// 其中 T 非空， 1 ≤ pos ≤ StrLength(S)</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(mn)，n 为主串长度，m 为模式串长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 初始化 i(= pos) 、 j(= 1)</span></span><br><span class="line"><span class="comment">2. 当 i 、 j 均小于各自字符串的长度时循环：</span></span><br><span class="line"><span class="comment">若 S 的 i 位置与 T 的 j 位置元素相等，则 i 、 j 自增；</span></span><br><span class="line"><span class="comment">若不等，则 i 回退(= i - j + 2)， j 重置(= 1)</span></span><br><span class="line"><span class="comment">3. 循环结束后，若 j &gt; T[0]，则返回 i - T[0]；否则返回 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = pos;	j = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == T[j])	&#123;++i;	++j;&#125;</span><br><span class="line">        <span class="keyword">else</span>	&#123;i = i - j + <span class="number">2</span>;	j = <span class="number">1</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(j &gt; T[<span class="number">0</span>])	<span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><h4 id="匹配算法"><a href="#匹配算法" class="headerlink" title="匹配算法"></a>匹配算法</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 4.6</span></span><br><span class="line"><span class="comment">// KMP 算法</span></span><br><span class="line"><span class="comment">// 利用模式串 T 的 next 函数求 T 在主串 S 中第 pos 个字符之后位置</span></span><br><span class="line"><span class="comment">// 其中 T 非空， 1 ≤ pos ≤ StrLength(S)</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n + m)，n 为主串长度，m 为模式串长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 初始化 i(= pos) 、 j(= 1)</span></span><br><span class="line"><span class="comment">2. 当 i 、 j 均小于各自字符串的长度时循环：</span></span><br><span class="line"><span class="comment">若 S 的 i 位置与 T 的 j 位置元素相等或者 j 为 0 （别漏），则 i 、 j 自增；</span></span><br><span class="line"><span class="comment">若不等， j 取 next[j]</span></span><br><span class="line"><span class="comment">3. 循环结束后，若 j &gt; T[0]，则返回 i - T[0]；否则返回 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = pos;	j = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S[i] == T[j])            <span class="comment">// 继续比较后续字符</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                  <span class="comment">// 模式串向右移动</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(j &gt; T[<span class="number">0</span>])                              <span class="comment">// 匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="计算-next-数组"><a href="#计算-next-数组" class="headerlink" title="计算 next 数组"></a>计算 next 数组</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 4.7</span></span><br><span class="line"><span class="comment">// 求模式串 T 的 next 函数值并存入数组 next</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(m)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(SString T <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = <span class="number">1</span>;	next[<span class="number">1</span>] = <span class="number">0</span>;	j = <span class="number">0</span>;<span class="comment">// i 从 1 开始，j 从 0开始 </span></span><br><span class="line">                                  <span class="comment">// next[1]= 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt; T[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T[i] == T[j])<span class="comment">// j == 0 别漏</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;  <span class="comment">// j 为最长相等前后缀长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];  <span class="comment">// 字符串移动公式（推导见王道 6.5.5节）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 4.8</span></span><br><span class="line"><span class="comment">// 算法 4.7 的改进版，效率更高</span></span><br><span class="line"><span class="comment">// 求模式串 T 的 next 函数修正值并存入数组 nextval</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(SString T <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = <span class="number">1</span>;	nextval[<span class="number">1</span>] = <span class="number">0</span>;	j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt; T[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T[i] == T[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 改进部分</span></span><br><span class="line">            <span class="keyword">if</span>(T[i] != T[j])<span class="comment">// 连续不等情况</span></span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span>            <span class="comment">//连续相等情况</span></span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充：一种手算-next-数组的方法"><a href="#补充：一种手算-next-数组的方法" class="headerlink" title="补充：一种手算 next 数组的方法"></a>补充：一种手算 next 数组的方法</h3><p>教材写的太难懂了，这里分享一下王道中的方法。</p>
<p>先理清几个概念：</p>
<ul>
<li>前缀：除最后一个字符，字符串的所有头部子串</li>
<li>后缀：除第一个字符，字符串的所有尾部子串</li>
<li>部分匹配值：字符串的前缀和后缀的最长相等前后缀长度</li>
</ul>
<p>举个例子：计算  <strong>‘ababa’</strong> 的 next 数组</p>
<ol>
<li>先算部分匹配值</li>
</ol>
<table>
<thead>
<tr>
<th align="center">子串</th>
<th align="center">前缀</th>
<th align="center">后缀</th>
<th align="center">前后缀交集</th>
<th align="center">最长相等前后缀长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">‘a’</td>
<td align="center">$\varnothing$</td>
<td align="center">$\varnothing$</td>
<td align="center">$\varnothing$</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">‘ab’</td>
<td align="center">{‘a’}</td>
<td align="center">{‘b’}</td>
<td align="center">$\varnothing$</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">‘aba’</td>
<td align="center">{‘a’, ‘ab’}</td>
<td align="center">{‘ba’, ‘a’}</td>
<td align="center">{‘a’}</td>
<td align="center">1(= len(‘a’))</td>
</tr>
<tr>
<td align="center">‘abab’</td>
<td align="center">{‘a’, ‘ab’, ‘aba’}</td>
<td align="center">{‘bab’, ‘ab’, ‘b’}</td>
<td align="center">{‘ab’}</td>
<td align="center">2(= len(‘ab’))</td>
</tr>
<tr>
<td align="center">‘ababa’</td>
<td align="center">{‘a’, ‘ab’, ‘aba’, ‘abab’}</td>
<td align="center">{‘baba’, ‘aba’, ‘ba’,’ a’}</td>
<td align="center">{‘a’, ‘aba’}</td>
<td align="center">3(= len(‘aba’))</td>
</tr>
</tbody></table>
<p>故部分匹配值为 <code>00123</code></p>
<ol start="2">
<li>再算 next 数组</li>
</ol>
<p>next 数组为上述匹配值先右移（左边补 -1），再每位加 1</p>
<p>此例便为</p>
<ul>
<li>右移：<code>-10012</code> （注：若位序从 0 开始，取这个答案）</li>
<li>每位加一：<code>01123</code> （注：若位序从 1 开始，取这个答案）</li>
</ul>
<p>故此例 next 数组为 <code>01123</code></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>数据结构（C语言版）.严蔚敏</li>
<li>2020年数据结构考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构复习笔记2-栈和队列</title>
    <url>/2019/07/14/shu-ju-jie-gou-fu-xi-bi-ji-2-zhan-he-dui-lie/</url>
    <content><![CDATA[<h1 id="3．栈和队列"><a href="#3．栈和队列" class="headerlink" title="3．栈和队列"></a>3．栈和队列</h1><h2 id="栈和队列的定义；"><a href="#栈和队列的定义；" class="headerlink" title="栈和队列的定义；"></a>栈和队列的定义；</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>限定<strong>仅在表尾</strong>进行<strong>插入</strong> 或<strong>删除</strong>操作的线性表。表尾称为<strong>栈顶</strong>，表头称为<strong>栈底</strong>。</li>
<li><strong>后进先出</strong></li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>限定在<strong>一端插入</strong>，<strong>另一端删除</strong>的线性表。允许插入的一端叫做<strong>队尾</strong>，允许删除的一端叫做<strong>队头</strong>。</li>
<li><strong>先进先出</strong></li>
</ul>
<h2 id="栈和队列的顺序和链式存储；"><a href="#栈和队列的顺序和链式存储；" class="headerlink" title="栈和队列的顺序和链式存储；"></a>栈和队列的顺序和链式存储；</h2><h3 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><ul>
<li>存储</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 栈的顺序存储表示</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100; <span class="comment">// 存储空间初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10;   <span class="comment">// 存储空间分配增量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType *base;         <span class="comment">// 在栈构造之前和销毁之后， base的值为 NULL</span></span><br><span class="line">    SElemType *top;          <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> stacksize;           <span class="comment">// 当前已分配的存储空间，以元素为单位</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>操作</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个空栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 申请栈的初始空间，并将头指针赋给 S.base</span></span><br><span class="line"><span class="comment">2. 判断是否申请成功。若不成功，则返回溢出，退出；</span></span><br><span class="line"><span class="comment">否则，初始化 S.top（= S.base） 和 S.statcksize （= 初始栈的大小），返回成功。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.base = (SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(SElemType));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(! S.base)	<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    </span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = STACK_INIT_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取栈 S 的栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">若栈不空，则用 e 返回 S 的栈顶元素，并返回 OK； </span></span><br><span class="line"><span class="comment">否则返回 Error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base)		<span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    e = *(S.top - <span class="number">1</span>); <span class="comment">// ☆☆☆ 注意要减一</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向栈 S 插入一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 判断栈是否已满。若已满，重新申请空间：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">若申请失败，返回溢出，退出；</span></span><br><span class="line"><span class="comment">否则，修改 S.top (= S.base + S.stacksize) 和 S.stacksize(+= STACKINCREMENT)，再进入第二步；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">否则转入第二步</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 将 e 的值填入 S.top 指针所指的位置，并自增 S.top ，使其指向下一个插入位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base &gt;= S.stacksize)</span><br><span class="line">    &#123;</span><br><span class="line">        S.base = (SElemType *)<span class="built_in">realloc</span>(S.base, (S.stacksize + STACKINCREMENT) * <span class="keyword">sizeof</span>(SElemType));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(! S.base)	<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    </span><br><span class="line">    	S.top = S.base + S.stacksize;</span><br><span class="line">    	S.stacksize += STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *S.top++ = e;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除并返回栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">若栈不空，则删除 S 的栈顶元素，用 e 返回 S 的栈顶元素，并返回 OK； </span></span><br><span class="line"><span class="comment">否则返回 Error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base)		<span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    e = * --S.top;    <span class="comment">//☆☆☆ 先减 1，再取值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><ul>
<li>存储</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 栈的链式存储表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LSNode</span>&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LSNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;LSNode *LinkStack;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>操作（带头节点）</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个空栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 申请栈的头节点 S</span></span><br><span class="line"><span class="comment">2. 判断是否申请成功。若不成功，则返回溢出，退出；</span></span><br><span class="line"><span class="comment">否则，初始化 S-&gt;next（= NULL），返回成功。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S = (LinkStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LSNode));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!S )	<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    </span><br><span class="line">    S-&gt;next = NuLL;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取栈 S 的栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">若栈不空，则用 e 返回 S 的栈顶元素，并返回 OK； </span></span><br><span class="line"><span class="comment">否则返回 Error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(LinkStack S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;next == <span class="literal">NULL</span>)		<span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    e = S-&gt;next-&gt;data; <span class="comment">// ☆☆☆ 注意，取头节点的下一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向栈 S 插入一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 将 e 赋值到头节点</span></span><br><span class="line"><span class="comment">2. 申请新的结点。若申请失败，则溢出，退出；否则转入第三步</span></span><br><span class="line"><span class="comment">3. 采用头插法插入链栈，返回成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    S-&gt;data = e;</span><br><span class="line">    </span><br><span class="line">    p = (LinkStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LSNode));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(! p)		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    </span><br><span class="line">    p-&gt;next = S-&gt;next;</span><br><span class="line">    S = p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除并返回栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">若栈不空，则删除 S 的栈顶元素，用 e 返回 S 的栈顶元素，并返回 OK； </span></span><br><span class="line"><span class="comment">否则返回 Error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;next == <span class="literal">NULL</span>)		<span class="keyword">return</span> ERROR;   <span class="comment">// 判空</span></span><br><span class="line">    </span><br><span class="line">    p = S-&gt;next;			e = p-&gt;data;    <span class="comment">// 取值</span></span><br><span class="line">    </span><br><span class="line">    S-&gt;next = p-&gt;next;		<span class="built_in">free</span>(p);        <span class="comment">// 删除结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h3><h4 id="顺序存储（循环队列）"><a href="#顺序存储（循环队列）" class="headerlink" title="顺序存储（循环队列）"></a>顺序存储（循环队列）</h4><ul>
<li>存储</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环队列——队列的顺序存储结构</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 100        <span class="comment">// 最大队列长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QElemtype *base;        <span class="comment">// 初始化的动态分配空间</span></span><br><span class="line">    <span class="keyword">int</span> front;              <span class="comment">// 头指针，若队列不空，指向队列头元素</span></span><br><span class="line">    <span class="keyword">int</span> rear;               <span class="comment">// 尾指针，若队列不空，则指向队尾的下一个位置</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>操作</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个空队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 申请顺序队列的存储空间，赋给 Q.base</span></span><br><span class="line"><span class="comment">2. 判断是否申请成功。若不成功，溢出，退出；否则，转入第三步</span></span><br><span class="line"><span class="comment">3. 初始化队头指针 Q.front(= 0) 和 队尾指针 Q.rear(= 0)，返回成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.base = (QElemType *)<span class="built_in">malloc</span>(MAXQSIZE * <span class="keyword">sizeof</span>(QElemType));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(! Q.base)		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    </span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求队列长度</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 判断队列是否已满。若已满，返回错误；否则转入第二步</span></span><br><span class="line"><span class="comment">2. 向队尾所指位置赋值，并使队尾自增加一（注意要【取模】），返回成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp; Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MAXQSIZE == Q.front)	<span class="comment">//队满	</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    Q.base[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXQSIZE;  <span class="comment">//自增注意要取模</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 判断队列是否为空。若空，返回错误；否则转入第二步</span></span><br><span class="line"><span class="comment">2. 取队头指针所指位置的元素值，并使队头自增加一（注意要【取模】），返回成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)   <span class="comment">// 队空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    </span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="链式存储（单链队列）"><a href="#链式存储（单链队列）" class="headerlink" title="链式存储（单链队列）"></a>链式存储（单链队列）</h4><ul>
<li>存储</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链队列——队列的链式存储结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> QNode&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueuePtr front;     <span class="comment">// 队头指针</span></span><br><span class="line">    Queueptr rear;      <span class="comment">// 队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>操作（带头结点，即头节点不存储任何值）</li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个空队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 申请队列的头尾结点，初始指向同一个位置</span></span><br><span class="line"><span class="comment">2. 判断是否申请成功。若不成功，则返回溢出，退出；</span></span><br><span class="line"><span class="comment">否则，初始化 Q.front-&gt;next（= NULL），返回成功。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!Q.front)	<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    </span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁队列 Q</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">从队头指针循环释放队头指针所指位置的空间，用 Q.rear 暂存 Q.front 的下一个位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(Q.front)</span><br><span class="line">    &#123;</span><br><span class="line">        Q.rear = Q.front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(Q.front);</span><br><span class="line">        Q.front = Q.rear;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 申请新结点空间</span></span><br><span class="line"><span class="comment">2. 若申请失败，溢出，退出；</span></span><br><span class="line"><span class="comment">否则，第三步</span></span><br><span class="line"><span class="comment">3. 将 e 赋给新结点，并插入队尾位置（ 3 处指针修改 ）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!p)		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    </span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 书上写法</span></span><br><span class="line">    p-next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//等价写法</span></span><br><span class="line">    <span class="comment">/*p-&gt;next = Q.rear-&gt;next;     //包含三个指针的修改！！</span></span><br><span class="line"><span class="comment">    Q.rear-&gt;next = p;</span></span><br><span class="line"><span class="comment">    Q.rear = p;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 判断队列是否为空。若空，则溢出，退出；否则第二步</span></span><br><span class="line"><span class="comment">2. 保存队头所指元素值，并删除该结点（注意删除的是最后一个元素的情况），返回成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue&amp; Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)		<span class="built_in">exit</span>(ERROR);</span><br><span class="line">    </span><br><span class="line">    p = Q.front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)		Q.rear = Q.front; <span class="comment">//尤其注意！！！</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="栈和队列的应用；"><a href="#栈和队列的应用；" class="headerlink" title="栈和队列的应用；"></a>栈和队列的应用；</h2><h3 id="栈-2"><a href="#栈-2" class="headerlink" title="栈"></a>栈</h3><h4 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于输入的任意一个十进制整数，打印输出与其等值的八进制数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 构造空栈，获取输入</span></span><br><span class="line"><span class="comment">2. 循环取模入栈。</span></span><br><span class="line"><span class="comment">3. 循环出栈，输出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">conversion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, N);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(N)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(S, N % <span class="number">8</span>);</span><br><span class="line">        N = N / <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!StackEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        Pop(S, e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="括号匹配检查-★"><a href="#括号匹配检查-★" class="headerlink" title="括号匹配检查(★)"></a>括号匹配检查(★)</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 括号匹配检查(自己写的，仅供参考)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 构造空栈</span></span><br><span class="line"><span class="comment">2. 遍历字符串，若是左括号，则入栈；</span></span><br><span class="line"><span class="comment">若是右括号：若此时栈为空，返回不匹配，退出；若栈顶元素与当前遍历到括号不匹配，则返回不匹配，退出；否则继续循环。</span></span><br><span class="line"><span class="comment">3. 循环结束后，判断栈是否为空。</span></span><br><span class="line"><span class="comment">若为空，则匹配；</span></span><br><span class="line"><span class="comment">否则，不匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">parenthesesCheck</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'('</span> ||</span><br><span class="line">           s[i] == <span class="string">'['</span> ||</span><br><span class="line">           s[i] == <span class="string">'&#123;'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(S, s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">')'</span> ||</span><br><span class="line">                s[i] == <span class="string">']'</span> ||</span><br><span class="line">                s[i] == <span class="string">'&#125;'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(StackEmpty(S))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            Pop(S, e);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(! match(s[i], e))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(S))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="行编辑程序"><a href="#行编辑程序" class="headerlink" title="行编辑程序"></a>行编辑程序</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 3.2</span></span><br><span class="line"><span class="comment">// 利用字符栈 S，从终端接收一行并传送至调用过程的数据区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 构造空栈，获取第一个字符输入</span></span><br><span class="line"><span class="comment">2. 若输入不为 EOF ，则循环：</span></span><br><span class="line"><span class="comment">若输入不为 EOF 并且不为 换行符，则判断输入字符类型：</span></span><br><span class="line"><span class="comment">① 若为 退格 ，则退栈；</span></span><br><span class="line"><span class="comment">② 若为 退行 ，则重置栈为空栈；</span></span><br><span class="line"><span class="comment">默认，将输入字符入栈</span></span><br><span class="line"><span class="comment">3. 内层循环结束后，将栈中的元素拷贝到相应的数据区，并重置栈为空栈。</span></span><br><span class="line"><span class="comment">4. 判断当前输入字符是否为 EOF 。若不是，则等待下一个输入，继续外层循环；否则外层循环结束。</span></span><br><span class="line"><span class="comment">5. 销毁栈的相关空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LineEdit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    ch = getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(ch != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ch != EOF &amp;&amp; ch != <span class="string">'\n'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(ch)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'#'</span>: Pop(S, c);	<span class="keyword">break</span>; <span class="comment">// 仅当栈非空时退栈</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">'@'</span>: ClearStack(S);<span class="keyword">break</span>; <span class="comment">// 重置 S 为空栈</span></span><br><span class="line">                <span class="keyword">default</span>:  Push(S, ch);  <span class="keyword">break</span>; <span class="comment">// 有效字符进栈，未考虑栈满</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ch = getchar();    <span class="comment">//从终端接收下一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        将从栈底到栈顶的栈内字符传送到调用过程的数据区；</span><br><span class="line">        ClearStack(S);         <span class="comment">// 重置 S 为空栈</span></span><br><span class="line">        <span class="keyword">if</span> (ch != EOF)	ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    DestroyStack(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="迷宫求解"><a href="#迷宫求解" class="headerlink" title="迷宫求解"></a>迷宫求解</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 3.3</span></span><br><span class="line"><span class="comment">// 若迷宫 maze 中存在从入口 start 到出口 end 的通道，</span></span><br><span class="line"><span class="comment">// 则求得一条存放在栈中（从栈底到栈顶），并返回 True；否则返回 False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ord;              <span class="comment">// 通道块在路径上的“序号”</span></span><br><span class="line">    PostType seat;        <span class="comment">// 通道块在迷宫中的“坐标位置”</span></span><br><span class="line">    <span class="keyword">int</span> di;               <span class="comment">// 从此通道块走向下一个通道块的“方向”</span></span><br><span class="line">&#125;SElemType;               <span class="comment">// 栈的元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">MazePath</span><span class="params">(MazeType maze, PostType start, PostType <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitStack(S);	curpos = start;      <span class="comment">// 设定“当前位置”为“入口位置”</span></span><br><span class="line">    curstep = <span class="number">1</span>;                         <span class="comment">// 探索第一步</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Pass(curpos))<span class="comment">// 当前位置可以通过，即是未曾走到过的通道块</span></span><br><span class="line">        &#123;</span><br><span class="line">            FootPoint(curpos);           <span class="comment">// 留下足迹</span></span><br><span class="line">            e = (curstep, curpos, <span class="number">1</span>);</span><br><span class="line">            Push(S, e);                  <span class="comment">// 加入路径</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curpos == <span class="built_in">end</span>)	<span class="keyword">return</span> True;<span class="comment">// 到达终点</span></span><br><span class="line">            </span><br><span class="line">            curpos = NextPos(curpos, <span class="number">1</span>); <span class="comment">// 下一个位置是当前位置的东邻</span></span><br><span class="line">            curstep++;                   <span class="comment">// 探索下一步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>            <span class="comment">// 当前位置不能通过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(! StackEmpty(S))</span><br><span class="line">            &#123;</span><br><span class="line">                Pop(S, e);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(e.di == <span class="number">4</span> &amp;&amp; ! StackEmpty(S))</span><br><span class="line">                &#123;</span><br><span class="line">                    MarkPrint(e.seat);   <span class="comment">// 留下不能通过过的标记 </span></span><br><span class="line">                    Pop(S, e);           <span class="comment">// 并退回一步</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(e.di &lt; <span class="number">4</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.di ++;	Push(S, e); <span class="comment">// 换下一个方向探索</span></span><br><span class="line">                    curpos = NextPos(e.seat, e.di);<span class="comment">// 设定当前位置是该新方向上的相邻块</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(! StackEmpty(S));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> False;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="表达式求值-★"><a href="#表达式求值-★" class="headerlink" title="表达式求值(★)"></a>表达式求值(★)</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 3.4</span></span><br><span class="line"><span class="comment">// 算术表达式求值的算符优先文法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 初始化两个栈，运算符栈 OPTR（初始化，将 '#' 入栈） 运算数栈 OPND</span></span><br><span class="line"><span class="comment">2. 当输入字符不为结束字符，并且 OPTR 栈顶不为 '#', 循环判断：</span></span><br><span class="line"><span class="comment">若输入字符不为运算符，则入栈 OPND，并等待下一个输入；</span></span><br><span class="line"><span class="comment">否则，判断当前算符和栈顶算符的优先级关系：</span></span><br><span class="line"><span class="comment">若栈顶 &lt; 输入，则入栈 OPTR，并等待下一个输入；</span></span><br><span class="line"><span class="comment">若栈顶 = 输入，则出栈 OPTR，并等待下一个输入；（去括号）</span></span><br><span class="line"><span class="comment">若栈顶 &gt; 输入，则出栈 OPTR(theta)，出栈 OPND( b【先出】 和 a【后出】 )，将 a theta b 的结果入栈 OPND；</span></span><br><span class="line"><span class="comment">3. 循环结束后，将 OPND 栈顶的值返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">OperandType <span class="title">EvaluateExpression</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitStack(OPTR); Push(OPTR, <span class="string">'#'</span>);           <span class="comment">// 运算符栈</span></span><br><span class="line">    InitStack(OPND);                            <span class="comment">// 运算数栈 </span></span><br><span class="line">    c = getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(c != <span class="string">'#'</span> || GetTop(OPTR) != <span class="string">'#'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(! In(c, OP))                         <span class="comment">// OP 为运算符集合</span></span><br><span class="line">        &#123;</span><br><span class="line">            Push(OPND, c);                      <span class="comment">// 不是运算符，进栈</span></span><br><span class="line">            c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(Precede(GetTop(OPTR), c))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&lt;'</span>:                    <span class="comment">// 栈顶元素优先级低</span></span><br><span class="line">                    Push(OPTR, c);</span><br><span class="line">                    c = getchar();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'='</span>:                    <span class="comment">// 脱括号并接收下一字符</span></span><br><span class="line">                    Pop(OPTR, x);</span><br><span class="line">                    c = getchar();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&gt;'</span>:                    <span class="comment">// 退栈，并将运算结果入栈</span></span><br><span class="line">                    Pop(OPTR, theta);</span><br><span class="line">                    Pop(OPND, b); Pop(OPND. a);</span><br><span class="line">                    Push(OPND, Operate(a, theta, b));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> GetTop(OPND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="实现递归-★"><a href="#实现递归-★" class="headerlink" title="实现递归(★)"></a>实现递归(★)</h4><ul>
<li>利用栈实现递归程序到非递归程序的转换。</li>
</ul>
<h3 id="队列-2"><a href="#队列-2" class="headerlink" title="队列"></a>队列</h3><h4 id="离散事件模拟（略-P65）"><a href="#离散事件模拟（略-P65）" class="headerlink" title="离散事件模拟（略 P65）"></a>离散事件模拟（略 P65）</h4><h2 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h2><h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><ul>
<li>两个顺序栈共享一个一维数据空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。</li>
<li>共享空间为从左到右，下标从 <code>0</code> 到 <code>MaxSize - 1</code> 的一维数组。0 号栈从 <code>0</code> 向中间延伸，1 号栈从 <code>MaxSize - 1</code> 向中间延伸。</li>
<li>判空条件<ul>
<li>0 号栈：<code>top0 = -1</code></li>
<li>1 号栈：<code>top1 = MaxSize</code></li>
</ul>
</li>
<li>判满条件<ul>
<li><code>top1 - top0 = 1</code></li>
</ul>
</li>
<li>优点<ul>
<li>节约存储空间</li>
<li>降低发生上溢的可能</li>
</ul>
</li>
</ul>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><ul>
<li>两端都可以出队、入队</li>
<li>输出受限的双端队列<ul>
<li>一端可插入、删除；另一端只能插入</li>
</ul>
</li>
<li>输入受限的双端队列<ul>
<li>一端可插入、删除；另一端只能删除</li>
</ul>
</li>
<li>相关解题技巧：把既可插入、又可删除的部分看作一个栈；把另一端视情况看作队列。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>数据结构（C语言版）.严蔚敏</li>
<li>2020年数据结构考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构复习笔记1-绪论及线性表</title>
    <url>/2019/07/11/shu-ju-jie-gou-fu-xi-bi-ji-1-xu-lun-ji-xian-xing-biao/</url>
    <content><![CDATA[<h1 id="1-数据结构基本概念及简单的算法分析"><a href="#1-数据结构基本概念及简单的算法分析" class="headerlink" title="1. 数据结构基本概念及简单的算法分析"></a>1. 数据结构基本概念及简单的算法分析</h1><h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><ol>
<li><strong>数据</strong>：数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。</li>
<li><strong>数据元素</strong>：数据元素是数据的基本单位，通常作为一个整体进行思考和处理。一个数据元素可由若干 <em>数据项</em> 组成，数据项是构成数据元素的不可分割的最小单位。</li>
<li><strong>数据对象</strong>：数据对象是具有相同性质的数据元素的集合，是数据的一个子集。</li>
<li><strong>数据类型</strong>：数据类型是一个值的集合和定义在此集合上的一组操作的总称。<ol>
<li><strong>原子类型</strong>。其值不可再分的数据类型。</li>
<li><strong>结构类型</strong>：其值可以再分解为若干成分（分量）的数据类型</li>
<li><strong>抽象数据类型</strong>：抽象数据组织及与之相关的操作。</li>
</ol>
</li>
<li><strong>抽象数据类型</strong>：抽象数据类型（ <strong>ADT</strong> ）是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其其在计算机内部如何表示和实现无关，即不论其内部结构如何变化，只要它的数学特性不变，都不影响其外部使用。通常用 <strong>（数据对象，数据关系，基本操作集）</strong> 这样的三元组来表示抽象数据类型。</li>
<li>数据结构：在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为 <strong>结构</strong> 。<strong>数据结构</strong> 是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括以下三方面的内容：<ol>
<li><strong>逻辑结构</strong><ul>
<li>是指数据元素之间的逻辑关系，即从逻辑关系描述数据。</li>
<li>与数据的存储无关，是独立于计算机的。</li>
<li>分为<strong>线性结构</strong>和<strong>非线性结构</strong></li>
<li>4 种基本结构<ol>
<li>集合</li>
<li>线性结构</li>
<li>树形结构</li>
<li>图状结构或网状结构</li>
</ol>
</li>
</ul>
</li>
<li><strong>存储结构</strong><ul>
<li>是指数据结构在计算机中的表示（又称<strong>映像</strong>），也称<strong>物理结构</strong>。</li>
<li>包括<strong>数据的表示</strong>和<strong>关系的表示</strong>。</li>
<li>依赖于计算机语言</li>
<li>4 种存储结构<ol>
<li>顺序存储</li>
<li>链式存储</li>
<li>索引存储</li>
<li>散列存储</li>
</ol>
</li>
</ul>
</li>
<li><strong>数据运算</strong><ul>
<li>包括<strong>定义</strong>和<strong>实现</strong></li>
<li><strong>定义</strong>：针对<strong>逻辑结构</strong>，指出运算的功能</li>
<li><strong>实现</strong>：针对<strong>存储结构</strong>，指出运算的具体操作步骤。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="算法的定义、特性"><a href="#算法的定义、特性" class="headerlink" title="算法的定义、特性"></a>算法的定义、特性</h2><ol>
<li>算法的定义<ul>
<li>算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每条指令表示一个或多个操作。</li>
</ul>
</li>
<li>算法的特性<ol>
<li><strong>有穷性</strong></li>
<li><strong>确定性</strong></li>
<li><strong>可行性</strong></li>
<li><strong>输入</strong></li>
<li><strong>输出</strong></li>
</ol>
</li>
</ol>
<h2 id="简单的算法分析：时间复杂度、空间复杂度"><a href="#简单的算法分析：时间复杂度、空间复杂度" class="headerlink" title="简单的算法分析：时间复杂度、空间复杂度"></a>简单的算法分析：时间复杂度、空间复杂度</h2><ol>
<li>时间复杂度分析技巧<ul>
<li>非递归：分析循环次数和问题规模 n 的关系，根据循环条件列出两者的不等式，取解中增长最快的一项作为时间复杂度。</li>
<li>递归：根据代码中的递推公式，求出通项公式，取增长最快的一项作为时间复杂度。</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>算法<strong>原地工作</strong>是指所需的辅助空间为<strong>常量</strong>（而非不需要），即 O(1) 。</li>
</ul>
</li>
</ol>
<h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2. 线性表"></a>2. 线性表</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.1</span></span><br><span class="line"><span class="comment">// 将所有在线性表 Lb 中但不在 La 中的数据元素插入到 La 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 分别求线性表的长度</span></span><br><span class="line"><span class="comment">2. 遍历 Lb ，取出元素，在 La 中寻找匹配。如果没找到，先将La长度加一,然后插入到 La 末尾</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(List &amp;La, List Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    La_Len = ListLength(La);</span><br><span class="line">    Lb_Len = ListLength(Lb);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lb_Len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        GetElem(Lb, i, e);</span><br><span class="line">        <span class="keyword">if</span>(! LocateElem(La, e equal) )</span><br><span class="line">            ListInsert(La,++La_Len, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.2</span></span><br><span class="line"><span class="comment">// 已知线性表 La 和 Lb 中的数据元素按值非递减排列</span></span><br><span class="line"><span class="comment">// 归并 La 和 Lb 得到新的线性表 Lc ，Lc 的数据元素也按值非递减排列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 初始化 Lc</span></span><br><span class="line"><span class="comment">2. 获取 La 和 Lb 的长度</span></span><br><span class="line"><span class="comment">3. 设置循环变量 i（La）、j（Lb）、k（Lc）</span></span><br><span class="line"><span class="comment">4. 循环（while）比较 La 和 Lb 数据元素的大小，选择小的插入Lc，循环变量对应增加</span></span><br><span class="line"><span class="comment">5. 遍历 La 的剩余元素，插入到 Lc 中</span></span><br><span class="line"><span class="comment">6. 遍历 Lb 的剩余元素，插入到 Lc 中</span></span><br><span class="line"><span class="comment">P.S. 5、6 只可能执行其中一个。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(List La, List Lb, List &amp; Lc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitList(Lc);</span><br><span class="line">    La_Len = ListLength(La);</span><br><span class="line">    Lb_Len = ListLength(Lb);</span><br><span class="line">    </span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= La_Len &amp;&amp; j &lt;= Lb_Len)</span><br><span class="line">    &#123;</span><br><span class="line">        GetElem(La, i, a);</span><br><span class="line">        GetElem(Lb, j, b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a &lt; b)</span><br><span class="line">        &#123;</span><br><span class="line">            ListInsert(Lc, ++k, a);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListInsert(Lc, ++k, b);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= La_Len)</span><br><span class="line">    &#123;</span><br><span class="line">        GetElem(La, i, a);</span><br><span class="line">        ListInsert(Lc, ++k, a);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= Lb_Len)</span><br><span class="line">    &#123;</span><br><span class="line">        GetElem(Lb, i, b);</span><br><span class="line">        ListInsert(Lc, ++k, b);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="顺序表和链表的存储与基本操作；"><a href="#顺序表和链表的存储与基本操作；" class="headerlink" title="顺序表和链表的存储与基本操作；"></a>顺序表和链表的存储与基本操作；</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线性表的 动态分配 存储结构定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType * elem;</span><br><span class="line">    <span class="keyword">int</span> length;     <span class="comment">// 若没有，则为静态</span></span><br><span class="line">    <span class="keyword">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.3</span></span><br><span class="line"><span class="comment">// 构造一个空的线性表 L</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 申请初始大小的空间</span></span><br><span class="line"><span class="comment">2. 判断是否申请成功。如果不成功，报错退出；否则，length和listsize分别赋予合理的初值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.elem = (ElemType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * LIST_INIT_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(! L.elem )</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    </span><br><span class="line">    L.listsize = LIST_INIT_SIZE;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.4</span></span><br><span class="line"><span class="comment">// 在顺序表线性表 L 中第 i 个 位置之前插入新的元素 e</span></span><br><span class="line"><span class="comment">// i 的合法值为 1 &lt;= i &lt;= ListLength(L) + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. i 的非法性检查</span></span><br><span class="line"><span class="comment">2. 存储空间已满检查</span></span><br><span class="line"><span class="comment">3. 循环移动元素，在目标位置插入元素</span></span><br><span class="line"><span class="comment">4. 表长加一</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp; L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="comment">// i 的非法检查</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(L.length + <span class="number">1</span> &gt; L.listsize)<span class="comment">// 存储空间已满检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        newbase = (ElemType *)<span class="built_in">realloc</span>(L.elem, <span class="keyword">sizeof</span>(ElemType) * (L.listsize + LIST_INCREMENT));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(! newbase )</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        </span><br><span class="line">        L.elem = newbase;</span><br><span class="line">        L.listsize = L.listsize + LIST_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    q = L.elem + i - <span class="number">1</span>;<span class="comment">// 第i个位置前插入</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(p = L.elem + L.length - <span class="number">1</span>; p &gt;= q; p--)</span><br><span class="line">        *(p+<span class="number">1</span>) = *p;</span><br><span class="line">    </span><br><span class="line">    *q = e;</span><br><span class="line">    ++ L.length;<span class="comment">//勿忘！</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.5</span></span><br><span class="line"><span class="comment">// 在顺序线性表 L 中删除第 i 个元素，并用 e 返回其值</span></span><br><span class="line"><span class="comment">// i 的合法值为 1 &lt;= i &lt;= ListLength(L)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. i 的合法性检查</span></span><br><span class="line"><span class="comment">2. 取出第 i 个位置的元素</span></span><br><span class="line"><span class="comment">3. 移动元素</span></span><br><span class="line"><span class="comment">4. 表长减一</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp; L, <span class="keyword">int</span> i, ElemType &amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    q = L.elem + i - <span class="number">1</span>;</span><br><span class="line">    e = *q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(p = q; p &lt; p + L.length - <span class="number">1</span>; p++)</span><br><span class="line">        *p = *(p+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    L.length--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.6</span></span><br><span class="line"><span class="comment">// 在顺序线性表 L 中查找第 1 个值与 e 满足 compare() 的元素的位序</span></span><br><span class="line"><span class="comment">// 若找到，则返回其在 L 中的位序，否则返回 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">遍历L 比较每个元素与e的大小关系，如果满足，则记录下位置，终止循环，返回答案。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_Sq</span><span class="params">(SqList L, ElemType e, Status(* compare)(ElemType, ElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    place = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(compare(e,L.elem[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            place = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> place;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.7</span></span><br><span class="line"><span class="comment">// 已知顺序线性表 La 和 Lb 的元素按值非递减排列</span></span><br><span class="line"><span class="comment">// 归并 La 和 Lb 得到新的顺序线性表 Lc ，Lc的元素也按值非递减排列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 初始化 Lc， 包括申请空间，初始化 listsize 和 length 的值</span></span><br><span class="line"><span class="comment">2. 设置循环变量（指针） pa，pb，pc</span></span><br><span class="line"><span class="comment">3. while 循环比较，插入 Lc</span></span><br><span class="line"><span class="comment">4. 将 La 或者 Lb 的剩余部分插入 Lc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList La, SqList Lb, SqList &amp; Lc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Lc.length = La.length + Lb.length;</span><br><span class="line">    Lc.listsize = Lc.length;</span><br><span class="line">    Lc.elem = (ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * Lc.listsize);</span><br><span class="line">    <span class="keyword">if</span>(! Lc.elem )</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    </span><br><span class="line">    pa = La.elem;</span><br><span class="line">    pb = Lb.elem;</span><br><span class="line">    pc = Lc.elem;</span><br><span class="line">    pa_last = La.elem + La.length - <span class="number">1</span>;</span><br><span class="line">    pb_last = Lb.elem + Lb.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pa &lt; *pb)</span><br><span class="line">            *pc++ = *pa++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *pc++ = *pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pa &lt;= pa_last)</span><br><span class="line">        *pc++ = *pa++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pb &lt;= pb_last)</span><br><span class="line">        *pc++ = *pb++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线性表的单链表存储结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.8</span></span><br><span class="line"><span class="comment">// L 为带头节点的单链表的头指针。</span></span><br><span class="line"><span class="comment">// 当第 i 个元素存在时，其值赋给 e 并返回 OK， 否则返回 ERROR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 设置用于记录循环状态的变量 j 和 指针 p</span></span><br><span class="line"><span class="comment">2. 循环，找第 i 个元素的位置</span></span><br><span class="line"><span class="comment">3. 出错检查 </span></span><br><span class="line"><span class="comment">4. 取出值，返回成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i)<span class="comment">//注意错误条件</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(i &lt;= 0)</span></span><br><span class="line"><span class="comment">        return ERROR;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    p = L;</span></span><br><span class="line"><span class="comment">    count = 0;</span></span><br><span class="line"><span class="comment">    while(p-&gt;next != NuLL)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(count == i)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            e = p-&gt;data;</span></span><br><span class="line"><span class="comment">            return OK;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        count++;</span></span><br><span class="line"><span class="comment">        p = p-&gt;next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    return ERROR;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.9</span></span><br><span class="line"><span class="comment">// 在头节点的单链线性表 L 中第 i 个位置之前插入元素 e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 设置 j（循环变量）、p（指针）</span></span><br><span class="line"><span class="comment">2. 循环，找第 i-1 个元素的位置</span></span><br><span class="line"><span class="comment">3. 出错检查 </span></span><br><span class="line"><span class="comment">4. 插入操作，返回成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp; L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i - <span class="number">1</span>)<span class="comment">//注意错误条件</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.10</span></span><br><span class="line"><span class="comment">// 在带头结点的单链线性表 L 中， 删除第 i 个元素，并由 e 返回其值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 设置 j（循环变量）、p（指针）</span></span><br><span class="line"><span class="comment">2. 循环，找第 i-1 个元素的位置</span></span><br><span class="line"><span class="comment">3. 出错检查 </span></span><br><span class="line"><span class="comment">4. 删除操作，返回成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp; L, <span class="keyword">int</span> i, ElemType &amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++j;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!p &amp;&amp; j &gt; i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    s = p-&gt;next;</span><br><span class="line">    e = s-&gt;data;</span><br><span class="line">    p-&gt;next = s-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.11</span></span><br><span class="line"><span class="comment">// 逆位序输入 n 个元素的值，建立带表头结点的单链线性表 L</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 申请头节点 L，并初始化 L-&gt;next 为 NULL</span></span><br><span class="line"><span class="comment">2. 循环：申请新节点，赋值，插入到 L 的头部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_L</span><span class="params">(LinkeList &amp; L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        <span class="built_in">scanf</span>(&amp; s-&gt;data);</span><br><span class="line">        </span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.12</span></span><br><span class="line"><span class="comment">// 已知单链线性表 La 和 Lb 的元素按值非递减排列</span></span><br><span class="line"><span class="comment">// 归并 La 和 Lb 得到新的单链线性表 Lc ，Lc 的元素也按值非递减排列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">（类似 算法 2.7）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkeList &amp; La, LinkList &amp; Lb, LinkList &amp; Lc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa = La-&gt;next;</span><br><span class="line">    pb = Lb-&gt;next;</span><br><span class="line">    Lc = pc = La;<span class="comment">// 用 La 做 Lc 的头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt; pb-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不需要申请额外空间</span></span><br><span class="line">            pc-&gt;next = pa;<span class="comment">// 之间将结点连接到 Lc 对应的位置</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//改变位置指针</span></span><br><span class="line">            pc = pa</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pb;</span><br><span class="line">            </span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pa)</span><br><span class="line">        pc-&gt;next = pa;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pc-&gt;next = pb;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(Lb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线性表的静态单链表存储结构</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">    </span><br><span class="line">&#125;component, SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.13</span></span><br><span class="line"><span class="comment">// 在静态单链线性表 L 中查找到第 1 个值为 e 的元素</span></span><br><span class="line"><span class="comment">// 若找到，则返回它在 L 中的位序，否则返回 0 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. i 初始化为 S[0].cur // 第 1 个 元素的位置</span></span><br><span class="line"><span class="comment">2. 循环比较，若 i 不为 0 并且 i 位置的元素不等于 e，那么 i 指向下一个元素位置（ 即 i = S[i].cur ）；否则跳出循环。</span></span><br><span class="line"><span class="comment">3. 返回结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_SL</span><span class="params">(SLinkList S, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = S[<span class="number">0</span>].cur;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &amp;&amp; S[i].data != e)<span class="comment">// 注意：当 i 为 0 时，为链表末尾</span></span><br><span class="line">        i = S[i].cur;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.14</span></span><br><span class="line"><span class="comment">// 将一维数组 space 中各分量链成一个备用链表，space[0].cur为头指针</span></span><br><span class="line"><span class="comment">// “0” 表示空指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSpace_SL</span><span class="params">(SLinkList &amp;space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; ++i)</span><br><span class="line">        space[i].cur = i + <span class="number">1</span>; <span class="comment">// 初始化时，默认指向存储空间上的下一个位置</span></span><br><span class="line">    </span><br><span class="line">    space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>; <span class="comment">// 最后一个元素指向空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.15</span></span><br><span class="line"><span class="comment">// 若备用空间链表为非空，则返回分配的结点下标，否则返回 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SL</span><span class="params">(SLinkList &amp; space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = space[<span class="number">0</span>].cur; <span class="comment">// 取备用链表的第一个元素的下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(space[<span class="number">0</span>].cur) <span class="comment">// 备用链表非空</span></span><br><span class="line">        space[<span class="number">0</span>].cur = space[i].cur;<span class="comment">// 删除第一个节点，并使头指针指向下一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.16</span></span><br><span class="line"><span class="comment">// 将下标为 k 的空闲结点回收到备用链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SL</span><span class="params">(SLinkList &amp;space, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    space[k].cur = space[<span class="number">0</span>].cur; <span class="comment">// k 结点的 下一个位置指向 0 结点指向的下一个位置</span></span><br><span class="line">    </span><br><span class="line">    space[<span class="number">0</span>].cur = k; <span class="comment">// 0 结点的下一个位置指向 k</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.17</span></span><br><span class="line"><span class="comment">// 依此输入集合 A 和集合 B 的元素， 在一维数组 space 中建立表示集合 </span></span><br><span class="line"><span class="comment">// (A-B)∪(B-A) 的静态链表， S 为其头指针。假设备用空间足够大，</span></span><br><span class="line"><span class="comment">// space[0].cur 为其头指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difference</span><span class="params">(SLinkList &amp;space, <span class="keyword">int</span> &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitSpace_SL(space);         <span class="comment">// 初始化备用空间</span></span><br><span class="line">    S = Malloc_SL(space);        <span class="comment">// 生成 S 的头节点</span></span><br><span class="line">    r = S;                       <span class="comment">// r 指向 S 的当前最后节点</span></span><br><span class="line">    <span class="built_in">scanf</span>(m, n);                 <span class="comment">// 输入 A 和 B 的元素个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= m; ++j)      <span class="comment">// 建立集合 A 的链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        i = Malloc_SL(space);    <span class="comment">// 分配节点</span></span><br><span class="line">        <span class="built_in">scanf</span>(space[i].data);    <span class="comment">// 输入 A 的元素值</span></span><br><span class="line">        space[r].cur = i; r = i; <span class="comment">// 插入到表尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    space[r].cur = <span class="number">0</span>;            <span class="comment">// 尾节点的指针为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)      <span class="comment">// 依次输入 B 的元素，若不在</span></span><br><span class="line">    &#123;                            <span class="comment">// 当前表中，则插入，否则删除</span></span><br><span class="line">        <span class="built_in">scanf</span>(b); p = S; k = space[S].cur; <span class="comment">// k 指向集合 A 中的第一个结点</span></span><br><span class="line">        <span class="keyword">while</span>(k != space[r].cur &amp;&amp; space[k].data != b)</span><br><span class="line">        &#123;<span class="comment">// 在当前表中查找</span></span><br><span class="line">            p = k; <span class="comment">// p 指向当前 </span></span><br><span class="line">            k = space[k].cur; <span class="comment">// k 指向下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k == space[r].cur)    <span class="comment">// 当前表中不存在该元素，</span></span><br><span class="line">        &#123;                        <span class="comment">// 插入在 r 所指结点之后，</span></span><br><span class="line">                                 <span class="comment">// 且 r 的位置不变</span></span><br><span class="line">            i = Malloc_SL(space);</span><br><span class="line">            space[i].data = b;</span><br><span class="line">            space[i].cur = space[r].cur;</span><br><span class="line">            space[r].cur = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                     <span class="comment">// 该元素已在表中， 删除之</span></span><br><span class="line">        &#123;</span><br><span class="line">            space[p].cur = space[k].cur;</span><br><span class="line">            Free_SL(space, k);</span><br><span class="line">            <span class="keyword">if</span>(r == k) r = p;    <span class="comment">// 若删除的是 r 所指结点，则需修改尾指针。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度 O(m × n)，第二个循环，外层最多 n 次，内层最多 m 次。</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="顺序表和链表的应用；"><a href="#顺序表和链表的应用；" class="headerlink" title="顺序表和链表的应用；"></a>顺序表和链表的应用；</h2><h3 id="一元多项式的表示及相加"><a href="#一元多项式的表示及相加" class="headerlink" title="一元多项式的表示及相加"></a>一元多项式的表示及相加</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 项的结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  <span class="comment">// 项的表示，多项式的项作为 LinkList 的数据元素</span></span><br><span class="line">    <span class="keyword">float</span> coef;  <span class="comment">// 系数 </span></span><br><span class="line">    <span class="keyword">float</span> expn;  <span class="comment">// 指数</span></span><br><span class="line">&#125;term, ElemType; <span class="comment">// term 用于本 ADT ，ElemType 为 LinkList 的数据对象名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> LinkList polynomial; <span class="comment">//用带表头结点的有序链表表示多项式</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.22</span></span><br><span class="line"><span class="comment">// 输入 m 项的系数和指数，建立表示一元多项式的有序链表 P</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 初始化线性表</span></span><br><span class="line"><span class="comment">2. 设置头节点数据</span></span><br><span class="line"><span class="comment">3. 读入数据， 判断插入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatPolyn</span><span class="params">(polynomail &amp;P, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitList(P);	h = GetHead(P);</span><br><span class="line">    <span class="comment">// 设置头节点的数据元素</span></span><br><span class="line">    e.coef = <span class="number">0.0</span>;	e.expn = <span class="number">-1</span>;	SetCurElem(h, e);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(e.coef, e.expn);</span><br><span class="line">        <span class="keyword">if</span>(! LocateElem(P, e, q, (*cmp)()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(MakeNode(s,e))</span><br><span class="line">                InsFirst(q, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.23</span></span><br><span class="line"><span class="comment">// 多项式加法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddPolyn</span><span class="params">(polynomial &amp;Pa. polynomial &amp;Pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ha = GetHead(Pa);	hb = GetHead(Pb);</span><br><span class="line">    qa = NextPos(Pa, ha);	qb = NextPos(Pb, hb);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(qa &amp;&amp; qb)</span><br><span class="line">    &#123;</span><br><span class="line">        a = GetCurElem(qa);	b = GetCurElem(qb);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 三种情况</span></span><br><span class="line">        <span class="comment">// 1. qa-&gt;elem &lt; qb-&gt;elem: 取 qa 结点插入到结果中</span></span><br><span class="line">        <span class="comment">// 2. qa-&gt;elem &gt; qb-&gt;elem: 取 qb 结点插入到结果中</span></span><br><span class="line">        <span class="comment">// 3. qa-&gt;elem = qb-&gt;elem: sum = qa-&gt;elem + b-&gt;elem</span></span><br><span class="line">        <span class="comment">// 若 sum == 0，则删除该节点；</span></span><br><span class="line">        <span class="comment">// 若 sum != 0，则更新结果中该位置的 elem 域的值。</span></span><br><span class="line">        <span class="keyword">switch</span>((*cmp(a, b)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                ha = qa;	qa = NextPos(Pa, qa);	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                sum = a.coef + b.coef;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(sum != <span class="number">0.0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    SetCurElem(qa, sum);</span><br><span class="line">                    ha = qa;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    DelFirst(ha, qa);</span><br><span class="line">                    FreeNode(qa);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                DelFirst(hb, qb);</span><br><span class="line">                FreeNode(qb);</span><br><span class="line">                qb = NextPos(Pb, hb);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                DelFirst(hb, qb);</span><br><span class="line">                InsFirst(ha, qb);</span><br><span class="line">                qb = NextPos(Pb, hb);</span><br><span class="line">                ha = NextPos(Pa, ha);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!ListEmpty(Pb))	Append(Pa, qb); <span class="comment">// A 遍历完了， </span></span><br><span class="line">                                            <span class="comment">// B 还有，应把剩</span></span><br><span class="line">                                            <span class="comment">// 下的元素一起加</span></span><br><span class="line">                                            <span class="comment">// 入结果中</span></span><br><span class="line">        FreeNode(hb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="循环链表；双向链表；"><a href="#循环链表；双向链表；" class="headerlink" title="循环链表；双向链表；"></a>循环链表；双向链表；</h2><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><ul>
<li>最后一个结点的指针域指向头节点。</li>
<li>遍历循环结束条件是<strong>p == 头指针</strong>或者<strong>p-&gt;next == 头指针</strong></li>
<li>基本操作与线性链表类似</li>
</ul>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线性表的双向链表存储结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode *DuLinkList;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.18</span></span><br><span class="line"><span class="comment">// 在带头结点的双链循环线性表 L 中第 i 个位置之前插入元素 e</span></span><br><span class="line"><span class="comment">// i 的合法值为 1 ≤ i ≤ 表长 + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 从头结点开始遍历，找到插入位置</span></span><br><span class="line"><span class="comment">（如果为空，则插入位置不合理，返回错误）</span></span><br><span class="line"><span class="comment">2. 申请新的结点空间（如果申请失败，返回错误）</span></span><br><span class="line"><span class="comment">3. 把新结点的 elem 域设置成指定值，插入到双链循环线性表中</span></span><br><span class="line"><span class="comment">（4处指针修改！！！）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(p = GetElemP_DuL(L, i)))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(!(s = (DuLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLNode))))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="comment">// 4 处指针修改</span></span><br><span class="line">    s-&gt;prior = p-&gt;prior;    <span class="comment">// s 的 prior</span></span><br><span class="line">    p-&gt;prior-&gt;next = s;     <span class="comment">// p 的 prior 的 next</span></span><br><span class="line">    s-&gt;next = p;            <span class="comment">// s 的 next</span></span><br><span class="line">    p-&gt;prior = s;           <span class="comment">// p 的 prior</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 2.19</span></span><br><span class="line"><span class="comment">// 删除带头结点的双链循环线性表 L 的 第 i 个元素</span></span><br><span class="line"><span class="comment">// i 的合法值为 1 ≤ i ≤ 表长</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法流程：</span></span><br><span class="line"><span class="comment">1. 从头结点开始遍历，找到删除位置</span></span><br><span class="line"><span class="comment">（如果为空，则插入位置不合理，返回错误）</span></span><br><span class="line"><span class="comment">2. 将删除结点的 elem 域的值赋给制定输出参数，再从链表中删除该结点</span></span><br><span class="line"><span class="comment">并释放相应存储空间。</span></span><br><span class="line"><span class="comment">（2 处指针修改）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListDelete_DuL</span><span class="params">(DuLinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(p = GetElemP_DuL(L, i)))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    </span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>数据结构（C语言版）.严蔚敏</li>
<li>2020年数据结构考研复习指导.王道论坛</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器真的有智能吗</title>
    <url>/2018/11/16/ji-qi-zhen-de-you-zhi-neng-ma/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/11/16/cover.jpg?raw=true" alt="cover"></p>
<p>最近几年，人工智能被炒得火热。机器打败人类围棋高手，玩部分电子游戏达到人类水平；机器同声传译、分类物体、识别人脸的准确率都达到十分高的水平；一些智能机器产品（智能音箱、智能服务机器人等），开始进入个人家庭或者企业。机器人的“入侵”，引起了很多普通人的恐慌：机器有了类似人类的智能，将来岂不是要代替人类？我想，这个恐慌的来源，便是人们对机器智能的未知的恐惧。那么，机器真的有智能吗？还是说这只是媒体大肆渲染的夸大之词？</p>
<p>要想正确回答这个问题，首先要从智能的定义入手，其次分析达到智能的手段，最后给出答案。本文便是照着这个逻辑和你分享一下我的认识。</p>
<h2 id="智能的定义"><a href="#智能的定义" class="headerlink" title="智能的定义"></a>智能的定义</h2><p>对于人工智能，其定义很多，没有统一的定义。Stuart J. Russell 和 Peter Norvig 将一些常见的定义分为以下四类[^1]</p>
<table>
<thead>
<tr>
<th align="center"><strong>Thinking Humanly</strong></th>
<th align="center"><strong>Thinking Rationally</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">“The exciting new effort to make computers think . . . <em>machines with minds</em>, in the full and literal sense.” (Haugeland, 1985)</td>
<td align="center">“The study of mental faculties through the use of computational models.” (Charniak and McDermott, 1985)</td>
</tr>
<tr>
<td align="center">“[The automation of] activities that we associate with human thinking, activities such as decision-making, problem solving, learning . . .” (Bellman, 1978)</td>
<td align="center">“The study of the computations that make it possible to perceive, reason, and act.” (Winston, 1992)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><strong>Acting Humanly</strong></th>
<th align="center"><strong>Acting Rationally</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">“The art of creating machines that perform functions that require intelligence when performed by people.” (Kurzweil, 1990)</td>
<td align="center">“Computational Intelligence is the study of the design of intelligent agents.” (Poole <em>et al.</em>, 1998)</td>
</tr>
<tr>
<td align="center">“The study of how to make computers do things at which, at the moment, people are better.” (Rich and Knight, 1991)</td>
<td align="center">“AI . . . is concerned with intelligent behavior in artifacts.” (Nilsson, 1998)</td>
</tr>
</tbody></table>
<p>表格上方更关注于机器的<strong>思考</strong>（可以认为是理解和推理，即知道某些知识信息的含义，并利用这些已知的信息能够得到未知的结论），与之相对，表格下方更注重于机器的<strong>行为</strong>（即机器如何执行动作，与外在环境进行交互）；表格左边的利用<strong>人类标准</strong>来评价，而右边的利用一种叫做<strong>“理性”</strong>（Rationality）的理想标准来评价。这里将人类标准和理性标准相对，并不意味着人类不理性，而是认为人的思考或者行为并不能每一次都能达到完美的结果；于此，提出理性标准来描述一种理想情况，在已知某些知识的情况下，做出正确的思考或者是行为。</p>
<p>综合以上的观点，可以给出对人工智能的较为全面的描述。<strong>人工智能是一个研究机器如何像人一样理性思考与行动的一个学科领域。</strong>研究这个领域的科学家渴望赋予机器像人一样的智能，那么他们怎么去做的呢？</p>
<h2 id="达到智能的手段"><a href="#达到智能的手段" class="headerlink" title="达到智能的手段"></a>达到智能的手段</h2><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>最简单的，可以利用<strong>搜索</strong>的方式来达到智能。比如，实现一个简单的问答机器人，可以事先给机器人准备一个包含大量问题以及对应回答的语料库。当用户询问机器人问题时，机器人简单的从语料库中搜索与用户问题一致的问题，将对应的回答反馈给用户。</p>
<h3 id="知识表示与推理"><a href="#知识表示与推理" class="headerlink" title="知识表示与推理"></a>知识表示与推理</h3><p>上一种搜索的方式是基于人为赋予的语料库，存在一定的局限性。该局限性在于机器只知道人告诉它的，如果超出语料库的范围，它将无法回答或者给出违反常理的回答。那么怎么解决这个问题呢？</p>
<p>一方面，我们可以不断地给机器人为增加语料库的内容以适应更多的提问；另一方面，我们也希望机器能够从已知去探索未知。语料库终究是有限的，而且越来越庞大的语料库会给导致搜索算法效率的降低，因而第二种可能是一种较好的方案。这种方案通常叫做<strong>知识表示与推理</strong>。</p>
<p>在知识表示与推理中，最关键的两个问题是<strong>如何将表述这些知识</strong>、<strong>如何建立规则做推理</strong>。科学家们反思自己的思考流程，发现<strong>命题逻辑</strong>是一个非常适合知识表达和推理的工具。其中，<strong>命题可以无歧义的表示某一个知识，逻辑推演中的各种规则可以拿来做推理</strong>。基于逻辑的知识表示与推理在一段时间内十分流行，并催生出一系列的专家系统。</p>
<p>经过一段时间，人们发现并不是所有的知识都能够用命题来表示。命题要求每一个知识都是<strong>确定</strong>的，是真就是真，是假就是假，但是日常生活中我们会遇到很多<strong>不确定</strong>的知识。怎样去表达这些不确定的信息呢？提到不确定，我想你一定会想到概率。对了！<strong>利用概率模型去表达知识，利用统计规律做推理</strong>。</p>
<h3 id="感知、规划与执行"><a href="#感知、规划与执行" class="headerlink" title="感知、规划与执行"></a>感知、规划与执行</h3><p>上面两个方法，都是有关<strong>如何赋予机器思考的能力</strong>。此外，也有一些科学家关注于<strong>如何构建一个和外在环境交互的机器</strong>。</p>
<p>他们给机器装上了各种传感器，试图模拟人类对外界的各种<strong>感知</strong>；他们通过一些物理知识，以传感器收集到的可测量的数据为基础，计算出一些必要的但是无法直接测量的数据，并且以这些数据作为后续动作<strong>规划</strong>的参考，试图模拟人类对原始感知的处理与动作决策；他们给机器装上各种控制机械装置，试图模拟人类在外界环境中<strong>执行</strong>动作。</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>随着互联网覆盖率越来越大，每天产生的数据也越来越多。这些数据中，有很多数据不像传感器数据有着十分明确的用途，也无法利用已知的知识去描述数据中的规律。</p>
<p>反思过去，在传统的软件系统中，计算机或其他设备借助于人对于问题的处理逻辑展现出某种“智能”。这是一种“人为赋予的智能”，处理过程十分清晰明确。然而，这种方法并不能产生真正的智能，而只是将人类自身知识、智慧等以一种系统化的模式组织起来，从而为特定的问题提供自动化的解决方案。</p>
<p>展望未来，有没有一种可能教会机器自己从数据中寻找规律的能力？</p>
<p><strong>机器学习</strong>就是一种可行的方法。</p>
<p>机器学习（ <em>Machine Learning</em> ）为我们提供了一个全新的思路，展现出一种创造 <em>Strong AI</em> 甚至 <em>Super AI</em> 的可能性。机器学习，正如 <em>Arthur Samuel</em> 所描述，是<strong>“一门研究‘给予计算机自我学习的能力，而不需明确程序控制’的学科”</strong>[^2]。从传统的“授计算机以鱼”到机器学习中的“授计算机以渔”，这种从“被动”接受人类智慧，到“主动”学习解决问题，是一种伟大的转变。</p>
<p>有关“什么是机器学习”，还有另一个观点。<em>Tom Mitchell</em> 给学习问题下了一个形式化的定义。一个优雅的学习问题应该由三元组 <em>(  E, T, P )</em> 所确定。其中 <em>E</em> 代表<strong>经验 （ <em>Experience</em> ）</strong>， <em>T</em> 代表<strong>任务 （ <em>Task</em> ）</strong>， <em>P</em> 代表<strong>性能量度 （ <em>Performance measure</em> ）</strong>。机器学习就是去学习获得经验 <em>E</em> ，依据经验 <em>E</em> 去处理任务 <em>T</em> ，依据性能量度 <em>P</em> 改善经验E，从而最终获得比较优秀的处理结果。[^3]</p>
<p>那么究竟怎么赋予机器学习发现规律的能力呢？第一点，定义一个针对某一任务的通用模型，作为机器经验的载体；第二点，定义性能度量指标，用于评价某一经验下模型的表现；第三点，定义如何得到最优模型的学习算法（通常是不断迭代）。有了<strong>模型</strong>、<strong>度量指标</strong>和<strong>学习算法</strong>这三点，再喂给它足够多的针对某一特定任务的<strong>数据</strong>，它就可以从数据中发现潜在的规律，并且在未知数据集上同样可以获得很好的表现。</p>
<h2 id="不必过度恐慌"><a href="#不必过度恐慌" class="headerlink" title="不必过度恐慌"></a>不必过度恐慌</h2><p>经过上面的介绍，我想你对人工智能应该有了一定的认识。人工智能，不过是一个渴望模拟人思考和行动的数学模型或者是系统。到目前为止，像科幻片里一样拥有自主思考能力的机器并不存在。因此，大家不必过度恐慌。</p>
<p>不过，机器人的“入侵”确实应该给我们敲响一个警钟。你对于你目前的职业是否不可替代？你有没有制定你的 <em>Plan B</em> 来躲过 <em>Plan A</em> 失败？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天，我和你分享了我对人工智能的认识，并由此得出对待机器人的“入侵”<strong>不必过度恐慌</strong>。最后，我将本文的要点总结如下：</p>
<ol>
<li><strong>人工智能是一个研究机器如何像人一样理性思考与行动的一个学科领域。</strong></li>
<li><strong>达到智能的手段有搜索，知识表示与推理，感知、规划与执行，机器学习等</strong></li>
<li><strong>面对机器人“入侵”不必过度恐慌，但要给自己敲响警钟，找个时间反思自己</strong></li>
</ol>
<hr>
<p>最后，说句题外话。预计之后的几篇文章，我会关注机器学习中<strong>统计学习</strong>的部分，并以<strong>李航博士</strong>的著作——<strong>《统计学习方法》</strong>来分享有关知识。如果你有兴趣，请持续关注。</p>
<p>[^1]: Stuart J. Russell and Peter Norvig. Artificial Intelligence——A Modern Approach [M] . 3rd ed. Prentice Hall, 2010. p2 Figure 1.1<br>[^2]: Machine Learning: Field of study that gives computers the ability to learn without being explicitly programmed.——Arthur Samuel (1959).<br>[^3]: Well-posed Learning Problem: A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.   ——Tom Mitchell (1998)</p>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>内容平台的个性化推荐是怎么做的</title>
    <url>/2018/11/03/nei-rong-ping-tai-de-ge-xing-hua-tui-jian-shi-zen-me-zuo-de/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/11/03/cover.jpg?raw=true" alt="cover"></p>
<p>每天，互联网上都会产生大量的内容信息，如何做好这些信息内容的分类、整理与分发是每一个内容平台需要不断思考的问题。内容平台除了鼓励内容创作者产出更优质的内容，更需要通过某种方式持续不断地抓住内容消费者的注意力，从而让内容创作者、内容消费者和平台形成一个有机的生态结构。那么，该怎样持续不断地吸引内容消费者的眼球呢？这几年来各种内容平台最佳内容分发实践，便是做好用户的个性化推荐。</p>
<p>那么，这些个性化推荐到底是怎么做的呢？我们先来看一个具体的交互实例。</p>
<h2 id="一个交互实例"><a href="#一个交互实例" class="headerlink" title="一个交互实例"></a>一个交互实例</h2><p>如果你在一个相关内容平台刚刚注册为新用户后，平台可能会让你选择一些感兴趣的领域，并自动为你关注相关领域的优质创作者。这些内容成为平台对你个性的第一次试探。</p>
<p>在此之后，平台会继续基于你的浏览、点赞及评论等记录，逐渐修正对你个性的认识。随着你与平台互动的次数越来越多，平台就可以做到非常精准的推荐，并且这些内容持续不断，让你“刷得停不下来”。</p>
<p>源源不断的内容资讯流，加上个性化推荐，极大地提高了用户对各个内容平台的粘性，并间接地为内容平台创造了商业价值。那么，这里的个性化推荐到底该怎么做，才能达到这种效果呢？</p>
<p>我觉得，一个较好的个性推荐系统要做好以下两点：</p>
<ol>
<li>内容创作者、内容、内容消费者三者的<strong>特征提取</strong>。</li>
<li>基于上述特征的<strong>相似推荐</strong>。</li>
</ol>
<h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><p>特征提取，简单来说，就是从某一事物中找到一组能够较为完整的描述其特征的属性组。这些特征，简单一点，可以由你与平台之间的互动数据来量化。这些数据包括但不限于你对某一方面的内容的浏览量、点赞次数、评论次数。</p>
<p>此外，还需要给这些属性组贴上符合其特质的标签。除了平台手动或者自动地给其中的内容和用户贴上标签，平台也鼓励用户自己给自己贴上标签。上面的例子中，平台在让你选择感兴趣的方面时，其实就是初步地给你打上略带个性但又普适的标签。</p>
<h2 id="相似推荐"><a href="#相似推荐" class="headerlink" title="相似推荐"></a>相似推荐</h2><p>那么，有了这些属性组和其对应的标签后，怎么去利用它们呢？可以定义属性组之间的相似度，给一组新的完全未知的属性组贴上可能的标签，再依据标签做推荐。</p>
<p>那么，依据打上的标签，如何做推荐呢？</p>
<p>如果一个<strong>内容</strong>和某一<strong>内容消费者</strong>的标签相似度十分高，那么就可以把该内容推荐给他；如果一个<strong>内容创作者</strong>和<strong>内容消费者</strong>的标签相似度十分高，那么就可以把这个内容创作者推荐给该内容消费者关注；如果一个<strong>内容消费者</strong>（假设为 <em>小明</em> ）和另一个<strong>内容消费者</strong>（假设为 <em>小刚</em> ）的标签相似度十分高，那么 <em>小明</em> 点赞过、喜欢过的内容、内容创作者可以推荐给 <em>小刚</em> ，同样的，基于 <em>小刚</em> 和平台、内容、内容作者的互动数据也可以给 <em>小明</em> 做推荐。</p>
<p>上面提到，对于特征提取，我们可以利用一些较为简单的方法得到大量的属性组和对应的标签数据。这块内容我暂时不做过深的讨论。</p>
<p>而相似推荐则需要一些算法支撑。仔细思考相似推荐这个流程，其实这个过程就是基于属性组之间的相似度，将一些事物分到不同的类别当中，再根据类别做推荐。这里的<strong>分类</strong>，是<strong>机器学习</strong>中一个典型的任务。分类任务中有很多算法，其中一种较为简单的算法便是下面要介绍的 <strong>K 近邻算法</strong> 。</p>
<h2 id="K近邻（K-nearest-neighbors，KNN）算法"><a href="#K近邻（K-nearest-neighbors，KNN）算法" class="headerlink" title="K近邻（K-nearest neighbors，KNN）算法"></a>K近邻（<em>K-nearest neighbors</em>，<em>KNN</em>）算法</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>K 近邻的算法思想很简单。对于一个含有若干属性组的未知的事物，通过计算它和其他所有已贴上标签的属性组之间的相似度，然后找到相似度最大的 <em>k</em> 个，从中找到次数出现最多的标签，作为未知的事物的类别。</p>
<p>对应的，K 近邻的算法伪码描述如下<a href="https://www.researchgate.net/figure/260397165_Pseudocode-for-KNN-classification" target="_blank" rel="noopener">^1</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;P.S.我修改了其中一部分</span><br><span class="line"></span><br><span class="line">kNearest Neighbor</span><br><span class="line">Classify ( X, Y, x ) &#x2F;&#x2F; X: training data, Y: class labels of X, x unknown sample</span><br><span class="line"></span><br><span class="line">    for 𝑖 &#x3D; 1 to m do</span><br><span class="line">        Compute similarity s( Xi, x )</span><br><span class="line">    end for</span><br><span class="line"></span><br><span class="line">    Compute set I containing indices for the k largest similarities s( Xi, x ).</span><br><span class="line"></span><br><span class="line">    return majority label for &#123; Yi where i ∈ I &#125;</span><br></pre></td></tr></table></figure>




<h3 id="相似度定义"><a href="#相似度定义" class="headerlink" title="相似度定义"></a>相似度定义</h3><p>由上面的伪码描述可知，这个算法的关键便是对两个属性组之间的相似度的定义。</p>
<p>两个属性组可以被量化为两个向量。对于向量之间的相似度，可以用他们之间的距离来表示。</p>
<p>较为常见的计算向量之间的距离公式有以下两种：</p>
<ol>
<li>欧氏距离</li>
<li>余弦距离</li>
</ol>
<p>欧氏距离利用类似勾股定理公式计算两个向量之间的距离。例如，有两个向量$\vec{a}=(x_1,x_2,\cdots,x_n) ,\vec{b}=(y_1,y_2,\cdots,y_n)$，他们之间的欧氏距离定义为</p>
<p>$$<br>distance_{Euclidean} = \sqrt{\overset{n}{\underset{i=1}{\sum}}{(x_{i} - y_{i})^{2}}}<br>$$</p>
<p>两个向量之间的欧氏距离越大，两个向量之间的相似度越低；反之越高。</p>
<p>余弦距离就是计算两个向量之间夹角的余弦值，套用上述用于计算欧氏距离的两个向量，可以定义他们之间的余弦距离如下：</p>
<p>$$<br>distance_{Cosine} = \frac{\overset{n}{\underset{i=1}{\sum}}x_{i}y_{i}}{\sqrt{\overset{n}{\underset{i=1}{\sum}}{x_{i}^{2}}}\cdot\sqrt{\overset{n}{\underset{i=1}{\sum}}{y_{i}^{2}}}}<br>$$<br>我们知道，当余弦值等于 1 时，两个向量之间的夹角为 0 °，这表示它们之间的相似度最高；当余弦值等于 0 时，两个向量之间的夹角为 90 °，这表示它们之间没什么相关性；如果余弦值等于 -1 ，此时两个向量的方向完全相反，这表示他们的相似度最低。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>基于上面的伪码和相似度定义公式，可以很容易给出如下的 <em>Python</em> 实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance_euclidean</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算两个向量之间的欧氏距离</span></span><br><span class="line"><span class="string">    :param a: 向量1</span></span><br><span class="line"><span class="string">    :param b: 向量2</span></span><br><span class="line"><span class="string">    :return:  两个向量之间的欧氏距离</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">assert</span> len(a) == len(b)</span><br><span class="line">    <span class="keyword">return</span> math.sqrt(sum([math.pow((x - y), <span class="number">2</span>) <span class="keyword">for</span> [x, y] <span class="keyword">in</span> list(zip(a, b))]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance_cosine</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算两个向量之间的余弦距离</span></span><br><span class="line"><span class="string">    :param a: 向量1</span></span><br><span class="line"><span class="string">    :param b: 向量2</span></span><br><span class="line"><span class="string">    :return: 两个向量之间的余弦距离</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">assert</span> len(a) == len(a)</span><br><span class="line">    <span class="keyword">return</span> (sum([x * y <span class="keyword">for</span> [x, y] <span class="keyword">in</span> list(zip(a, b))])) / (</span><br><span class="line">        (math.sqrt(sum([x * x <span class="keyword">for</span> x <span class="keyword">in</span> a]))) * (math.sqrt(sum([y * y <span class="keyword">for</span> y <span class="keyword">in</span> b]))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knn_classifier</span><span class="params">(X, Y, x, k, distance)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    利用K近邻算法给未知类别的属性组x分类</span></span><br><span class="line"><span class="string">    :param X: 已知类别属性组</span></span><br><span class="line"><span class="string">    :param Y: X所对应的标签</span></span><br><span class="line"><span class="string">    :param x: 未知类别属性组</span></span><br><span class="line"><span class="string">    :param k: 超参数k</span></span><br><span class="line"><span class="string">    :param distance: 距离定义函数</span></span><br><span class="line"><span class="string">    :return: x 可能所处的类别</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    s = &#123;&#125;   <span class="comment"># 存储相似度（或者距离）</span></span><br><span class="line">    m = len(X)  <span class="comment"># 已知数据组数</span></span><br><span class="line">    reverse = <span class="literal">False</span> <span class="comment"># 存储决定距离集合是升序还是降序。默认为False（升序）</span></span><br><span class="line">    <span class="keyword">if</span> distance <span class="keyword">is</span> distance_cosine: <span class="comment"># 如果距离计算函数是余弦距离，那么要降序排列，置 reverse 为 True</span></span><br><span class="line">        reverse = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 计算距离</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        s[i] = distance(X[i], x)</span><br><span class="line">    <span class="comment"># 排序（升序还是降序由距离函数所决定）</span></span><br><span class="line">    res_lst = sorted(s.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=reverse)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在 k 个相似度最大的邻居中给各个标签出现的次数计数</span></span><br><span class="line">    k_neighbors = &#123;&#125;</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, _ <span class="keyword">in</span> res_lst:</span><br><span class="line">        <span class="keyword">if</span> Y[i] <span class="keyword">in</span> k_neighbors.keys():</span><br><span class="line">            k_neighbors[Y[i]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k_neighbors[Y[i]] = <span class="number">1</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count == k:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 给上述计数的标签排序（降序）</span></span><br><span class="line">    label_count_lst = sorted(k_neighbors.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> label_count_lst[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    group = [[<span class="number">0.1</span>, <span class="number">0</span>], [<span class="number">1.0</span>, <span class="number">1.1</span>], [<span class="number">1.0</span>, <span class="number">1.0</span>], [<span class="number">1.1</span>, <span class="number">1.9</span>], [<span class="number">0.3</span>, <span class="number">0.1</span>]]</span><br><span class="line">    labels = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>]</span><br><span class="line">    unknown = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    print(knn_classifier(group, labels, unknown, <span class="number">5</span>, distance_euclidean))</span><br><span class="line">    <span class="comment"># print(knn_classifier(group,labels,x,5,distance_cosine))</span></span><br></pre></td></tr></table></figure>




<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我和你一起了解到个性化推荐的一般套路，并由此引出<strong>机器学习</strong>中的<strong>分类</strong>任务里一个非常简单的算法——<strong>K近邻算法</strong>。最后，我将本文的要点总结如下：</p>
<ol>
<li><strong>一个较好的个性推荐系统应该处理好两个关键问题：一是特征提取、二是相似推荐</strong></li>
<li><strong>做特征提取，一方面深入挖掘用户的行为数据，获取用户特征；另一方面鼓励用户给自己贴上标签，获取与特征对应的标签信息。这样就获得大量的（特征属性组，标签）数据积累，为下一步更精准的推荐打下基础</strong></li>
<li><strong>在积累了大量的用户行为数据后和一些符合用户个性的标签后，可以利用K近邻算法给新的用户分类别，做类别的相似推荐</strong></li>
</ol>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>电子词典中查词的模糊推荐是怎么做的</title>
    <url>/2018/10/28/dian-zi-ci-dian-zhong-cha-ci-de-mo-hu-tui-jian-shi-zen-me-zuo-de/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/10/28/cover.jpg?raw=true" alt="cover"></p>
<p>大家在学习英语的时候经常会用到电子词典，当你在查询一个英语单词的时候，搜索框下方通常会依据你的输入给出词条的模糊推荐。即使你不小心输错了，电子词典也会给你一个看似模糊实则精准的推荐。这个功能大大提升了用户了单词查阅的效率，带给用户非常好的体验。那么，问题来了，这种模糊推荐到底是怎么做的呢？今天，我们就来一起探讨一下其中的算法。</p>
<h2 id="单词相似度"><a href="#单词相似度" class="headerlink" title="单词相似度"></a>单词相似度</h2><p>做模糊推荐，一种很直观的想法就是找到它们之间的相似度，如果相似度高，就将它可以排在模糊推荐集合中较前的位置。</p>
<p>那么，怎样去定义单词之间的相似度呢？根据单词相似度定义的方式不同，主要分为以下两种算法：</p>
<ol>
<li>最长公共子串（<em>Longest common substring</em>）</li>
<li>最长公共子列（<em>Longest common subsequence</em>）</li>
</ol>
<h2 id="最长公共子串（Longest-common-substring）"><a href="#最长公共子串（Longest-common-substring）" class="headerlink" title="最长公共子串（Longest common substring）"></a>最长公共子串（<em>Longest common substring</em>）</h2><h3 id="单词相似度的定义"><a href="#单词相似度的定义" class="headerlink" title="单词相似度的定义"></a>单词相似度的定义</h3><p>正如名称所述，该算法将单词的相似度定义为两个单词中共同含有的最长子串（这个子串在原字符串中是<strong>连续</strong>的）的长度大小。</p>
<h3 id="算法简述"><a href="#算法简述" class="headerlink" title="算法简述"></a>算法简述</h3><p>为了找到两个单词（一个设为 <em>S</em> ，另一个设为 <em>T</em> ）之间的最长公共子串，我们可以这样处理。</p>
<p>首先定义一个二维表 <em>L</em> （大小为 <em>r</em> × <em>n</em>，其中 <em>r</em> 为 <em>S</em> 的长度， <em>n</em> 为 <em>T</em> 的长度），用于存储算法处理的中间结果。</p>
<p>然后，循环比较每一组从两个单词中取出的字母。比较结果无非两种情况，一种不同，一种相同。不同的情况下，给二维表 L 对应的位置赋值为 0 ，表示在该位置最长公共子串的长度为0；相同的情况下，找到当前位置的前一个位置上存储的长度，将它加一，保存在当前位置即可。可以用公式描述如下：</p>
<p>$$<br>L(i, j) =<br>\left {<br>\begin{aligned}<br> &amp;  L(i-1, j-1)+1, &amp; if\ S[i] = T[j]\<br> &amp; 0,                     &amp; otherwise\<br>\end{aligned}<br>\right.<br>$$</p>
<p>那么，寻找最长子串的长度就可以定义为</p>
<p>$$<br>\underset{ i\in [ 0, r ), j\in [ 0, n ) }{ max } L( i, j )<br>$$</p>
<p>因而，为了求出两个字符串的最长公共子串，维基百科给出了如下的伪码描述<a href="https://en.wikipedia.org/wiki/Longest_common_substring_problem#Pseudocode" target="_blank" rel="noopener">^1</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function LCSubstr(S[1..r], T[1..n])</span><br><span class="line">    L :&#x3D; array(1..r, 1..n)</span><br><span class="line">    z :&#x3D; 0</span><br><span class="line">    ret :&#x3D; &#123;&#125;</span><br><span class="line">    for i :&#x3D; 1..r</span><br><span class="line">        for j :&#x3D; 1..n</span><br><span class="line">            if S[i] &#x3D;&#x3D; T[j]</span><br><span class="line">                if i &#x3D;&#x3D; 1 or j &#x3D;&#x3D; 1</span><br><span class="line">                    L[i,j] :&#x3D; 1</span><br><span class="line">                else</span><br><span class="line">                    L[i,j] :&#x3D; L[i-1,j-1] + 1</span><br><span class="line">                if L[i,j] &gt; z</span><br><span class="line">                    z :&#x3D; L[i,j]</span><br><span class="line">                    ret :&#x3D; &#123;S[i-z+1..i]&#125;</span><br><span class="line">                else</span><br><span class="line">                if L[i,j] &#x3D;&#x3D; z</span><br><span class="line">                    ret :&#x3D; ret ∪ &#123;S[i-z+1..i]&#125;</span><br><span class="line">            else</span><br><span class="line">                L[i,j] :&#x3D; 0</span><br><span class="line">    return ret</span><br></pre></td></tr></table></figure>



<p>为了方便阐释，我们可以举一个例子帮助理解。假设要找到 <em>process</em> 和 <em>progress</em> 两个单词的最长公共子串。那么二维表 L 的最终状态如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>p</strong></th>
<th align="center"><strong>r</strong></th>
<th align="center"><strong>o</strong></th>
<th align="center"><strong>c</strong></th>
<th align="center"><strong>e</strong></th>
<th align="center"><strong>s</strong></th>
<th align="center"><strong>s</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>p</strong></td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>r</strong></td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>o</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>g</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>r</strong></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>e</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>s</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><strong>s</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>由上图可知， <em>process</em> 和 <em>progress</em> 两个单词的最长公共子串为 <em>pro</em> 和 <em>ess</em> ，最长长度为 3 。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LCSubstr</span><span class="params">(S, T)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    寻找两个字符串S、T的最长相同子串</span></span><br><span class="line"><span class="string">    :param S: ( str ) 字符串1</span></span><br><span class="line"><span class="string">    :param T: ( str ) 字符串2</span></span><br><span class="line"><span class="string">    :return: ( list ) 符合条件的子串集合</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    r = len(S)</span><br><span class="line">    n = len(T)</span><br><span class="line">    L = np.zeros((r + <span class="number">1</span>, n + <span class="number">1</span>))  <span class="comment"># 初始化大小为 ( r + 1 ) × ( n + 1 ) 并且值全为 0 的数组。将 r 和 n 都加 1 是为了方便后续的计算</span></span><br><span class="line">    z = <span class="number">0</span>  <span class="comment"># 保存当前找到的最长相同子串的长度</span></span><br><span class="line">    ret = []  <span class="comment"># 保存符合条件的子串集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, r + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> S[i - <span class="number">1</span>] == T[j - <span class="number">1</span>]:  <span class="comment"># 如果字母相同，那么L[i][j] = L[i - 1][j - 1] + 1</span></span><br><span class="line">                L[i][j] = L[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> L[i][j] &gt; z:  <span class="comment"># 如果找到更大的，更新 z 和 ret 集合</span></span><br><span class="line">                    z = int(L[i][j])</span><br><span class="line">                    ret.clear()</span><br><span class="line">                    ret.append(S[i - z:i])</span><br><span class="line">                <span class="keyword">elif</span> L[i][j] == z:  <span class="comment"># 如果找到与当前最长的长度一样，将该子串加入 ret 集合</span></span><br><span class="line">                    ret.append(S[i - z:i])</span><br><span class="line">    <span class="keyword">return</span> ret  <span class="comment"># 返回结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(LCSubstr(<span class="string">"progress"</span>, <span class="string">"process"</span>))</span><br><span class="line">    print(LCSubstr(<span class="string">"BABA"</span>, <span class="string">"ABAB"</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">['pro', 'ess']</span></span><br><span class="line"><span class="string">['BAB', 'ABA']</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<h2 id="最长公共子列（Longest-common-subsequence）"><a href="#最长公共子列（Longest-common-subsequence）" class="headerlink" title="最长公共子列（Longest common subsequence）"></a>最长公共子列（<em>Longest common subsequence</em>）</h2><h3 id="单词相似度的定义-1"><a href="#单词相似度的定义-1" class="headerlink" title="单词相似度的定义"></a>单词相似度的定义</h3><p>上面的子串要求其在原字符串中是连续的，那不连续的又会怎样？这就诞生了 <strong>最长公共子列</strong> 。最长公共子列将单词相似度定义为两个单词的最长公共子列（这个子列不要求在原字符串中是连续的，但要求<strong>保持原序</strong>）的长度大小。</p>
<h3 id="算法简述-1"><a href="#算法简述-1" class="headerlink" title="算法简述"></a>算法简述</h3><p>受求最长公共子串的启发，对于两个单词 <em>X</em> 和 <em>Y</em>，同样的，我们可以定义一个二维表 <em>C</em> ，用于存储算法处理的中间结果。</p>
<p>那么对应的循环过程中，怎样去改变 <em>C</em> ，从而满足题目的需要呢？</p>
<p>在字母相同的情况下，我们依旧可以用和求最长公共子串相同的方法，即当前位置的前一个位置的存储的长度加一；而字母不同的情况下，连续子串到此结束，因而不能简单的使用上一个位置存储的长度。那么决定当前位置的值，还剩下以下两种情况。</p>
<ol>
<li>（ <em>X</em> 当前位置， <em>Y</em> 上一个位置）</li>
<li>（ <em>X</em> 上一个位置，<em>Y</em> 当前位置）</li>
</ol>
<p>而当前位置的最长公共子列长度由于当前位置上的两个字母不同，所以该位置不会对上一个位置上的数据产生影响。因而，当前位置上的最长公共子列长度只需取上述两种情况的最大值即可。具体可以用公式描述如下：</p>
<p>$$<br>C(i, j) =<br>\left {<br>\begin{aligned}<br> &amp;  C(i-1, j-1)+1, &amp; if\ X[i] = Y[j]\<br> &amp; max(C(i, j-1), C(i-1, j)),                     &amp; otherwise\<br>\end{aligned}<br>\right.<br>$$</p>
<p>而其中的最大长度，会在二维表 <em>C</em> 的末尾出现（如果两个单词的长度分别为 <em>m</em> 和 <em>n</em> , 那么 C[m][n] 即为最长公共子列）</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>对于求最长公共子列的长度，维基百科中给出如下的伪码描述<a href="https://en.wikipedia.org/wiki/Longest_common_subsequence_problem#Computing_the_length_of_the_LCS" target="_blank" rel="noopener">^2</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function LCSLength(X[1..m], Y[1..n])</span><br><span class="line">    C &#x3D; array(0..m, 0..n)</span><br><span class="line">    for i :&#x3D; 0..m</span><br><span class="line">       C[i,0] &#x3D; 0</span><br><span class="line">    for j :&#x3D; 0..n</span><br><span class="line">       C[0,j] &#x3D; 0</span><br><span class="line">    for i :&#x3D; 1..m</span><br><span class="line">        for j :&#x3D; 1..n</span><br><span class="line">            if X[i] &#x3D; Y[j]</span><br><span class="line">                C[i,j] :&#x3D; C[i-1,j-1] + 1</span><br><span class="line">            else</span><br><span class="line">                C[i,j] :&#x3D; max(C[i,j-1], C[i-1,j])</span><br><span class="line">    return C[m,n]</span><br></pre></td></tr></table></figure>



<p>基于此，我给出 <em>Python</em> 实现如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LCSLength</span><span class="params">(X, Y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算两个字符串最长公共子列的长度</span></span><br><span class="line"><span class="string">    :param X: （str）字符串1</span></span><br><span class="line"><span class="string">    :param Y: （str）字符串2</span></span><br><span class="line"><span class="string">    :return: （int）两个字符串最长公共子列的长度</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m = len(X)</span><br><span class="line">    n = len(Y)</span><br><span class="line">    C = np.zeros((m+<span class="number">1</span>, n+<span class="number">1</span>), np.int)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> X[i<span class="number">-1</span>] == Y[j<span class="number">-1</span>]:</span><br><span class="line">                C[i, j] = C[i<span class="number">-1</span>, j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                C[i, j] = max(C[i, j<span class="number">-1</span>], C[i<span class="number">-1</span>, j])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C[m, n]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(LCSLength(<span class="string">"progress"</span>, <span class="string">"process"</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">P.S.也就是proess的长度</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<h2 id="动态规划（Dynamic-programming）"><a href="#动态规划（Dynamic-programming）" class="headerlink" title="动态规划（Dynamic programming）"></a>动态规划（<em>Dynamic programming</em>）</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>仔细观察上面两种算法，其共同之处都是将原问题分解为较小的子问题，并将子问题的解进行保存，依据子问题由递推公式得到原问题的解，这种方法通常叫做 <strong>”动态规划“</strong> 。</p>
<p>那么，什么样的问题适合用动态规划来解决呢？</p>
<p>有人在博客中给出了如下的解释<a href="http://hxrs.iteye.com/blog/1055478" target="_blank" rel="noopener">^3</a></p>
<blockquote>
<p>适合采用动态规划方法的最优化问题中的两个要素：最优子结构和重叠子问题。 </p>
<p>最优子结构：如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子结构。</p>
<p>重叠子问题：适用于动态规划求解的最优化问题必须具有的第二个要素是子问题的空间要很小，也就是用来求解原问题的递归算法课反复地解同样的子问题，而不是总在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。</p>
</blockquote>
<p>说到这里，你应该会想到之前的文章中提到的贪心算法和分治算法，它们的思想和动态规划很类似，那么他们之间的区别又在那里呢？</p>
<h3 id="动态规划-VS-贪心算法-VS-分治算法-VS-遍历搜索"><a href="#动态规划-VS-贪心算法-VS-分治算法-VS-遍历搜索" class="headerlink" title="动态规划 VS 贪心算法 VS 分治算法 VS 遍历搜索"></a>动态规划 VS 贪心算法 VS 分治算法 VS 遍历搜索</h3><p>在维基百科中，有人对比了贪心算法，动态规划和遍历搜索。其原文如下<a href="https://en.wikipedia.org/wiki/Optimal_substructure" target="_blank" rel="noopener">^4</a>：</p>
<blockquote>
<p>Typically, a greedy algorithm is used to solve a problem with optimal substructure if it can be proven by induction that this is optimal at each step. Otherwise, provided the problem exhibits overlapping subproblems as well, dynamic programming is used. If there are no appropriate greedy algorithms and the problem fails to exhibit overlapping subproblems, often a lengthy but straightforward search of the solution space is the best alternative.</p>
</blockquote>
<p>也就是说，如果一个问题具有最优子结构并且可以证明其每一步选择都是最优的，那么选用贪心算法。如果该问题除了含有最优子结构，其子问题又是相互重叠的，那么选用动态规划。如果这两种方法都不成功，那么就进行简单的暴力搜索，遍历所有情况。</p>
<p>那么分治呢？分治也是将问题分解为子问题，但是这些子问题是互相独立的，同时它们之间的计算结果不共享。如果将分治法用于子问题相互重叠的问题，那么分治法会做很多重复的计算。这时候，动态规划的优势就显现出来，因为它将子问题的解存储起来，避免了重复计算。</p>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>现在，让我们回到最初的问题。电子词典中查词的模糊推荐以单词之间的相似度为标准，还有其他的方法吗？</p>
<p>当然有。比如基于用户的历史查询记录，分析查词词频，依据词频来做推荐。限于篇幅，这里不做讨论，有兴趣请自行查阅资料。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天，我和你一起了解到两种计算不同字符串相似度的算法，一个是 <strong>最长公共子串</strong> ，另一个是 <strong>最长公共子列</strong> ，并由此引出 <strong>动态规划</strong> 这种算法思想。最后我将本文要点总结如下：</p>
<ol>
<li><strong>最长公共子串要求子串在原字符串中是连续的</strong></li>
<li><strong>最长公共子列不要求子列在原字符串中是连续的，但要求保持原序</strong></li>
<li><strong>求最长公共子串和最长公共子列的时间复杂度为 $O(M\cdot N)$ ，其中 <em>M</em> 和 <em>N</em> 为两个字符串的长度。（这个我在原文中没有写，很容易分析得到）</strong></li>
<li>*<em>适合采用动态规划方法的最优化问题中的两个要素：最优子结构和重叠子问题。 *</em></li>
<li><strong>如果一个问题具有最优子结构并且可以证明其每一步选择都是最优的，那么选用贪心算法。如果该问题除了含有最优子结构，其子问题又是相互重叠的，那么选用动态规划。如果这两种方法都不成功，那么就进行简单的暴力搜索，遍历所有情况。</strong></li>
<li><strong>动态规划利用存储子问题的解，避免了子问题中的重复计算，有时候会比分治算法快很多。</strong></li>
</ol>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样求解难解决问题?</title>
    <url>/2018/10/14/zen-yang-qiu-jie-nan-jie-jue-wen-ti/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/10/14/cover.jpg?raw=true" alt="cover"></p>
<p>在之前的文章中，我们遇到的问题，其对应的算法都在我们所能容忍的时间给出结果（这些问题被称作<strong>“可解决问题”</strong>）。但是，对于有些问题，通过传统的解决办法，我们甚至在有生之年也得不到结果（这些问题被称作<strong>“难解决问题”</strong>）。在这些问题中，一个比较著名的便是今天我们要一起探讨的旅行商问题（<em>Travelling salesman problem</em> ，简写为 <em>TSP</em> ）。</p>
<h2 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h2><p>维基百科中，给出了旅行商问题的描述。具体如下：</p>
<blockquote>
<p>The <strong>travelling salesman problem</strong> (<strong>TSP</strong>) asks the following question: “Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city and returns to the origin city?” <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" target="_blank" rel="noopener">^1</a></p>
</blockquote>
<p>也就是说，如果已知一个城市列表以及每一对城市之间的距离，如何找到一条回路，这条回路到达过列表中的每一个城市并且总路径长度最短？</p>
<p>碰到这个问题，我想你脑中瞬间蹦出的解决方案就是穷举。下面，我们简单看看针对这个问题的穷举解法。</p>
<h2 id="传统解法——穷举"><a href="#传统解法——穷举" class="headerlink" title="传统解法——穷举"></a>传统解法——穷举</h2><h3 id="算法简述"><a href="#算法简述" class="headerlink" title="算法简述"></a>算法简述</h3><p>这个算法的总体的思路就是，枚举城市列表中的每一个排列，计算其路径长度，和当前找到的最短路径进行比较。如果新找到的排列方案的路径更短，那么更新最短路径和方案。当城市列表中所有的排列都枚举完成后，返回最短的排列方案和最短路径即可。</p>
<p>利用伪码描述，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function TSP_Exhaustion(city_list)</span><br><span class="line">    shortest_path &#x3D; NULL               &#x2F;&#x2F; 记录回路方案，初始为NULL  </span><br><span class="line">    shortest_dist &#x3D; ∞                  &#x2F;&#x2F; 记录回路方案中最短路径长度,初始化为无穷大</span><br><span class="line">    </span><br><span class="line">    foreach permutation in city_list   &#x2F;&#x2F; permutation表示city_list中的一个排列</span><br><span class="line">        dist &#x3D; CalcDist(permutation)   &#x2F;&#x2F; 计算当前排列方案下的路径长度</span><br><span class="line">        if dist &lt; shortest_path        &#x2F;&#x2F; 如果找到更小的，更新方案和最短路径</span><br><span class="line">            shortest_dist &#x3D; dist</span><br><span class="line">            shortest_path &#x3D; permutation</span><br><span class="line">    </span><br><span class="line">    return shortest_path, shortest_dist&#x2F;&#x2F;返回结果</span><br></pre></td></tr></table></figure>



<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>仔细观察上述的伪码描述，我们很容易知道，该算法最耗时间的部分便是枚举城市列表中的排列部分。对于一个容量大小为 <em>N</em> 的城市列表，它所有的排列为 <em>N!</em> 。所以，该算法的时间复杂度为 <em>O( N !)</em> 。</p>
<p>这样的时间复杂度是什么概念？如果计算机可以 1秒 处理一个上述的排列，那么针对不同的数据量 <em>N</em> ,</p>
<p> 有如下表格。</p>
<table>
<thead>
<tr>
<th align="center">数据量 <em>N</em></th>
<th align="center">计算量</th>
<th align="center">花费时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1！=   1</td>
<td align="center">1秒</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">10！=  3628800</td>
<td align="center">42天</td>
</tr>
<tr>
<td align="center">100</td>
<td align="center">100！=  9.33262×10^157</td>
<td align="center">2.95935×10^150年</td>
</tr>
</tbody></table>
<p>由此可见，随着数据量的增大，花费的时间以惊人的速度增长着。数据量为10时，这个解决问题的速度，我们已经无法容忍，更别提100了。</p>
<p>对于我们来说，时间是非常宝贵的资源。那么，如何在较少的时间内，获得这个问题的答案呢？</p>
<p>在这类问题中，前人经过不断尝试，放弃了能获得精确解但十分耗时的算法，转而投向更节省时间的近似算法。其中一种算法便是接下来要聊到的贪心算法。</p>
<h2 id="近似逼近——贪心算法"><a href="#近似逼近——贪心算法" class="headerlink" title="近似逼近——贪心算法"></a>近似逼近——贪心算法</h2><p>贪心算法是一种近似算法，算法的每一次迭代选取的都是当前局部最优的情况。它试图通过每一次的贪心选择，从局部最优解逐步逼近全局最优解。</p>
<p>贪心算法有两个关键部分：</p>
<ol>
<li>找到贪心选择的策略</li>
<li>依据第一步设定的贪心策略在一个有限集上不断迭代</li>
</ol>
<p>依据上两个关键部分，我们能够利用贪心算法解决一些 <strong>难解决问题</strong> 。</p>
<h3 id="算法简述-1"><a href="#算法简述-1" class="headerlink" title="算法简述"></a>算法简述</h3><p>对于旅行商问题，我们可以先随机选取一个城市作为起点，每次选取未被访问的并且路径最短的城市作为旅行商的下一站。以这个策略在城市列表中进行迭代，当所有城市都访问过后，就可以获得一个旅行商问题的看起来还不错的解。</p>
<p>其伪码描述如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function TSP_Greedy(city_list)</span><br><span class="line">    visited &#x3D; NULL                      &#x2F;&#x2F; 存放已经访问过的城市，初始化为NULL</span><br><span class="line">    dist &#x3D; 0                            &#x2F;&#x2F; 记录贪心算法找到的近似最短路径长度</span><br><span class="line">    </span><br><span class="line">    rand_i &#x3D; rand(city_list.length)     &#x2F;&#x2F; 随机选取一个城市列表长度范围内的下标</span><br><span class="line">    start_city &#x3D; city_list[rand_i]      &#x2F;&#x2F; 将其作为起点</span><br><span class="line">    visited.add(start_city)             &#x2F;&#x2F; 标记其已被访问过</span><br><span class="line">    city_current &#x3D; start_city           &#x2F;&#x2F; 当前旅行商所在的城市</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 寻找下一个没有访问过的并且从当前城市出发路径最短的下一个城市</span><br><span class="line">    city_next &#x3D; FindNextShortestCity(start_city, visited)</span><br><span class="line">    </span><br><span class="line">    while city_next !&#x3D; NULL             &#x2F;&#x2F; 所有的城市还未访问完</span><br><span class="line">        &#x2F;&#x2F; 计算路径长度</span><br><span class="line">        dist +&#x3D; CalcDistBetweenCities(city_current, city_next)</span><br><span class="line">        city_current &#x3D; city_next        &#x2F;&#x2F; 旅行商到达下一个城市</span><br><span class="line">        visited.add(city_current)       &#x2F;&#x2F; 标记已被访问过</span><br><span class="line">        &#x2F;&#x2F; 寻找下一个城市</span><br><span class="line">        city_next &#x3D; FindNextShortestCity(city_current, visited)</span><br><span class="line">    </span><br><span class="line">    return visited, dist                &#x2F;&#x2F; 返回结果</span><br></pre></td></tr></table></figure>



<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设数据量为 <em>N</em> ，<code>while</code> 循环大约消耗 <em>N</em> 步，函数 <code>find_next_shortest_city</code>  也会消耗 <em>N</em> 步，所以贪心算法在 <em>TSP</em> 问题中的时间复杂度为 $O(N^{2})$ 。</p>
<h2 id="TSP贪心算法实现"><a href="#TSP贪心算法实现" class="headerlink" title="TSP贪心算法实现"></a>TSP贪心算法实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 城市列表</span></span><br><span class="line">cities = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存任意两个城市的距离</span></span><br><span class="line">costs = &#123;&#125;</span><br><span class="line">costs[<span class="string">'A'</span>] = &#123;<span class="string">'B'</span>: <span class="number">1</span>, <span class="string">'C'</span>: <span class="number">2</span>, <span class="string">'D'</span>: <span class="number">3</span>, <span class="string">'E'</span>: <span class="number">4</span>&#125;</span><br><span class="line">costs[<span class="string">'B'</span>] = &#123;<span class="string">'A'</span>: <span class="number">1</span>, <span class="string">'C'</span>: <span class="number">2</span>, <span class="string">'D'</span>: <span class="number">3</span>, <span class="string">'E'</span>: <span class="number">4</span>&#125;</span><br><span class="line">costs[<span class="string">'C'</span>] = &#123;<span class="string">'A'</span>: <span class="number">1</span>, <span class="string">'B'</span>: <span class="number">2</span>, <span class="string">'D'</span>: <span class="number">3</span>, <span class="string">'E'</span>: <span class="number">4</span>&#125;</span><br><span class="line">costs[<span class="string">'D'</span>] = &#123;<span class="string">'A'</span>: <span class="number">1</span>, <span class="string">'B'</span>: <span class="number">2</span>, <span class="string">'C'</span>: <span class="number">3</span>, <span class="string">'E'</span>: <span class="number">4</span>&#125;</span><br><span class="line">costs[<span class="string">'E'</span>] = &#123;<span class="string">'A'</span>: <span class="number">1</span>, <span class="string">'B'</span>: <span class="number">2</span>, <span class="string">'C'</span>: <span class="number">3</span>, <span class="string">'D'</span>: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_next_shortest_city</span><span class="params">(src, searched)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    寻找下一个没有访问过的并且从当前城市出发路径最短的下一个城市</span></span><br><span class="line"><span class="string">    :param src: 当前的起点</span></span><br><span class="line"><span class="string">    :param searched: 已被访问过的城市集合</span></span><br><span class="line"><span class="string">    :return: 符合要求的下一个城市</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    shortest_city = <span class="literal">None</span></span><br><span class="line">    shortest_dist = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> city, dist <span class="keyword">in</span> costs[src].items():</span><br><span class="line">        <span class="keyword">if</span> dist &lt; shortest_dist <span class="keyword">and</span> city <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line">            shortest_city = city</span><br><span class="line">            shortest_dist = dist</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shortest_city</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tsp_greedy</span><span class="params">(city_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    利用贪心算法近似解决TSP问题</span></span><br><span class="line"><span class="string">    :param city_list: 城市列表</span></span><br><span class="line"><span class="string">    :return: 访问回路方案（列表），最小代价（整数）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    visited = []                            <span class="comment"># 存放已经访问过的城市，初始化为NULL</span></span><br><span class="line">    dist = <span class="number">0</span>                                <span class="comment"># 记录贪心算法找到的近似最短路径长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机选取一个城市列表长度范围内的下标</span></span><br><span class="line">    rand_i = random.randint(<span class="number">0</span>, len(city_list) - <span class="number">1</span>)</span><br><span class="line">    start_city = city_list[rand_i]          <span class="comment"># 将其作为起点</span></span><br><span class="line">    visited.append(start_city)              <span class="comment"># 标记其已被访问过</span></span><br><span class="line">    city_current = start_city               <span class="comment"># 当前旅行商所在的城市</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 寻找下一个没有访问过的并且从当前城市出发路径最短的下一个城市</span></span><br><span class="line">    city_next = find_next_shortest_city(start_city, visited)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> city_next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:            <span class="comment"># 所有的城市还未访问</span></span><br><span class="line">        <span class="comment"># 计算路径长度</span></span><br><span class="line">        dist += costs[city_current][city_next]</span><br><span class="line">        city_current = city_next            <span class="comment"># 旅行商到达下一个城市</span></span><br><span class="line">        visited.append(city_current)        <span class="comment"># 标记已被访问过</span></span><br><span class="line">        <span class="comment"># 寻找下一个城市</span></span><br><span class="line">        city_next = find_next_shortest_city(city_current, visited)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> visited, dist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    v, d = tsp_greedy(cities)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"回路路径方案："</span>)</span><br><span class="line">    print(<span class="string">"-&gt;"</span>.join(v))</span><br><span class="line">    print(<span class="string">"路径长度："</span>)</span><br><span class="line">    print(d)</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我和你一起了解到 <strong>旅行商问题</strong> 这类难解决问题，这类问题通常难以在可容忍的时间内获得其精确解。为了快速获得一个可能的解，可以利用近似算法逼近精确解。进一步，我们了解到<strong>贪心算法</strong>——一种近似算法，并实现了用于解决 <strong>TSP</strong> 的贪心算法。</p>
<p>最后，我将本文的要点总结如下：</p>
<ol>
<li><strong>旅行商问题这类难解决问题可以通过近似算法获得近似解</strong> </li>
<li><strong>近似算法中，有一种常见的算法便是贪心算法</strong></li>
<li><strong>贪心算法有两个关键部分：</strong><ol>
<li><strong>找到贪心选择的策略</strong></li>
<li><strong>依据第一步设定的贪心策略在一个有限集上不断迭代</strong></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>去目的地的最短路径怎么算（下）</title>
    <url>/2018/10/08/qu-mu-de-di-de-zui-duan-lu-jing-zen-me-suan-xia/</url>
    <content><![CDATA[<h2 id="Dijkstra-算法的局限性"><a href="#Dijkstra-算法的局限性" class="headerlink" title="Dijkstra 算法的局限性"></a><em>Dijkstra</em> 算法的局限性</h2><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/10/08/cover.jpg?raw=true" alt="cover"></p>
<p>上一篇文章中，我给你留下一个思考题：</p>
<blockquote>
<p><em>Dijkstra</em> 算法可以处理所有情况下的最短路径问题吗？</p>
</blockquote>
<p>你的答案是什么呢？如果是不是，那么恭喜你，你答对了。</p>
<p>那么在什么情况下， <em>Dijkstra</em> 算法不再适用呢？我们一起来看一个具体的例子。 </p>
<p>假设有6个人，分别是 <em>A</em> 、<em>B</em> 、<em>C</em> 、<em>D</em> 、<em>E</em> 、<em>F</em> 。他们每个人都有一个十分珍爱的东西，除非用他们自己所认为的等价的东西交换，否则一般情况下，他们是不卖这些东西的。</p>
<p>有一天，<em>A</em> 突然想要用自己所珍爱的东西换取 <em>F</em> 的东西。于是， <em>A</em> 边和 <em>F</em> 商量，自己的东西是否能作为交换的等价物。可是，非常遗憾， <em>F</em> 看不上 <em>A</em> 的东西，并不同意。</p>
<p>故事到了这里，并没有结束。 <em>A</em> 非常执( nan )着( chan )， <em>F</em> 被他的精神打动了，做出一定的妥协。 <em>F</em> 说，如果你能用你的东西换到 <em>C</em> 的东西，并且加上 1 块钱，我就和你换。</p>
<p><em>A</em> 非常激动，跑去找 <em>C</em> 。结果也是被拒。直接交换不成功，那么就间接交换吧， <em>A</em> 如是提议着。<em>C</em> 想了想，自己也有想要拥有其他人的一些东西，便提出了自己的要求：如果你能换到 <em>E</em> 的东西，我能返你 6 快钱；如果你能换到 <em>B</em> 的东西，那么还要在加上 1 块钱。</p>
<p><em>A</em> 又去找 <em>B</em> 、<em>E</em> 商量，他们也提出了自己的要求。</p>
<p>最终 <em>A</em> 把这些信息化成一张图，构成如下所示的交换贸易网：</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/10/08/graph.png?raw=true" alt="graph"></p>
<p>那么，现在问题来了， <em>A</em> 如何能画最少的钱，用自己的东西换到 <em>F</em> 的东西呢？</p>
<p>仔细分析题目中抽象出的交换网以及问题，这不就是在求有权图（或者是网）中，从某一点到另一点的最短路径方案嘛，直接用 <em>Dijkstra</em> 算法就能解决！</p>
<p>我们把这里的网输入交给 <em>Dijkstra</em> 算法计算一下，它的输出又是什么呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">最短路径：</span><br><span class="line">A-&gt;B-&gt;C-&gt;F</span><br><span class="line">路径长度：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>



<p>惊了！该算法怎么没走含有负数的路径，原本代价可以更小的！那这个算法究竟哪里存在不足呢？仔细分析一下， <em>Dijkstra</em> 算法在寻找最短路径时，是存在一些“短见”的。它考虑最短路径是依据起点到当前点的最短距离加上该点到其邻居节点的距离。依据这个和，找到和最小的邻居结点，并选择这个点作为下一个点。在这种情况下，它并不会考虑到下几个结点的和会出现更小的情况。以上面的例子来说，在到达B时，算法在选择 <em>C</em> 或者 <em>E</em> 作为下一个最短路径的结点时，更倾向于贪心地选择下一个结点代价更小的 <em>C</em> ，而不会选择下两个结点和会更小的 <em>E</em> 。</p>
<p>那为什么上次在计算最短路径时， <em>Dijkstra</em> 算法表现的十分出色呢？原来在所有边的权值都为正数时，是不会出现上述情况的。所以 <em>Dijkstra</em> 算法在边权值为负数的时候，可能会出现错误。</p>
<p>那么对于负数边的图，怎样计算其中的最短路径呢？这就要用到 <em>Floyd</em> 算法。</p>
<h2 id="Floyd-算法-1"><a href="#Floyd-算法-1" class="headerlink" title="Floyd 算法[^1]"></a><em>Floyd</em> 算法[^1]</h2><p>试想有一个图，它有 <em>N</em> 个顶点，编号从 1 到 N 。我们设 <em>shortestPath(i,  j, k)</em> 为一条最短路径，这条最短路径从 <em>i</em> 出发 到 <em>j</em> 为止，并且中间只经过 <em>{1, 2, ···, k}</em> 这些点。那么图上的最短路径问题即可描述为，对于每一个 <em>i</em> 、 <em>j</em> 对， 寻找它们之间的最短路径，其中间路径只通过  <em>{1, 2, ···, N}</em> ，也就是对每一组 <em>i</em>,  <em>j</em> ,求 <em>shortestPath(i,  j, N)</em>  。</p>
<p>对 <em>shortestPath(i,  j, k)</em> 这个式子的含义进一步分析，不难发现，它的结果不外乎两种情况：</p>
<ol>
<li>路径并不通过顶点 <em>k</em> （也就是可用顶点集合为 <em>{1, 2, ···, k-1}</em> ）</li>
<li>路径通过顶点 <em>k</em> （路径先从 <em>i</em> 开始，到 <em>k</em> 暂停；再从 <em>k</em> 开始，最终到达终点 <em>j</em> 。其中间只经过 <em>{1, 2, ···, k-1}</em> ）</li>
</ol>
<p>将上述两点，结合开头的定义将这个问题进一步化简，对于 <em>shortestPath(i,  j, k)</em> ，它可能的解可以用如下式子表示</p>
<ol>
<li><em>shortestPath(i,  j, k-1)</em> </li>
<li><em>shortestPath(i,  k, k-1)</em>  + <em>shortestPath(k,  j, k-1)</em> </li>
</ol>
<p>也就是 </p>
<p>$$<br>\begin{aligned}<br>shortestPath(i, j, k) = min(&amp;shortestPath(i,  j, k-1),\<br>&amp;shortestPath(i,  k, k-1)  + shortestPath(k,  j, k-1) )<br>\end{aligned}<br>$$<br>上述式子是一个递推公式，那么它一定有一个起始值。在这里，<em>k = 0</em> 条件下的值便是它的起始值。用公式便可表示如下：</p>
<p>$$<br>shortestPath(i, j, 0) = w(i, j)<br>$$</p>
<p>这种情况下，为 <em>i</em> 和 <em>j</em> 两点直接相连。其中， <em>w(i, j)</em> 为顶点为 <em>i</em> 、<em>j</em> 边上的权值。</p>
<p>将上述两个式子写到一起，便是</p>
<p>$$<br>shortestPath(i, j, k) =<br>\left {<br>\begin{aligned}<br> &amp;  w(i, j), &amp;k = 0\<br> &amp;  min<br>         \left (<br>         \begin{aligned}<br>         &amp;shortestPath(i,  j, k-1),\<br>         &amp;shortestPath(i,  k, k-1)  + shortestPath(k,  j, k-1)<br>         \end{aligned}<br>         \right ) , &amp;k &gt; 0\<br>\end{aligned}<br>\right.<br>$$</p>
<p>上式便是 <em>Floyd</em> 算法的核心公式。当算法运行时，对于每一组顶点 <em>i</em> 和顶点 <em>j</em> 的组合，计算每一个 <em>k</em> 取值情况下的 <em>shortestPath</em> 值。当用户查询时，只需从 <em>shortestPath</em> 中访问即可。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这个算法如何实现呢？</p>
<p>我们先来看下维基百科上的伪代码描述</p>
<p>source[^1]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let dist be a |V| × |V| array of minimum distances initialized to ∞ (infinity)</span><br><span class="line">for each edge (u,v)</span><br><span class="line">    dist[u][v] ← w(u,v)  &#x2F;&#x2F; the weight of the edge (u,v)</span><br><span class="line">for each vertex v</span><br><span class="line">    dist[v][v] ← 0</span><br><span class="line">for k from 1 to |V|</span><br><span class="line">    for i from 1 to |V|</span><br><span class="line">       for j from 1 to |V|</span><br><span class="line">          if dist[i][j] &gt; dist[i][k] + dist[k][j] </span><br><span class="line">             dist[i][j] ← dist[i][k] + dist[k][j]</span><br><span class="line">          end if</span><br></pre></td></tr></table></figure>



<p>以这个为基础，很容易将它转成 <em>Python</em> 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># 在你的终端命令行中输入 'pip install numpy' 命令安装numpy包。已经安装过的可以忽略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立图</span></span><br><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">'A'</span>] = &#123;<span class="string">'B'</span>: <span class="number">1</span>, <span class="string">'D'</span>: <span class="number">4</span>&#125;</span><br><span class="line">graph[<span class="string">'B'</span>] = &#123;<span class="string">'C'</span>: <span class="number">1</span>, <span class="string">'E'</span>: <span class="number">4</span>&#125;</span><br><span class="line">graph[<span class="string">'C'</span>] = &#123;<span class="string">'F'</span>: <span class="number">1</span>&#125;</span><br><span class="line">graph[<span class="string">'D'</span>] = &#123;<span class="string">'C'</span>: <span class="number">3</span>&#125;</span><br><span class="line">graph[<span class="string">'E'</span>] = &#123;<span class="string">'C'</span>: <span class="number">-6</span>&#125;</span><br><span class="line">graph[<span class="string">'F'</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义常量</span></span><br><span class="line">A, B, C, D, E, F = list(range(len(graph))) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符映射到对应的常量</span></span><br><span class="line">index = &#123;<span class="string">'A'</span> : A, <span class="string">'B'</span> : B, <span class="string">'C'</span> : C, <span class="string">'D'</span> : D, <span class="string">'E'</span> : E, <span class="string">'F'</span> : F&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floyd</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    利用 floyd 算法，计算图中任意两点间的最短路径长度，并以矩阵的形式打印出来</span></span><br><span class="line"><span class="string">    :return: 无</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    V = len(graph)</span><br><span class="line">    dist = np.array([[np.inf] * V] * V)   <span class="comment"># 保存最短路径距离</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> graph.keys():</span><br><span class="line">        dist[index[u]][index[u]] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> graph[u].keys():</span><br><span class="line">            dist[index[u]][index[v]] = graph[u][v]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(V):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(V):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(V):</span><br><span class="line">                <span class="keyword">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]:</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j]</span><br><span class="line"></span><br><span class="line">    print(dist)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    floyd()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">[[  0.   1.  -1.   4.   5.   0.]</span></span><br><span class="line"><span class="string"> [ inf   0.  -2.  inf   4.  -1.]</span></span><br><span class="line"><span class="string"> [ inf  inf   0.  inf  inf   1.]</span></span><br><span class="line"><span class="string"> [ inf  inf   3.   0.  inf   4.]</span></span><br><span class="line"><span class="string"> [ inf  inf  -6.  inf   0.  -5.]</span></span><br><span class="line"><span class="string"> [ inf  inf  inf  inf  inf   0.]]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p>上述实现仅仅给出了最短路径长度，有时候我们更需要的是最短路径的方案。怎么办呢？</p>
<p>维基百科中进一步给出了如下的伪代码描述：</p>
<p>source<a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm#Path_reconstruction" target="_blank" rel="noopener">^2</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let dist be a |V| × |V| array of minimum distances initialized to ∞</span><br><span class="line"> (infinity)</span><br><span class="line">let next be a |V| × |V| array of vertex indices initialized to null</span><br><span class="line"></span><br><span class="line">procedure FloydWarshallWithPathReconstruction ()</span><br><span class="line">   for each edge (u,v)</span><br><span class="line">      dist[u][v] ← w(u,v)  &#x2F;&#x2F; the weight of the edge (u,v)</span><br><span class="line">      next[u][v] ← v</span><br><span class="line">   for k from 1 to |V| &#x2F;&#x2F; standard Floyd-Warshall implementation</span><br><span class="line">      for i from 1 to |V|</span><br><span class="line">         for j from 1 to |V|</span><br><span class="line">            if dist[i][j] &gt; dist[i][k] + dist[k][j] then</span><br><span class="line">               dist[i][j] ← dist[i][k] + dist[k][j]</span><br><span class="line">               next[i][j] ← next[i][k]</span><br><span class="line"></span><br><span class="line">procedure Path(u, v)</span><br><span class="line">   if next[u][v] &#x3D; null then</span><br><span class="line">       return []</span><br><span class="line">   path &#x3D; [u]</span><br><span class="line">   while u ≠ v</span><br><span class="line">       u ← next[u][v]</span><br><span class="line">       path.append(u)</span><br><span class="line">   return path</span><br></pre></td></tr></table></figure>



<p>所以有 <em>Python</em> 代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># 在你的终端命令行中输入 'pip install numpy' 命令安装numpy包。已经安装过的可以忽略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立图</span></span><br><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">'A'</span>] = &#123;<span class="string">'B'</span>: <span class="number">1</span>, <span class="string">'D'</span>: <span class="number">4</span>&#125;</span><br><span class="line">graph[<span class="string">'B'</span>] = &#123;<span class="string">'C'</span>: <span class="number">1</span>, <span class="string">'E'</span>: <span class="number">4</span>&#125;</span><br><span class="line">graph[<span class="string">'C'</span>] = &#123;<span class="string">'F'</span>: <span class="number">1</span>&#125;</span><br><span class="line">graph[<span class="string">'D'</span>] = &#123;<span class="string">'C'</span>: <span class="number">3</span>&#125;</span><br><span class="line">graph[<span class="string">'E'</span>] = &#123;<span class="string">'C'</span>: <span class="number">-6</span>&#125;</span><br><span class="line">graph[<span class="string">'F'</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义常量</span></span><br><span class="line">A, B, C, D, E, F = list(range(len(graph))) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符映射到对应的常量</span></span><br><span class="line">index = &#123;<span class="string">'A'</span> : A, <span class="string">'B'</span> : B, <span class="string">'C'</span> : C, <span class="string">'D'</span> : D, <span class="string">'E'</span> : E, <span class="string">'F'</span> : F&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floyd_with_path_reconstruction</span><span class="params">(src, des)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    利用 floyd 算法，计算图中两点间的最短路径长度，和路径方案</span></span><br><span class="line"><span class="string">    :param src: 起点</span></span><br><span class="line"><span class="string">    :param des: 终点</span></span><br><span class="line"><span class="string">    :return: 路径方案（列表），最短路径长度（一个数）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    V = len(graph)</span><br><span class="line">    dist = np.array([[np.inf] * V] * V)  <span class="comment"># 保存最短路径距离</span></span><br><span class="line">    next_ = np.array([[<span class="literal">None</span>] * V] * V)  <span class="comment"># 保存当前路径上的下一个顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> graph.keys():</span><br><span class="line">        dist[index[u]][index[u]] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> graph[u].keys():</span><br><span class="line">            dist[index[u]][index[v]] = graph[u][v]</span><br><span class="line">            next_[index[u]][index[v]] = v</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(V):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(V):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(V):</span><br><span class="line">                <span class="keyword">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]:</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j]</span><br><span class="line">                    next_[i][j] = next_[i][k]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成路径方案</span></span><br><span class="line">    <span class="keyword">if</span> next_[index[src]][index[des]] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> [], np.inf</span><br><span class="line">    path = [src]</span><br><span class="line">    u = src</span><br><span class="line">    <span class="keyword">while</span> u != des:</span><br><span class="line">        u = next_[index[u]][index[des]]</span><br><span class="line">        path.append(u)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> path, dist[index[src]][index[des]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试例程</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    r, c = floyd_with_path_reconstruction(<span class="string">'A'</span>, <span class="string">'F'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"最短路径："</span>)</span><br><span class="line">    print(<span class="string">"-&gt;"</span>.join(r))</span><br><span class="line">    print(<span class="string">"路径长度："</span>)</span><br><span class="line">    print(c)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">最短路径：</span></span><br><span class="line"><span class="string">A-&gt;B-&gt;E-&gt;C-&gt;F</span></span><br><span class="line"><span class="string">路径长度：</span></span><br><span class="line"><span class="string">0.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p>上述的最终结果符合我们的预期。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>由于 <em>Floyd</em> 算法中存在一个非常消耗时间的三重循环，所以该算法的时间效率并不高，其时间复杂度为 $O(N^{3})$ 。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我从一个非常有意思的例子和你一起了解到 <em>Dijkstra</em> 算法的局限性，由此引出客服其局限性的 <em>Floyd</em> 算法，并且介绍了它的算法思想和算法实现。</p>
<p>最后，我将本文的要点总结如下：</p>
<ol>
<li><strong>在边权值全部为正数的图中求最短路径，适合使用 <em>Dijkstra</em> 算法；</strong></li>
<li><strong>在边权值存在负数的图中求最短路径，应该使用  <em>Floyd</em> 算法；</strong></li>
<li><strong><em>Floyd</em> 算法 的时间复杂度为 $O(N^{3})$ 。</strong></li>
<li><strong><em>Dijkstra</em> 算法的时间复杂度为 $O(N^{2})$ 。</strong>（这个小知识点，我上篇文章忘说了，你可以自己推导下）</li>
</ol>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>去目的地的最短路径怎么算（上）</title>
    <url>/2018/10/02/qu-mu-de-di-de-zui-duan-lu-jing-zen-me-suan-shang/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/10/02/cover.jpg?raw=true" alt="cover"></p>
<p>上两篇文章中，我们具体讨论了“去目的地的最少中转方案”这个问题，并给出算法过程以及它的实现。在实际生活中，我们对于出行方案的需求除了“最少中转”，还有“最短路径”。今天，我们一起来思考一下如何计算出去目的地的最短路径。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在地图中，从某一位置到达另一个位置通常有很多条路径。其中，总路径长度最短的，叫做“最短路径”。</p>
<p>“最短路径”是这个问题的输出，也是这个问题的目标。为了达到这个目标，第一步就需要我们搞清楚它的输入是什么（或者我们能提供什么样的原始信息【通常是可测量的】），在这个基础之上我们才能运用或者设计合适的算法，给出符合期望的结果。</p>
<p>在前两篇文章中，我们一起了解到，图这种数据结构，天生地可以表示多个点之间多对多的关系。因而，在这个问题中，我们通过图存储信息。与之前的图略有不同的是，这里的图还存储有两个相邻点之间路径的代价（在这个问题中，就是该道路的长度）。这样的图，在每一条边上都有对应的值（称作“权值”），也被称作为<strong>“网”</strong>。这个由各个道路长度、各个顶点和边构成的交通网以及用户给定的起点、终点信息，作为我们的输入。</p>
<p>那么，如何利用这个输入信息得到我们希望的结果呢？这里就要用到 <em>Dijkstra</em> 算法。</p>
<h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p><em>Dijkstra</em> 算法描述如下：</p>
<blockquote>
<ol>
<li>找到所花代价最小的顶点。这个顶点满足，从起点开始到达该顶点的路径长度最短。</li>
<li>更新第一步找到顶点的邻居顶点的代价（这个代价是指从起点到该顶点的距离加上该顶点到相应邻居顶点的距离）。</li>
<li>重复上述操作，直至每一个顶点都被处理过。</li>
<li>计算最终路径，给出指定要求的输出</li>
</ol>
</blockquote>
<p>上面的算法描述太过抽象，我们看一个例子来体会一下这个算法的过程。</p>
<p>假设，一个简单的交通网如下所示：</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/10/02/%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%A4%E9%80%9A%E7%BD%91%E7%A4%BA%E4%BE%8B.png?raw=true" alt="简单的交通网示例"></p>
<p>比如，用户想要从 <em>A</em> 到 <em>D</em> 的最短路径。 </p>
<p>在利用 <em>Dijkstra</em> 算法之前，首先要对相关数据初始化。初始时，我们有如下表格：</p>
<table>
<thead>
<tr>
<th align="center">顶点</th>
<th align="center">从起点到达该点的最短路径长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A（已处理）</td>
<td align="center">$\infty$</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">$\infty$</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">$\infty$</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">$\infty$</td>
</tr>
</tbody></table>
<p>第一步，找到符合要求的顶点 <em>C</em> 。</p>
<p>第二步，更新 <em>C</em> 邻居顶点的的代价（也就是B、E【A是起点，不参与更新】）。从而有以下表格：</p>
<table>
<thead>
<tr>
<th align="center">顶点</th>
<th align="center">从起点到达该点的最短路径长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A（已处理）</td>
<td align="center">$\infty$</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">$3 + 5 = 8$ （由于$3 + 5 = 8 &lt; \infty$ ，所以更新）</td>
</tr>
<tr>
<td align="center">C（已处理）</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">$\infty$</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">$3 + 5 = 8$（由于$3 + 5 = 8 &lt; \infty$ ，所以更新）</td>
</tr>
</tbody></table>
<p>重复第一步，找到符合要求的顶点 <em>B</em> 。</p>
<p>又是第二步，更新 <em>B</em> 邻居顶点的代价（也就是 <em>C</em> 和 <em>D</em> ）。从而有以下表格：</p>
<table>
<thead>
<tr>
<th align="center">顶点</th>
<th align="center">从起点到达该点的最短路径长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A（已处理）</td>
<td align="center">$\infty$</td>
</tr>
<tr>
<td align="center">B（已处理）</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">C（已处理）</td>
<td align="center">3（由于$8 + 5 &gt; 3$ ，所以不更新）</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">$8 + 2 = 10$（由于$8 + 2 = 10 &lt; \infty$ ，所以更新）</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">8</td>
</tr>
</tbody></table>
<p>重复第一步，找到符合要求的顶点 <em>E</em> 。</p>
<p>又是第二步，更新 <em>E</em> 邻居顶点的代价（也就是 <em>C</em> 和 <em>D</em> ）。从而有以下表格：</p>
<table>
<thead>
<tr>
<th align="center">顶点</th>
<th align="center">从起点到达该点的最短路径长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A（已处理）</td>
<td align="center">$\infty$</td>
</tr>
<tr>
<td align="center">B（已处理）</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">C（已处理）</td>
<td align="center">3（由于$8 + 5 &gt; 3$ ，所以不更新）</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">10（由于 $8 + 4 &gt; 10$ ，所以不更新）</td>
</tr>
<tr>
<td align="center">E（已处理）</td>
<td align="center">8</td>
</tr>
</tbody></table>
<p>最后一个满足要求的点为 <em>D</em> ，经过算法处理完的表格结果如下：</p>
<table>
<thead>
<tr>
<th align="center">顶点</th>
<th align="center">从起点到达该点的最短路径长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A（已处理）</td>
<td align="center">$\infty$</td>
</tr>
<tr>
<td align="center">B（已处理）</td>
<td align="center">8（由于 $10 + 2 &gt; 8$ ，所以不更新）</td>
</tr>
<tr>
<td align="center">C（已处理）</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">D（已处理）</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">E（已处理）</td>
<td align="center">8（由于$10 + 4 &gt; 8$ ，所以不更新）</td>
</tr>
</tbody></table>
<p>到此为止，我们可以在表给中找到，从 <em>A</em> 到 <em>D</em> 的最短路径长度为 10 。简单地检验一下，这个结果是正确的。除了给出最短路径长度，我们还需要给出路径方案。靠上述中的表格信息远远不够。</p>
<p>那么如何计算出最短路径方案呢？还记得上一篇文章中我们是如何给出最少中转方案的吗？通过引入名为 <code>parents</code> 的哈希表，将当前路径点和上一个顶点联系起来。 在算法处理过程中，更新这个哈希表。算法处理完后，从终点开始，一个个寻找它的上一个顶点，直至到达起点。最后将这些路径点按照从起点到终点的顺序排列，存储起来或者直接输出。</p>
<p>至此，想必大家对 <em>Dijkstra</em> 算法执行的过程有所了解，下面便是代码实现环节。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立图</span></span><br><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">'A'</span>] = &#123;<span class="string">'C'</span>: <span class="number">3</span>&#125;</span><br><span class="line">graph[<span class="string">'B'</span>] = &#123;<span class="string">'C'</span>: <span class="number">5</span>, <span class="string">'D'</span>: <span class="number">2</span>&#125;</span><br><span class="line">graph[<span class="string">'C'</span>] = &#123;<span class="string">'A'</span>: <span class="number">3</span>, <span class="string">'B'</span>: <span class="number">5</span>, <span class="string">'E'</span>: <span class="number">5</span>&#125;</span><br><span class="line">graph[<span class="string">'D'</span>] = &#123;<span class="string">'B'</span>: <span class="number">2</span>, <span class="string">'E'</span>: <span class="number">4</span>&#125;</span><br><span class="line">graph[<span class="string">'E'</span>] = &#123;<span class="string">'C'</span>: <span class="number">5</span>, <span class="string">'D'</span>: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建parents哈希表，将当前路径点和上一个顶点联系起来</span></span><br><span class="line">parents = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储图上的点是否被访问过。</span></span><br><span class="line"><span class="comment"># 如果某点在searched集合中，那么该点在之前已经被访问过；</span></span><br><span class="line"><span class="comment"># 否则，没有</span></span><br><span class="line">searched = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义常量：无穷大</span></span><br><span class="line">infinity = float(<span class="string">'inf'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建costs哈希表，记录每一个顶点和从起点到达该顶点的最短路径长度</span></span><br><span class="line">costs = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lowest_cost_node</span><span class="params">(m_costs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    在m_cost中寻找未被搜索过并且所花代价最小的结点</span></span><br><span class="line"><span class="string">    :param m_costs: 道路代价集合</span></span><br><span class="line"><span class="string">    :return: 符合要求的结点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    lowest_cost = float(<span class="string">'inf'</span>)</span><br><span class="line">    lowest_cost_node = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> m_costs:</span><br><span class="line">        cost = m_costs[node]</span><br><span class="line">        <span class="keyword">if</span> cost &lt; lowest_cost <span class="keyword">and</span> node <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line">            lowest_cost = cost</span><br><span class="line">            lowest_cost_node = node</span><br><span class="line">    <span class="keyword">return</span> lowest_cost_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span><span class="params">(src, des)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    利用dijkstra算法，寻找图中从src点到des点的最短路径</span></span><br><span class="line"><span class="string">    :param src: 起点</span></span><br><span class="line"><span class="string">    :param des: 终点</span></span><br><span class="line"><span class="string">    :return: 路径方案(list), 最短路径长度</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 根据起点信息，更新parents和costs</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> graph.keys():</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> graph[src].keys():</span><br><span class="line">            parents[key] = src</span><br><span class="line">            costs[key] = graph[src][key]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parents[key] = <span class="literal">None</span></span><br><span class="line">            costs[key] = infinity</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 寻找所花代价最小的结点，分情况更新parents和costs</span></span><br><span class="line">    node = find_lowest_cost_node(costs)</span><br><span class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        cost = costs[node]</span><br><span class="line">        neighbors = graph[node]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> neighbors.keys():</span><br><span class="line">            new_cost = cost + neighbors[n]</span><br><span class="line">            <span class="keyword">if</span> costs[n] &gt; new_cost:</span><br><span class="line">                costs[n] = new_cost</span><br><span class="line">                parents[n] = node</span><br><span class="line">        searched.append(node)</span><br><span class="line">        node = find_lowest_cost_node(costs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据parents信息和起点信息找出最短路径。</span></span><br><span class="line">    stack = []</span><br><span class="line">    road = []</span><br><span class="line">    stack.append(des)</span><br><span class="line">    child = des</span><br><span class="line">    <span class="keyword">while</span> parents[child] != src:</span><br><span class="line">        stack.append(parents[child])</span><br><span class="line">        child = parents[child]</span><br><span class="line">    stack.append(src)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        road.append(stack.pop())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回路径方案和最短路径长度。</span></span><br><span class="line">    <span class="keyword">return</span> road, costs[des]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试例程</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    r, c = dijkstra(<span class="string">'A'</span>, <span class="string">'D'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"最短路径："</span>)</span><br><span class="line">    print(<span class="string">"-&gt;"</span>.join(r))</span><br><span class="line">    print(<span class="string">"路径长度："</span>)</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天，我和你一起通过计算最短路径这个问题，探讨了 <em>Dijkstra</em> 算法的执行流程和算法实现。我将这篇文章的要点总结如下：</p>
<ol>
<li><p><strong>对于边有权值的图，我们通常将其称作”网”。一个“网”的实例就是地图中的交通网络</strong></p>
</li>
<li><p><em>Dijkstra</em> <strong>算法可以用来计算“网”中从某一点到另一点所花代价最小的方案。在地图中，就是用来计算两个点之间的最短路径方案</strong></p>
</li>
</ol>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><em>Dijkstra</em> 算法可以处理所有情况下的最短路径问题吗？这个问题留给你思考，欢迎你留言与我一起讨论。</p>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>去目的地最少中转方案怎么实现?</title>
    <url>/2018/09/22/qu-mu-de-di-zui-shao-zhong-zhuan-fang-an-zen-me-shi-xian/</url>
    <content><![CDATA[<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/09/22/cover.jpg?raw=true" alt="cover"></p>
<p>在之前的一篇文章中，我们具体讨论了计算去目的地的最少中转方案的算法，但是限于篇幅，没有介绍实现。今天，我们就来看看这个算法如何实现。</p>
<p>在那篇文章中我们提到，为了更快速地获取某一顶点的邻居顶点，采用图的邻接表存储信息比较合适。那么邻接表如何用Python来表达呢？</p>
<p>邻接表兼具数组和链表的特点。我们可以利用哈希表将表头元素和其后续的链表联系起来。在Python中，可以直接使用其内置的字典和列表数据结构来描述这里的邻接表。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/09/17/%E5%9B%BE%E7%BB%93%E6%9E%84%E4%B8%BE%E4%BE%8B.png?raw=true" alt="图的结构举例"></p>
<p>比如，上图的邻接表可表达为： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">'A'</span>] = [<span class="string">'C'</span>]</span><br><span class="line">graph[<span class="string">'B'</span>] = [<span class="string">'C'</span>, <span class="string">'D'</span>]</span><br><span class="line">graph[<span class="string">'C'</span>] = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'E'</span>]</span><br><span class="line">graph[<span class="string">'D'</span>] = [<span class="string">'B'</span>, <span class="string">'E'</span>]</span><br><span class="line">graph[<span class="string">'E'</span>] = [<span class="string">'C'</span>, <span class="string">'D'</span>]</span><br></pre></td></tr></table></figure>



<p>通过调用<code>graph[顶点名]</code>，我们可以很快的获取该点的所有邻居顶点。</p>
<p>除此以外，广度优先搜索需要队列保持搜索的顺序。在Python中，已有内置了队列这样的数据结构。它的基本使用方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque <span class="comment"># 从包中导入队列</span></span><br><span class="line">q = deque()                   <span class="comment"># 初始化一个空队列</span></span><br><span class="line">q.append(&lt;object&gt;)            <span class="comment"># 将某一对象（这个对象是&lt;object&gt;）加入队尾</span></span><br><span class="line">&lt;object&gt; = q.popleft()        <span class="comment"># 从队首弹出元素,将此元素赋值给&lt;object&gt;</span></span><br><span class="line"><span class="string">""" P.S.</span></span><br><span class="line"><span class="string">如果你细心地查看deque的文档的话，会发现它不完全是我们之前所描述的队列。</span></span><br><span class="line"><span class="string">deque是一种双端队列，也就是说元素的增删操作在队头和队尾都可以。</span></span><br><span class="line"><span class="string">在这里，我们限制了deque的操作来模拟队列的功能。</span></span><br></pre></td></tr></table></figure>



<p>确定数据的存储方式后，就可以进入下一步，即如何操作这些数据，达到预期的效果。</p>
<p>在实现最短中转之前，我们先来看看广度优先搜索如何实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">'A'</span>] = [<span class="string">'C'</span>]</span><br><span class="line">graph[<span class="string">'B'</span>] = [<span class="string">'C'</span>, <span class="string">'D'</span>]</span><br><span class="line">graph[<span class="string">'C'</span>] = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'E'</span>]</span><br><span class="line">graph[<span class="string">'D'</span>] = [<span class="string">'B'</span>, <span class="string">'E'</span>]</span><br><span class="line">graph[<span class="string">'E'</span>] = [<span class="string">'C'</span>, <span class="string">'D'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_traverse</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    广度优先遍历图中的顶点</span></span><br><span class="line"><span class="string">    :return:无</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    search_queue = deque()                     <span class="comment"># 初始化队列</span></span><br><span class="line">    searched = []                              <span class="comment"># 存储已经访问过的元素</span></span><br><span class="line">    vexs = list(graph.keys())                  <span class="comment"># 获取图中的所有顶点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph)):                <span class="comment"># 循环遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> vexs[i] <span class="keyword">in</span> searched:            <span class="comment"># 如果该顶点没有访问过</span></span><br><span class="line">            searched.append(vexs[i])           <span class="comment"># 标记其已被访问过</span></span><br><span class="line">            search_queue.append(vexs[i])       <span class="comment"># 加入队列</span></span><br><span class="line">            <span class="keyword">while</span> search_queue:                <span class="comment"># 当队列非空</span></span><br><span class="line">                vex = search_queue.popleft()   <span class="comment"># 弹出队列中的顶点</span></span><br><span class="line">                print(vex)                     <span class="comment"># 打印显示</span></span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> graph[vex]:           <span class="comment"># 遍历其邻居顶点</span></span><br><span class="line">                    <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> searched:      <span class="comment"># 如果邻居顶点未被访问过</span></span><br><span class="line">                        searched.append(v)     <span class="comment"># 标记其已被访问过</span></span><br><span class="line">                        search_queue.append(v) <span class="comment"># 加入队列</span></span><br><span class="line"></span><br><span class="line">bfs_traverse()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">A</span></span><br><span class="line"><span class="string">C</span></span><br><span class="line"><span class="string">B</span></span><br><span class="line"><span class="string">E</span></span><br><span class="line"><span class="string">D</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p> 仔细观察，我们发现广度优先遍历在遍历的过程中并没有存储路径方案。如果要计算从某一点到另一点的最少中转路径，则需要存储路径信息。</p>
<p>那么，如何来存储路径信息呢？</p>
<p>这里，我们可以定义一个<code>parents</code>哈希表，用来存储到达某一点时的上一个顶点。初始时，每一个顶点的上一个顶点都为空。当算法处理完后，这个哈希表中就隐含着路径信息。那么究竟如何利用<code>parents</code>信息来给出路径呢？</p>
<p>我们一起来分析一个例子。如果从A出发，算法处理完后，得到如下的哈希表：</p>
<p>${‘A’: None, ‘B’: ‘C’, ‘C’: ‘A’, ‘D’: ‘B’, ‘E’: ‘C’}$</p>
<p>（为什么 $A$ 对应的值为 $None$ ？因为 $A$ 是起点，在路径上没有上一个顶点。）</p>
<p>如果我们想到达 $D$ ，依据哈希表，可以找到 $D$ 的上一个点为 $B$ ；继续找到 $B$ 的上一个顶点为 $C$ ， $C$ 的上一个顶点为 $A$ 。而 $A$ 没有上一个顶点（即 $A$ 为起点），所以所得路径为 $A-&gt;C-&gt;B-&gt;D$ 。</p>
<p>寻找这个路径的顶点的顺序和最终输出的顺序是相反的，怎么描述方便呢？如果你还记得之前介绍过的栈，你肯定会选择栈来暂存路径数据，在输出时依次弹出即可。（栈的特点是先进后出的，因而可以利用栈把一些对象序列逆序）</p>
<p>为了保证最终得到的方案是最少中转，还需引入中转数。在某些情况下，更新中转数和parents哈希表中的值。中转数的存储可以另外开设哈希表存储，也可以嵌入现有的graph哈希表中。这里，我们选择第二种方案实现。</p>
<p>这样的话，上述 $graph$ 就变为如下的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">'A'</span>] = &#123;<span class="string">'C'</span>: <span class="literal">None</span>&#125;</span><br><span class="line">graph[<span class="string">'B'</span>] = &#123;<span class="string">'C'</span>: <span class="literal">None</span>, <span class="string">'D'</span>: <span class="literal">None</span>&#125;</span><br><span class="line">graph[<span class="string">'C'</span>] = &#123;<span class="string">'A'</span>: <span class="literal">None</span>, <span class="string">'B'</span>: <span class="literal">None</span>, <span class="string">'E'</span>: <span class="literal">None</span>&#125;</span><br><span class="line">graph[<span class="string">'D'</span>] = &#123;<span class="string">'B'</span>: <span class="literal">None</span>, <span class="string">'E'</span>: <span class="literal">None</span>&#125;</span><br><span class="line">graph[<span class="string">'E'</span>] = &#123;<span class="string">'C'</span>: <span class="literal">None</span>, <span class="string">'D'</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure>



<p>在这种 $graph$ 的结构下，广度优先遍历也需要做一点简单的修改。</p>
<p>全部的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">'A'</span>] = &#123;<span class="string">'C'</span>: <span class="literal">None</span>&#125;</span><br><span class="line">graph[<span class="string">'B'</span>] = &#123;<span class="string">'C'</span>: <span class="literal">None</span>, <span class="string">'D'</span>: <span class="literal">None</span>&#125;</span><br><span class="line">graph[<span class="string">'C'</span>] = &#123;<span class="string">'A'</span>: <span class="literal">None</span>, <span class="string">'B'</span>: <span class="literal">None</span>, <span class="string">'E'</span>: <span class="literal">None</span>&#125;</span><br><span class="line">graph[<span class="string">'D'</span>] = &#123;<span class="string">'B'</span>: <span class="literal">None</span>, <span class="string">'E'</span>: <span class="literal">None</span>&#125;</span><br><span class="line">graph[<span class="string">'E'</span>] = &#123;<span class="string">'C'</span>: <span class="literal">None</span>, <span class="string">'D'</span>: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line">parents = &#123;&#125;</span><br><span class="line">parents[<span class="string">'A'</span>] = <span class="literal">None</span></span><br><span class="line">parents[<span class="string">'B'</span>] = <span class="literal">None</span></span><br><span class="line">parents[<span class="string">'C'</span>] = <span class="literal">None</span></span><br><span class="line">parents[<span class="string">'D'</span>] = <span class="literal">None</span></span><br><span class="line">parents[<span class="string">'E'</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(src, des)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    寻找从src到des之间的最短中转方案</span></span><br><span class="line"><span class="string">    :param src: 起点</span></span><br><span class="line"><span class="string">    :param des: 终点</span></span><br><span class="line"><span class="string">    :return: 路径（列表），中转数（整型）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    search_queue = deque()</span><br><span class="line">    searched = []</span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> src <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line">        searched.append(src)</span><br><span class="line">        search_queue.append(src)</span><br><span class="line">        <span class="keyword">while</span> search_queue:</span><br><span class="line">            vex = search_queue.popleft()</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> graph[vex].keys():</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line">                    searched.append(v)</span><br><span class="line">                    search_queue.append(v)</span><br><span class="line">                    <span class="keyword">if</span> graph[vex][v] <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> graph[vex][v] &lt; level:</span><br><span class="line">                        parents[v] = vex</span><br><span class="line">                        graph[vex][v] = level</span><br><span class="line">        <span class="comment">#print(parents)</span></span><br><span class="line">        stack = []</span><br><span class="line">        road = []</span><br><span class="line">        stack.append(des)</span><br><span class="line">        child = des</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> parents[child] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(parents[child])</span><br><span class="line">            child = parents[child]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            road.append(stack.pop())</span><br><span class="line"></span><br><span class="line">        node = src</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> des <span class="keyword">not</span> <span class="keyword">in</span> graph[node].keys():</span><br><span class="line">            node = road[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        cost = graph[node][des]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> road, cost</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_traverse</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    广度优先遍历图中的顶点</span></span><br><span class="line"><span class="string">    :return:无</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    search_queue = deque()</span><br><span class="line">    searched = []</span><br><span class="line">    vexs = list(graph.keys())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph)):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> vexs[i] <span class="keyword">in</span> searched:</span><br><span class="line">            searched.append(vexs[i])</span><br><span class="line">            search_queue.append(vexs[i])</span><br><span class="line">            <span class="keyword">while</span> search_queue:</span><br><span class="line">                vex = search_queue.popleft()</span><br><span class="line">                print(vex)</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> graph[vex].keys(): <span class="comment"># 修改！！！</span></span><br><span class="line">                    <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line">                        searched.append(v)</span><br><span class="line">                        search_queue.append(v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bfs_traverse()</span></span><br><span class="line"></span><br><span class="line">r, c = search(<span class="string">"A"</span>, <span class="string">'E'</span>)</span><br><span class="line">print(<span class="string">"最少中转次数为&#123;&#125;,路径为&#123;&#125;"</span>.format(c, <span class="string">','</span>.join(r)))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">最少中转次数为2,路径为A,C,E</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p>上述输出的结果符合我们的心理预期。这样实现就能满足所有情况了吗？答案显然是否定的，因为这种实现并没有考虑两点之间没有路径的极端情况（当然如果在现实中，这种情况出现的概率非常小）。这个函数的进一步改进留给你自己思考。</p>
<p>好了，本篇文章的主要内容结束了。最后是本篇的重点内容回顾。</p>
<ol>
<li><strong>图的邻接表存储方式，在Python中可以利用字典描述</strong></li>
<li><strong>利用栈可以将对象序列逆序排列。</strong></li>
</ol>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>去目的地最少中转方案怎么算?</title>
    <url>/2018/09/17/qu-mu-de-di-zui-shao-zhong-zhuan-fang-an-zen-me-suan/</url>
    <content><![CDATA[<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/09/17/cover.jpg?raw=true" alt="cover"></p>
<p>当今时代，随着交通越来越发达，我们更加愿意选择公共交通出行。然而在去往目的地的时，公共交通有时并不能直达，需要中转。中转有时候会非常浪费时间，因而我们希望在去往目的地的过程中，中转的次数越少越好。以往，我们需要自己记忆繁杂的交通网络人为判断；而现在，我们可以很方便地从手机中的地图app中获取最少中转的方案。你有没有想过，这些最少中转方案是怎么生成的呢？</p>
<p>面对这个问题感觉无从下手？那我们一起来看看地图导航app中是如何简化这个问题的。</p>
<p>地图上，我们自己的位置和目的地的位置被简化为两个不同的点，各个公共交通站台也被简化成一个个点；一条条线连接着不同的点，这意味着这两点可以通过一种公共交通直达。这种由点和线连接起来的结构，在数据结构中叫做“图”。其中的点叫做“顶点”（ $Vertex$ ），线则叫做“边”（ $Edge$ ）。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/09/17/%E5%9B%BE%E7%BB%93%E6%9E%84%E4%B8%BE%E4%BE%8B.png?raw=true" alt="图的结构距离"></p>
<p>有了“图”这种结构，我们就可以构建出一个简易的交通网络。以此为基础，让我们回到文章开始提出的问题：如何利用这样的信息来寻找最少中转方案呢？</p>
<p>在了解这个算法之前，我们先来了解一下图这个数据结构中的“邻居”的概念。</p>
<p>比如上图中，假设你在 $C$ 点，那么 $A$ 、 $B$ 、 $E$  是与你直接相连的，这些顶点也叫做 $C$  的“邻居”（ $Neighbour$ ）。</p>
<p>利用“邻居”的概念，该算法可以描述如下：</p>
<p>计算机会先寻找你周围的“邻居”，检查这些地点是否是你的目的地。如果是，那么就可以返回结果了；如果不是，那么再依次检查你“邻居”的“邻居”···依次类推，直到找到目的地。</p>
<p>从“邻居”到其自身“邻居”依次遍历，保证自己的位置到目的地是一条可行的通路；按照距离你位置由近到远的“邻居”为顺序依次检查，保证了路径是最短中转。因此，这个算法是有效的。</p>
<p>上述求最少中转方案的算法，其实是图算法中一种遍历算法的具体应用。这种遍历图的算法称作“宽度优先搜索”（ $Breadth-First \ Search$ ）。它从一个点出发，先遍历起点周围的未被访问过的“邻居”顶点，再遍历“邻居”顶点的未被访问过的“邻居”顶点···依次类推，直到所有能够被访问到的顶点（也就是该点与起点之间存在一条路径）都被访问过。如果在此过程中，还有未被访问的顶点，那么重新选择一个未被访问的顶点作为新起点，并重复上述操作。</p>
<p>那么这个算法如何实现呢？</p>
<p>在此之前，我们要考虑如何利用编程语言来描述图这种结构。</p>
<p>图在计算机中的存储结构通常有三个，分别是数组表示法(有时候也叫邻接矩阵表示法)、邻接表表示法、十字链表表示法。限于篇幅。我这里只讨论前两种，第三种大家自己找相关书籍阅读吧。 :)</p>
<p>从“数组表示法”的命名，我们很自然地想到利用数组来存储顶点信息；从“邻接矩阵表示法”的命名，我们也可以很自然的想到这种方式是利用矩阵来存储顶点与顶点之间的关联。</p>
<p>假设图中有 $N$ 个顶点，那么建立一个大小为 $N$ 的数组存储顶点信息；接下来再创建一个大小为 $N × N$ 的矩阵存储顶点之间的联系。假设存储在顶点数组下标为 $i$ 和 $j$ 的两个顶点直接相连，如果这种相连关系是单向的（比如从 $i$ 到 $j$ ），那么矩阵 $( i, j )$ 位置存储 1 （表示它们是相邻的，而 0 自然是表示它们不相邻）；如果这种相连关系是双向的，那么矩阵 $( j, i )$ 位置上的值也得是 1 。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/09/17/%E5%9B%BE%E7%BB%93%E6%9E%84%E4%B8%BE%E4%BE%8B.png?raw=true" alt="图的结构距离"></p>
<p>把我们上面用于举例的图的结构拿过来，我们发现顶点之间的联系是双向的。换句话说，方向在这种图中，是没有意义的。这样顶点双向联系的图叫做“无向图”。依据这点分析，顶点单向联系的图便叫做“有向图”。</p>
<p>面对这个无向图，我们可以很容易得到它的顶点数组和其邻接矩阵。具体如下：</p>
<p>顶点数组：${A，B，C，D，E}$</p>
<p>邻接矩阵：<br>$$<br>\left[\begin{array}{ccc}<br>0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\<br>0 &amp; 0 &amp; 1 &amp; 1 &amp; 0\<br>1 &amp; 1 &amp; 0 &amp; 0 &amp; 1\<br>0 &amp; 1 &amp; 0 &amp; 0 &amp; 1\<br>0 &amp; 0 &amp; 1 &amp; 1 &amp; 0\<br>\end{array}<br>\right]<br>$$<br>对应的表格如下：</p>
<table>
<thead>
<tr>
<th align="center">·</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>仔细观察，我们发现，无向图的邻接矩阵是以主对角线对称的。根据这点特性，对于无向图，我们可以只存储一个上三角区域（或者是下三角区域）来节省存储空间。</p>
<p>上述图的存储方式十分简单，但是如果图中的边非常少，那么邻接矩阵中大部分存储的都是零，造成了极大的空间浪费。怎么解决这个问题呢？</p>
<p>邻接表的存储方式就是来解决这一问题的。邻接表的存储结构有点像我们之前介绍过的数组链表的混合结构。每个链表的表头存储顶点信息，这些链表构成一个链表数组。每个链表表头后续的链表元素存储与表头所存顶点直接相连顶点在链表数组中的下标。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/09/17/%E5%9B%BE%E7%BB%93%E6%9E%84%E4%B8%BE%E4%BE%8B.png?raw=true" alt="图的结构距离"></p>
<p>那么上图就可以利用邻接表表示为 </p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/09/17/%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E4%B8%BE%E4%BE%8B.png?raw=true" alt="邻接表存储举例"></p>
<p>我们对比两者图的存储结构，可以发现，邻接表可以很快获取一个顶点的“邻居”顶点。因而，对于求最短路径算法，我们选择邻接表存储图的信息。</p>
<p>为了图中的顶点能够按照宽度优先搜索时的顺序遍历，我们这里还要利用另一个叫做“队列”数据结构。“队列”，和生活中的排队十分相似，数据在队列中“先进先出”【 $FIFO$ 】（与之相反，数据在栈中“先进后出”【 $FILO$ 】）。队列只支持两种操作，一种为 $EnQueue$ （入队，将元素加入队尾），另一种为 $DeQueue$ （出队，从队首移除元素，并返回该元素的值）。</p>
<p>从起点开始，依次将其“邻居”顶点加入队列；在遍历“邻居”顶点时，先将该顶点出队，再将“邻居”顶点的“邻居”顶点依次入队···直到找到目的地顶点。如果这个过程结束后，队列为空，那么已知的图上不存在相关路径。</p>
<p>好了，今天就到这里。算法的实现留给大家思考。也许，我之后会补上一篇文章介绍该算法的实现。</p>
<p>最后是本文的总结：</p>
<ol>
<li><strong>利用图这种数据结构可以很全面地描述多个点之间相互关联的信息（比如地图）。</strong></li>
<li><strong>利用图的广度优先搜索，我们可以遍历图中的每一个顶点、判断一个顶点到另一个顶点是否存在路径、计算乘坐公交去目的地的最少中转方案等问题。</strong></li>
<li><strong>图的存储结构有三种，分别是邻接矩阵表示法、邻接表表示法、十字链表表示法。</strong></li>
<li><strong>广度优先搜索中利用到“队列”的数据结构。</strong></li>
<li><strong>数据在队列中“先进先出”【 $FIFO$ 】。队列只支持两种操作，一种为 $EnQueue$  （入队，将元素加入队尾），另一种为 $DeQueue$（出队，从队首移除元素，并返回该元素的值）</strong></li>
<li><strong>对比第5点，数据在栈中“先进后出”【 $FILO$ 】</strong></li>
</ol>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>高效的数据结构——哈希表</title>
    <url>/2018/09/07/gao-xiao-de-shu-ju-jie-gou-ha-xi-biao/</url>
    <content><![CDATA[<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/09/07/cover.jpg?raw=true" alt="cover"></p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在编程过程中，我们经常会遇到多组一一对应的数据（比如，通讯录中的姓名和电话号码），如何存储这些数据，同时能获得较高的数据操作效率呢？</p>
<p>下面，我们以通讯录中的存储为例进行简单的讨论。</p>
<p>首先，我们会想到利用数组来存储这些数据，一个数组用于存储姓名，另一个数组用于存储电话号码。单单两个数组并不能完成数据中一一对应的要求，因而需要我们自己书写其中的对应关系。</p>
<p>一一对应的关系可以由这样一个映射关系 $f$ 来描述：$f : a → b$ 。这个映射关系意味着一个确定的 $a$ 的值，能够找到与之对应的 $b$ 。在这里，我们通常把 $a$ 称作“关键字”（ $Key$ ），而与之对应的 $b$ 称作“值”（ $Value$ ）。对于我们的通讯录例子，因为我们经常需要按人名查找其电话号码，所以我们可以将姓名当作关键词，将电话号码当作值。</p>
<p>数组利用整数作为下标来取用任意位置元素的值，类似的，我们也希望上面所描述的对应关系能够利用关键字来取用对应的值。这种想法怎样实现呢？基于数组这种结构，我们可以对它进行简单的扩展，来实现这种想法。数组下标是整数，而关键字通常是字符串，所以我们要写一个转换函数，它能够将一个字符串映射到自然数域中。举个例子，比如有一个叫做“小明”的人，我利用这个转换函数将“小明”转换成数字 1 ，此时将小明的姓名和电话号码存储在各自数组下标为 1 的位置即可。这种存储方式，就是一种简单的哈希表，其中的字符串转换为数字函数称为哈希函数。</p>
<p>很多高级语言本身内置了类似哈希表的数据类型，可以直接使用。比如Python中，字典（Dict）就是哈希表。哈希表在每种语言中的使用在各类语言教程中已经有了很好的示例，这里不再介绍。而我们要探讨的便是分析一下哈希表中存在的问题、它的性能和一些典型应用。</p>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>经过上述的一些讨论，我们可以发现，哈希表有两个集合和一个函数组成。两个集合分别是关键字集合和值集合，而一个函数则为哈希函数（用于维护关键字到值存储位置的关系）。两个集合的存储可以很容易利用数组实现，从而问题的关键便转向了哈希函数的设计。</p>
<p>构造一个从字符串映射到数字的函数很简单，但是随手设计的哈希函数有时却会产生问题。我们来看一个典型的例子。比如我把哈希函数定义为取字符串的长度，并以此输出结果作为信息存储位置。同时，我有待存储的信息：<em>（小明，12345678910）</em>、<em>（小刚，01987654321）</em>。首先，存储小明的信息。假设一个汉字的字符长度为1，那么“小明”字符长度为2，应该存储在下标为2的位置上。接着存储小刚的信息，此时我们发现，根据给定的哈希函数，小刚的信息也应该存储的在下标为 2 的位置。这种情况下，存储位置就产生了冲突。在哈希表中，这种冲突称作“哈希冲突”。</p>
<p>那么，如何解决哈希冲突呢？一种做法在原有的存储结构上修改：比如在数组对应位置新串接一个链表，存储新的数据；此外，也可以在冲突位置的附近数据为空的位置存储新的信息。二是重新设计哈希函数，使它出现冲突的情况尽可能得少。</p>
<p>要构造一个较好的哈希函数，首先它必须满足以下基本的三个条件：</p>
<p>第一点，      一致性。相同的字符串输入，能够获得相同的数字输出；</p>
<p>第二点，      互异性。不同的字符串输入，获得的数字输出尽量不同；</p>
<p>第三点，      合理性。哈希函数的输出值大小必须在表存储容量的范围之内，保证得到的下标的合理性。比如容量为10的哈希表，对应的哈希函数不能返回100这样的数值。</p>
<p>哈希函数构造方法有很多，大家可以自己去看看，我这里就不过多阐述了。</p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>哈希表继承了数组高效获取任意元素的特质，在常数时间内即可完成对任意元素的访问。同时在增添和删除也有十分好的表现。由于哈希表的信息存储并不是像数组一样按照顺序依次存储，而是依据哈希函数确定存储位置，所以增添和删除元素不需要做十分耗费时间的移动操作，因而在哈希表中，增添和删除操作也可以在常数时间内完成。</p>
<h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><p>基于哈希表的特性，实际编程中有以下两种应用。第一种，用于建立信息相关的两组数据的联系，方便由一组数据的信息快速查找到它对应的信息。之前的通讯录例子便是这一类的具体应用。第二种，用于过滤重复的信息。有哈希函数的特性可知，不同的关键字对应不同的存储位置，相同的关键字对应相同的位置。我们可以在对应位置存储一个标记信息，用来判断该关键字是新增的还是之前出现过的。利用哈希表这种结构，我们就可以很方便地过滤掉重复的信息。</p>
<p>文章的最后，我们简单总结一下本文的内容：</p>
<ol>
<li><p><strong>哈希表是一种十分高效的数据结构，它通常可以在常数时间内完成对元素的插入、删除和访问。</strong></p>
</li>
<li><p><strong>哈希表内部通常有两个集合和一个函数。两个集合分别是关键字集合和值集合，而一个函数则为哈希函数（用于维护关键字到值存储位置的关系）。</strong></p>
</li>
<li><p><strong>哈希表的效率受哈希函数影响，不恰当的哈希函数会造成哈希冲突，造成哈希表效率的下降。</strong></p>
</li>
<li><p><strong>一个哈希函数通常有以下三个特点：</strong></p>
<p><strong>第一点，一致性。相同的字符串输入，能够获得相同的数字输出；</strong></p>
<p><strong>第二点，互异性。不同的字符串输入，获得的数字输出尽量不同；</strong></p>
<p><strong>第三点，合理性。哈希函数的输出值大小必须在表存储容量的范围之内，保证得到的下标的合理性。比如容量为10的哈希表，对应的哈希函数不能返回100这样的数值。</strong></p>
</li>
<li><p><strong>利用哈希表可以很容易存储两个联系十分紧密的数据，同时也可以过滤掉重复的信息。</strong></p>
</li>
</ol>
<p>附录：哈希表的简单实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    哈希表类：</span></span><br><span class="line"><span class="string">      用于创建哈希表</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">      size：哈希表的容量大小</span></span><br><span class="line"><span class="string">    属性：</span></span><br><span class="line"><span class="string">      keys：哈希表的关键字集合</span></span><br><span class="line"><span class="string">      values：哈希表的值集合</span></span><br><span class="line"><span class="string">      items：哈希表的关键字集合和哈希表的值集合组成的一个元组</span></span><br><span class="line"><span class="string">    静态变量：</span></span><br><span class="line"><span class="string">      UNUSED：用于标记某一存储位置是否被使用，其值为None</span></span><br><span class="line"><span class="string">      DEFAULTSIZE：默认哈希表容量，值为32</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    UNUSED = <span class="literal">None</span></span><br><span class="line">    DEFAULTSIZE = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size=DEFAULTSIZE)</span>:</span></span><br><span class="line">        self.__keys = [HashTable.UNUSED] * size</span><br><span class="line">        self.__values = [HashTable.UNUSED] * size</span><br><span class="line">        self.__size = size</span><br><span class="line">        self.__len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        删除哈希表中关键字为key的key和value。如果key不在哈希表中，那么将引起KeyError异常</span></span><br><span class="line"><span class="string">        :param key:待删除的关键字</span></span><br><span class="line"><span class="string">        :return:无</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        found, index = self.__find_index(key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            self.__keys[index] = HashTable.UNUSED</span><br><span class="line">            self.__values[index] = HashTable.UNUSED</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">"关键字不存在"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        在哈希表中查找关键字为key的值。如果找到，返回关键字对应的值；如果不存在，返回None</span></span><br><span class="line"><span class="string">        :param key: 待查找的关键字</span></span><br><span class="line"><span class="string">        :return: 关键字对应的值或者是None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        found, index = self.__find_index(key)</span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            <span class="keyword">return</span> self.__values[index]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        清空哈希表</span></span><br><span class="line"><span class="string">        :return: 无</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.__keys = [HashTable.UNUSED] * HashTable.DEFAULTSIZE</span><br><span class="line">        self.__values = [HashTable.UNUSED] * HashTable.DEFAULTSIZE</span><br><span class="line">        self.__size = HashTable.DEFAULTSIZE</span><br><span class="line">        self.__len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">keys</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取所有关键字</span></span><br><span class="line"><span class="string">        :return: 一个包含哈希表关键字集合的列表</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> [key <span class="keyword">for</span> key <span class="keyword">in</span> self.__keys <span class="keyword">if</span> key <span class="keyword">is</span> <span class="keyword">not</span> HashTable.UNUSED]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">values</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取所有值</span></span><br><span class="line"><span class="string">        :return: 一个包含哈希表值集合的列表</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> [value <span class="keyword">for</span> value <span class="keyword">in</span> self.__values <span class="keyword">if</span> value <span class="keyword">is</span> <span class="keyword">not</span> HashTable.UNUSED]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">items</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取所有关键字和值</span></span><br><span class="line"><span class="string">        :return: 一个包含keys和values的元组</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.keys, self.values</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__load_factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        装载因子，如果此值超过一定数值，需要重新申请新空间，重新做哈希操作</span></span><br><span class="line"><span class="string">        :return: 返回当前装载因子的值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> float(self.__len / self.__size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        重载[]运算符获取元素的方法</span></span><br><span class="line"><span class="string">        :param key: 关键字</span></span><br><span class="line"><span class="string">        :return: 关键字对应的值</span></span><br><span class="line"><span class="string">        :raise:KeyError("关键字不存在")</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">assert</span> self.__len &gt; <span class="number">0</span>, <span class="string">"哈希表为空！"</span></span><br><span class="line">        found, index = self.__find_index(key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            <span class="keyword">return</span> self.__values[index]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">"关键字不存在"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        重载H[k] = v</span></span><br><span class="line"><span class="string">        :param key: 关键字</span></span><br><span class="line"><span class="string">        :param value: 值</span></span><br><span class="line"><span class="string">        :return: 无</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.__load_factor &gt; <span class="number">0.7</span>:</span><br><span class="line">            self.__rehash()</span><br><span class="line"></span><br><span class="line">        found, index = self.__find_index(key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            self.__values[index] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__len += <span class="number">1</span></span><br><span class="line">            self.__keys[index] = key</span><br><span class="line">            self.__values[index] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__find_index</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        计算或者是查找key存储的位置</span></span><br><span class="line"><span class="string">        :param key: 关键字</span></span><br><span class="line"><span class="string">        :return: (bool, int)。第一个返回值代表key是否在哈希表中，index代表key所在的位置（如果不在哈希表中，那么是新位置；否则是原来key的位置）</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        index = abs(hash(key)) % self.__size <span class="comment">#利用python内置的hash函数计算下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.__keys[index] <span class="keyword">is</span> <span class="keyword">not</span> HashTable.UNUSED:</span><br><span class="line">            <span class="keyword">if</span> self.__keys[index] == key:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, index</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = (index + <span class="number">1</span>) % self.__size<span class="comment">#处理哈希冲突，采用开放定址法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, index</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rehash</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        重新申请新的空间，存储数据</span></span><br><span class="line"><span class="string">        :return:无</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        old_keys = self.keys</span><br><span class="line">        old_values = self.values</span><br><span class="line"></span><br><span class="line">        self.__size *= <span class="number">2</span></span><br><span class="line">        self.__len = <span class="number">0</span></span><br><span class="line">        self.__keys = [HashTable.UNUSED] * self.__size</span><br><span class="line">        self.__values = [HashTable.UNUSED] * self.__size</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(old_keys)):</span><br><span class="line">            key = old_keys[i]</span><br><span class="line">            value = old_values[i]</span><br><span class="line">            _, index = self.__find_index(key)</span><br><span class="line">            self.__keys[index] = key</span><br><span class="line">            self.__values[index] = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    hash_table = HashTable(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    hash_table[<span class="number">100</span>] = <span class="number">56</span></span><br><span class="line">    print(hash_table.keys, hash_table.values)</span><br><span class="line">    hash_table[<span class="number">100</span>] = <span class="number">46</span></span><br><span class="line">    print(hash_table.keys, hash_table.values)</span><br><span class="line"></span><br><span class="line">    hash_table[<span class="string">"aa"</span>] = <span class="string">"44"</span></span><br><span class="line">    print(hash_table.keys, hash_table.values)</span><br><span class="line"></span><br><span class="line">    hash_table[<span class="number">1.44</span>] = <span class="number">666</span></span><br><span class="line">    print(hash_table.keys, hash_table.values)</span><br><span class="line"></span><br><span class="line">    print(hash_table[<span class="number">100</span>])</span><br><span class="line"></span><br><span class="line">    hash_table.delete(<span class="string">"aa"</span>)</span><br><span class="line"></span><br><span class="line">    print(hash_table.keys, hash_table.values)</span><br><span class="line"></span><br><span class="line">    print(hash_table.find(<span class="number">444</span>))</span><br><span class="line"></span><br><span class="line">    hash_table.clear()</span><br><span class="line"></span><br><span class="line">    print(hash_table.keys, hash_table.values)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">100] [56]</span></span><br><span class="line"><span class="string">[100] [46]</span></span><br><span class="line"><span class="string">[100, 'aa'] [46, '44']</span></span><br><span class="line"><span class="string">[100, 1.44, 'aa'] [46, 666, '44']</span></span><br><span class="line"><span class="string">46</span></span><br><span class="line"><span class="string">[100, 1.44] [46, 666]</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">[] []</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>分治思想下的高效排序算法</title>
    <url>/2018/08/30/fen-zhi-si-xiang-xia-de-gao-xiao-pai-xu-suan-fa/</url>
    <content><![CDATA[<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/30/cover.jpg?raw=true" alt="cover"></p>
<p>什么是分治？这是一种解决问题的方法。别看它名字高大上，其实我们在日常生活学习中经常用到它。我相信，你看完下面的例子后就可以明白分治的内涵了。</p>
<p>还记得你小学是如何计算多个数连续相加吗？我想，一般的解决办法应该是这样的：</p>
<p>从左到右，让第一个数和第二个数相加，所得的结果和后续的式子相加构成新的式子。此时，新得到的式子比原式更简单，更容易解决（因为要相加的数的个数变少了）。接着，让新的式子中的第一个数和第二个数相加，所得结果和后续剩下的式子构成另一个新的式子···如此进行下去，原式会不断的被化简，最终只剩下一个数，而这个数，正是原式的结果。</p>
<p>这里用来化简多个数相加的方法其实就是“分治”的实际应用。仔细观察上述过程，我们可以总结概括利用分治解决问题的两大步骤：</p>
<p>第一，   化简原问题。我们要找到能够将原问题化简为相似的、更小的、更易解决的子问题的方法。在上述连续的加法计算中，不断地将式子中第一个数字和第二个数字相加，所得结果和剩下的式子构成新式子，供下一步化简使用。这个过程便是不断化简问题的过程。</p>
<p>第二，   找到答案显而易见的基础案例。我们要找到一个非常简单的一个案例和该案例发生时的条件（这个案例要尽可能地简单，从而通过常识即可给出案例对应的答案）。这也指明了化简的终点。对应上面加法的例子，它的基础案例便是当化简到一个数时，化简终止。</p>
<p>上述对于分治方法的描述是不是有些熟悉？对了！它解决问题的过程和递归十分相似。基于这一点特质，我们可以利用递归程序来实现分治。</p>
<p>分治思想在算法中有很多应用，要说其中最基础的、最实用的，我想应该是以下要介绍的两种高效排序算法：一是归并排序，二是快速排序。</p>
<p>下面，我们来看一看这两个高效的排序算法是如何工作的。</p>
<p>首先是归并排序。它的算法流程描述如下：</p>
<p>假设待排序的数据序列中有n个数据， 可以先将序列看成是由n个长度为1 的有序子序列组成</p>
<p>n 然后再两两子序列合并， 得到一个n/2个长度为2或1 （当序列中数据为奇数时会有一个子序列长度为1 ） 的有序子序列，</p>
<p>n 再两两子序列合并， 如此重复， 直到得到一个长度为n的有序序列为止</p>
<p>为了更清晰地理解归并排序的流程，我们来看一个例子。</p>
<p>我们来看看利用归并排序算法排序83，84，87，88，61，50，70，60，80，99这10个数的流程：（注：以下分号分割每一组数据，逗号分割组内数据）</p>
<p>首先，进行2个数合并排序，得到：83，84 ；87，88；50，61；60，70；80，99；</p>
<p>其次，进行4个数合并排序，得到：83，84，87，88；50，60，61，70；80，99；</p>
<p>接着，进行8个数合并排序，得到：50，60，61，70，83，84，87，88；80，99；</p>
<p>最后，将剩下的2个子序列合并排序，得到：50, 60, 61, 70, 80, 83, 84, 87, 88, 99。</p>
<p>那么，这样的排序流程如何用代码来实现呢？</p>
<p>这个过程与递归相似，但不完全一致，所以需要通过一定的转化，才能利用递归实现归并排序算法。</p>
<p>递归程序，无非要找两个东西。一是初始条件，二是能够将原问题化为更小子问题的递推公式。在归并排序中，这两个东西对应着什么呢？</p>
<p>仔细观察上述归并排序的过程，我们发现这个过程是一个不断合并的过程，所以我们可以先写一个函数，来实现合并两个内部已经有序的数据序列。有了这个函数的支持，我们下一步就需要将原问题化为更小的子问题。这里，一种解决方案是将原数据序列不断划分为左一半和右一半，然后再利用合并函数将它们合并即可。那么什么时候到达划分的终点呢？根据排序这个问题，我们很容易发现，当数据序列中的元素只有一个时，便达到划分的终点。</p>
<p>根据上述讨论，简单总结一下便是：对原序列划分成左半部和右半部后再合并，是归并排序的原问题化简的方法；数据序列中只剩下一个元素时，划分到达终点，这也是该递归程序的初始条件。</p>
<p>了解了这些，代码也就很容易写了。</p>
<p>它的代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(lst1,lst2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    merge:</span></span><br><span class="line"><span class="string">     对于内部已经从小到大排序的两个列表，把它们合并成一个从小到大排序的列表</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     lst1：内部已经从小到大排序的数据列表1</span></span><br><span class="line"><span class="string">     lst2：内部已经从小到大排序的数据列表2</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     两个列表的合并结果（结果从小到大排序）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    lst = lst1<span class="comment">#合并后的lst</span></span><br><span class="line">    <span class="keyword">while</span> len(lst2) != <span class="number">0</span>:</span><br><span class="line">        a = lst2.pop(<span class="number">0</span>)<span class="comment">#取出lst2中第一个元素，并且将它从lst2中删除</span></span><br><span class="line">        place = len(lst)<span class="comment">#记录元素a插入结果lst的位置</span></span><br><span class="line">        lst.append(a)<span class="comment">#将a插入到lst末尾</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst1)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):<span class="comment">#寻找大小顺序合适的位置插入元素a，保证lst从小到大排列</span></span><br><span class="line">            <span class="keyword">if</span> a &lt; lst[i]:</span><br><span class="line">                lst[i+<span class="number">1</span>] = lst[i]</span><br><span class="line">                place = i</span><br><span class="line">        lst[place] = a</span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    merge_sort:</span></span><br><span class="line"><span class="string">     利用归并排序使得列表中的数据从小到大排列</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     lst：待排序的数据列表</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     从小到大排序的数据列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(lst) == <span class="number">1</span>:<span class="comment">#当数据列表中只有一个元素时，这个列表已经有序，直接返回该列表</span></span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#分解子问题，对原lst排序，相当于对当前lst的左一半和右一半做排序</span></span><br><span class="line">        lst1 = merge_sort(lst[:len(lst)//<span class="number">2</span>])<span class="comment">#左一半的有序数据列表</span></span><br><span class="line">        lst2 = merge_sort(lst[len(lst)//<span class="number">2</span>:])<span class="comment">#右一半的有序数据列表</span></span><br><span class="line">        <span class="keyword">return</span> merge(lst1,lst2)<span class="comment">#将两个有序列表合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例</span></span><br><span class="line">print(merge_sort([<span class="number">83</span>,<span class="number">84</span>,<span class="number">87</span>,<span class="number">88</span>,<span class="number">61</span>,<span class="number">50</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">80</span>,<span class="number">99</span>]))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出结果:</span></span><br><span class="line"><span class="string">[50, 60, 61, 70, 80, 83, 84, 87, 88, 99]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p>接着，我们来看一看快速排序。</p>
<p>快速排序的中的分治思想也是将原数据序列做划分，但是它在排序过程中又与归并排序有些不同。归并排序首先让每一个子序列内部有序，但外部整体无序；然后再通过合并子序列，使得整体有序。快速排序则是首先让数据外部整体有序，但内部无序；之后利用同样的方法使得子序列内部有序，再将它们按照外部整体有序时的顺序合并即可。</p>
<p>那么快速排序算法是怎样实现外部整体有序的呢？快速排序每次选择一个枢轴（ $pivot$ ）元素，将当前数据序列中剩下的所有比枢轴元素小的组成一个新的数据序列（假设名字为 $l$ ）、所有比枢轴元素大的组成一个新的数据序列（假设名字为 $g$ ），那么 $l$ ， $pivot$ ， $g$ 三个子序列在外部便已经有序。如何解决 $l$ 、 $g$ 两个子序列内部无序的的问题呢？对子序列利用快速排序的思想即可。比如在 $l$ 中选择枢轴元素，将 $l$ 划分成 $ll$ （比 $ppivot$ 小的）、 $ppivot$ （枢轴元素）、 $gg$ （比 $ppivot$ 大的）三部分···经过不断的划分，最终我们会使得序列中的元素个数小于2个，这也就是我们划分的终点。</p>
<p>有了上述的讨论，我想下面的代码也会很容易理解吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    quick_sort:</span></span><br><span class="line"><span class="string">     利用快速排序使得列表中的数据从小到大排列</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     lst：待排序的数据列表</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     从小到大排序的数据列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#如果列表元素只有1个或者没有，</span></span><br><span class="line">    <span class="comment">#那么其本身已经有序，不需要任何额外操作，</span></span><br><span class="line">    <span class="comment">#直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> len(lst) == <span class="number">1</span> <span class="keyword">or</span> len(lst) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = lst[<span class="number">0</span>]<span class="comment">#选定当前lst的第一个元素为枢轴元素（基准）</span></span><br><span class="line">        lst_l = [i <span class="keyword">for</span> i <span class="keyword">in</span> lst[<span class="number">1</span>:] <span class="keyword">if</span> i &lt; pivot]<span class="comment">#在lst中抽取所有比枢轴元素小的元素构成列表lst_l</span></span><br><span class="line">        lst_g = [i <span class="keyword">for</span> i <span class="keyword">in</span> lst[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]<span class="comment">#在lst中抽取所有比枢轴元素大的元素构成列表lst_g</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#lst_l、pivot、lst_g已经相对有序，但是lst_l、lst_g内部无序，</span></span><br><span class="line">        <span class="comment">#所以需要分别对lst_l、lst_g执行快速排序，使其有序</span></span><br><span class="line">        <span class="comment">#最后将结果合并即可</span></span><br><span class="line">        <span class="keyword">return</span> quick_sort(lst_l) + [pivot] + quick_sort(lst_g)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例</span></span><br><span class="line">print(quick_sort([<span class="number">83</span>,<span class="number">84</span>,<span class="number">87</span>,<span class="number">88</span>,<span class="number">61</span>,<span class="number">50</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">80</span>,<span class="number">99</span>]))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出结果:</span></span><br><span class="line"><span class="string">[50, 60, 61, 70, 80, 83, 84, 87, 88, 99]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p>归并排序和快速排序在排序算法中是比较高效的算法。它们究竟有多快呢？我们来一起分析一下他们呢的时间复杂度。</p>
<p>首先假设问题规模为 $N$ ，所需要的执行步骤为 $T ( N )$ 。在归并排序中，程序第36行和37行将问题分解为左右一半，第38行的合并相当于将两个子序列都遍历了一遍（每个子列的规模为 $\frac{N}{2}$ ），所以有如下递推公式：</p>
<p>$$<br>\begin{aligned}<br>T(N) &amp;= 2T(N/2) + N / 2 + N / 2\<br>         &amp;=2T(N/2) + N<br>\end{aligned}<br>$$</p>
<p>进一步递推可得， $T(N) = N\cdot T(1) + k\cdot N$ ，其中 $k = log_{2}(N)$ 。当数据规模为1时，解决问题的步骤显然只需一步，所以 $T(N) = N + N\cdot log_{2}(N)$，所以归并排序的时间复杂度为 $O( N\cdot log( N ) )$ 。</p>
<p>快速排序中，子序列的划分并不像归并排序那么确定（因为枢轴元素的选取会影响快速排序中子列的划分），同时快速排序的时间复杂度也有多种情况。最好的情况，枢轴元素恰巧是该序列的中数（也就是排序后，该数的位置在序列的中间），第一层快速排序会使得枢轴元素两端的子序列的个数相差不大。这种情况就相当于把原序列对半划分，和归并排序十分类似。分析一下，这种情况下快速排序的时间复杂度和归并排序一样，为 $O( N\cdot log( N ) )$ ；最坏的情况，枢轴元素是原序列中最小的元素或者是最大的元素，他将原序列划分为两个十分不平衡的子序列，一边没有元素，而另一边含有所有剩下的元素。对于这种情况，我们有如下递推公式：</p>
<p>$$<br>T(N) = T(N-1) + N\<br>其中,T(N-1)为解决子问题的时间，N为合并时间<br>$$</p>
<p>递推下去，可得 $T(N) = T(1) + N\times N = N^{2} + 1$ ，所以时间复杂度为 $O( N^{2} )$ 。平均情况下，枢轴元素的选取不会总是最坏情况，大多数情况下都是 $O( N\cdot log( N ) )$ 。</p>
<p>文章的最后，我们简单总结一下本文的内容：</p>
<ol>
<li><strong>分治是一种解决问题的方法，他通过不断将原问题分解成相似的、更小的、更以解决的子问题，并通过可以直接看出结果的子问题的答案，逐层回代解决原问题。</strong></li>
<li><strong>分治解决问题的一般步骤：找到显而易见的子问题的解；分解原问题到子问题，通过子问题的解解决原问题。</strong></li>
<li><strong>分治的方法可以利用递归程序实现。</strong></li>
<li><strong>分治思想下有两种十分高效的排序算法：一是归并排序，二是快速排序。</strong></li>
<li><strong>归并排序的流程：将原序列不断对半划分，直至其中元素只剩1个返回，然后逐层将左右子序列合并即可。</strong></li>
<li><strong>快速排序的流程：将原序列利用枢轴元素划分，比枢轴元素小的为一个子序列，比枢轴元素大的为另一个子序列，直至其中元素只剩1个返回，然后将这些子序列逐层合并即可。</strong></li>
<li><strong>归并排序的时间复杂度为 $O( N\cdot log( N ) )$ 。</strong></li>
<li><strong>快速排序的最好时间复杂度为 $O( N\cdot log( N ) )$ ，最坏时间复杂度为 $O( N^{2} )$ ，平均时间复杂度为 $O( N\cdot log( N ) )$ 。</strong></li>
</ol>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>算法趣解之递归思想</title>
    <url>/2018/08/25/suan-fa-qu-jie-zhi-di-gui-si-xiang/</url>
    <content><![CDATA[<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/25/cover.jpg?raw=true" alt="cover"></p>
<p>数学上有一种运算叫做阶乘，它的计算定义如下：</p>
<p>$$<br>n ! = 1 × 2 × ··· × n ( n ≥ 1)<br>$$</p>
<p>如果，让你依据上述公式，为阶乘运算写一个函数，你会怎么实现？</p>
<p>我想大部分人会利用循环做乘法，得到阶乘结果。这种方法，我们通常称作递推实现方法。</p>
<p>其实，阶乘的运算还可以通过另一种方式实现，那就是递归实现。我们仔细观察，可以发现，原阶乘计算公式进一步可以化为</p>
<p>$$<br>\begin{aligned}<br>n ! &amp;= 1 × 2 × ··· × n \<br>      &amp;= n × (n - 1) ! \<br>      &amp;( n ≥ 1，1 ! = 1，0 ! = 1)\<br>\end{aligned}<br>$$</p>
<p>也就是说， $n$ 的阶乘可以通过 $n$ 本身和 $n – 1$ 的阶乘结果确定；更进一步， $n - 1$ 的阶乘可以通过 $n - 1$ 本身和 $n – 2$ 的阶乘结果确定···最终，这样的推导，会到求 1 的阶乘，而 1 的阶乘是 1 。这时，我们将1的结果逐层回代，最后会得到 $n$ 的阶乘。</p>
<p>上述递归阶乘算法的实现便可通过Python描述如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    factorial</span></span><br><span class="line"><span class="string">     计算一个数的阶乘</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     n：待求阶乘的整数</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     阶乘计算的结果</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"输入不能为负数。"</span>)</span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(factorial(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">24</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p>从上面的实现中，我们可以总结递归实现的两大特点：</p>
<p>第一点，       也是程序中最重要的一点，就是“自身调用自身部分”（也就是程序中的第15行）。这部分将当前求解的问题，化简为可以利用自身解决的更小的子问题（在本例中，即是将求 $n$ 的阶乘转化为 $n$ 本身和 $n – 1$ 的阶乘的乘积结果）。这部分的描述，通常是以一个公式的形式呈现，这个公式我们称作“递推公式”。</p>
<p>第二点，       为了不让递归程序陷入死循环，因而我们需要为递归程序设置一个出口。通常的实现方式是给定一个初始条件，这个初始条件使得所有递归的中间结果获得确定。（在本例中，便是对 $n$ 等于 1 或者是 0 的时候，直接给出其阶乘的结果）</p>
<p>递归程序通常看起来比较简洁，也易于理解，但是它的执行效率是极低的。我们来实际看一个例子。</p>
<p>比如，我要计算4的阶乘，上述递归实现的阶乘的计算过程是怎样的呢？</p>
<p>在描述这个过程之前，先补充一下“栈”的概念。栈，是一种数据结构。它对数据的操作只在表的一端（这个部位通常被叫做“栈顶”），并且只支持两种操作，一个是Push操作（用于将数据压入栈顶），一个是Pop操作（将栈顶的元素弹出）。</p>
<p>形象一点，你可以把栈的一个个元素想象成一个个盘子，每次的Push操作就是将盘子放在栈的顶端；而每次的Pop操作便是从栈的顶端取出一个盘子。由此可见，栈是一个“先进后出”的数据结构。</p>
<p>对于递归程序来说，为了获得最终的答案，必须要程序自己维护中间的函数状态（因为代码中并没有像循环一样明确给出）。利用什么样的结构来保存这些信息呢？我们仔细看一下递归函数的一般流程。递归的过程，通常是从待解决的问题，通过递推公式，一层一层地推到已知的初始条件的子问题；然后，在依据已知子问题的解，一层一层返回，最终得到原问题的解。这些中间状态的存取是后存的先取用，先存的后取用，这个和栈的特质完全一致，因而，可以利用栈这种数据结构来维护函数的中间状态。</p>
<p>我们利用上述栈的知识，来看一下 $factorial(4)$ 的执行过程。</p>
<p>要计算 $factorial(4)$ , 根据递推公式可以得到 $factorial(4) = 4 × factorial(3)$ 。为了计算 $factorial(3)$ ，我们先将当前的函数状态 $factorial(4)$ 压入栈中保存；</p>
<p>要计算 $factorial(3)$ , 根据递推公式可以得到 $factorial(3) = 3 × factorial(2)$ 。为了计算 $factorial(2)$ ，我们先将当前的函数状态 $factorial(3)$ 压入栈中保存；</p>
<p>···</p>
<p>以此类推，我们会到达递归的出口，也就是直接给出的factorial(1)的值。然后我们从栈中取出最近一个函数状态 $factorial(2)$ ，得到 $factorial(2)$ 等于2；再进一步得到 $factorial(3)$ 等于6， $factorial(4)$ 等于24。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/25/%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%A0%88%E7%9A%84%E7%8A%B6%E6%80%81.jpg?raw=true" alt="执行过程中栈的状态"></p>
<p>计算一个简单的4的阶乘，背后有这么多的栈的操作，看上去非常繁琐。同时，随着数据待求数字的增大，其递归层次也变得更深，而栈的空间是有限的，深层次的递归调用可能会使得栈存储不下，导致栈溢出，程序异常终止。</p>
<p>在可读性方面，递归程序的简洁十分利于理解，但在效率方面，并不如循环递推高效。那递归为什么会存在于算法思想里呢？我想除了易于理解以外，还有一点便是有些问题只能通过递归来实现（比如说“汉诺塔问题”。由于篇幅有限，这里不做讨论，大家可以自己看看）。</p>
<p>递归函数在执行过程比较特殊，对应的其时间复杂度的计算也比较特殊。以上述递归求阶乘为例，介绍一下递归函数时间复杂度的分析。</p>
<p>假设问题规模为 $N$，所需的步骤为 $T( N )$ ，根据代码第 15 行可知，乘法需要1次，递归调用 $factorial$ 需要 $T ( N -1 )$ 次；进一步则有递推公式 $T ( N ) = T ( N – 1 ) + 1$ 。</p>
<p>将此递推下去，可得 $T ( N ) = T (1) + N – 1$ 。当问题规模为1时，显然只需一步即可。所以 $T ( N ) = 1 + N – 1 = N$ ，从而时间复杂度为 $O ( N )$ 。</p>
<p>由此可见，递归函数的时间复杂度分析，可以通过寻找所需步骤的递推公式来分析。</p>
<p>在文章的最后，照例进行总结：</p>
<ol>
<li><strong>递归简单来说，便是包含有“自身调用自身”的编程实现方法。</strong></li>
<li><strong>递归函数通常分为两大部分：一是递推部分、二是初始条件。</strong></li>
<li><strong>递归的过程，通常是从待解决的问题，通过递推公式，一层一层地推到已知的初始条件的子问题；然后，在依据已知子问题的解，一层一层返回，最终得到原问题的解。</strong></li>
<li><strong>栈是一种数据结构，其特点是“先进后出”。</strong></li>
<li><strong>在计算机中，利用栈保存中间的函数状态，递归从而得以实现。</strong></li>
<li><strong>递归函数的时间复杂度分析，可以通过寻找所需步骤的递推公式来分析。</strong></li>
<li><strong>递归函数简洁，易于理解和实现，但其执行效率不如循环递推。</strong></li>
</ol>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>算法趣解之基础排序算法（下）</title>
    <url>/2018/08/20/suan-fa-qu-jie-zhi-ji-chu-pai-xu-suan-fa-xia/</url>
    <content><![CDATA[<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/20/cover.jpg?raw=true" alt="cover"></p>
<p>打牌是很多人喜欢的与亲朋好友一起娱乐的一种方式。在牌局开始，打牌的各位都要依此摸牌。与此同时，为了方便后续出牌，很多人对摸到的牌从大到小排序。这种排序手法，在算法中，被称作“插入排序”。</p>
<p>为了理解“插入排序”的主要流程，我们先来简单地回顾一下对牌排序的流程。</p>
<p>每摸一张牌，我们都会将这张牌和手上的牌依次进行对比，找到合适的位置插入，保证手上的牌是有序的。下次摸牌时，也是类似的流程。最终，手上会是一个有序的牌组。</p>
<p>将上述流程抽象概括一下，就是：每次将一个待排序的数据，在前面已排好序的子序列中从后向前扫描， 按其值大小找到适当的位置并插入其中，直到序列中的全部数据都插入完毕为止。</p>
<p>这个算法的流程在排序牌的例子中已经有了非常直观的解释，这里我们直接进入代码实现环节。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    插入排序</span></span><br><span class="line"><span class="string">     将无序的数字列表变成从小到大的数字列表返回</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     lst：待排序的列表</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     按从小到大排列的列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst)):</span><br><span class="line">        k = i<span class="comment">#保存插入的位置</span></span><br><span class="line">        tmp = lst[i]<span class="comment">#暂时保存当前待插入元素的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> lst[i] &lt; lst[j]:</span><br><span class="line">                k = j<span class="comment">#找到插入位置，保存到k中</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, k, <span class="number">-1</span>):</span><br><span class="line">            lst[j] = lst[j<span class="number">-1</span>]<span class="comment">#将列表中相关数据移位，方便元素插入</span></span><br><span class="line"></span><br><span class="line">        lst[k] = tmp<span class="comment">#插入元素</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">"第&#123;&#125;次排序结果:"</span>.format(i+<span class="number">1</span>),lst)<span class="comment">#print(lst)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试例程</span></span><br><span class="line">lst = [<span class="number">89</span>, <span class="number">43</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"最终结果"</span>,insert_sort(lst))</span><br><span class="line">        </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出结果:</span></span><br><span class="line"><span class="string">第1次排序结果: [89, 43, 88, 87, 61]</span></span><br><span class="line"><span class="string">第2次排序结果: [43, 89, 88, 87, 61]</span></span><br><span class="line"><span class="string">第3次排序结果: [43, 88, 89, 87, 61]</span></span><br><span class="line"><span class="string">第4次排序结果: [43, 87, 88, 89, 61]</span></span><br><span class="line"><span class="string">第5次排序结果: [43, 61, 87, 88, 89]</span></span><br><span class="line"><span class="string">最终结果 [43, 61, 87, 88, 89]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p>假设待排序的数据量为 $N$ ，依据上述插入排序算法，外层循环将执行 $N$ 次，内层循环依据外层循环次数 $i$ 将执行 $i$ 次（将两个内层循环次数相加即可）。所以该算法至多执行<br>$$<br>\begin{aligned}<br>&amp;\ \ \ \ \ 1+2+3+ ··· +N-1\<br>&amp;= (N-1)(1 + N – 1)/2\<br>&amp;= N(N-1)/2<br>\end{aligned}<br>$$<br>次。所以插入排序的时间复杂度为 $O(N^{2})$ 。</p>
<p>插入排序算法在时间性能上来说，表现得并不理想。能不能对他进行优化呢？希尔（Donald Shell）提出了他对该算法的改进。这个算法描述如下：</p>
<blockquote>
<p>取一个小于 $n$ 的整数 $d_{1}$ 作为第一个增量， 把序列中的全部数据分成 $d_{1}$ 个组。 所有距离为 $d_{1}$ 的倍数的数据放在同一个组中；</p>
<p>$n$ 在各组内进行直接插入排序；</p>
<p>$n$  取第二个增量 $d_{2} &lt; d_{1}$ ， 重复上述的分组和排序， 直至所取的增量 $d_{t}=1(d_{t}&lt; …&lt;d_{2}&lt;d_{1})$ ， 即所有数据都放在同一组中进行直接插入排序为止。</p>
</blockquote>
<p>所以这个算法本质是一种分组插入排序。除了插入排序的思想，更关键的是算法中增量序列d的确定。</p>
<p>有一种增量叫做Hibbard增量，其表达式如下：</p>
<p>$$<br>h_{i} = 2^{i} - 1<br>$$</p>
<p>它可以使希尔排序的时间复杂度降低到 $O(N^{\frac{3}{2}})$ 。</p>
<p>我们以这种增量序列生成方式来实现一下希尔排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参考：https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin#7_8</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_insert</span><span class="params">(lst,dk)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    shell_insert:</span></span><br><span class="line"><span class="string">     按照增量dk，对lst中的元素进行分组插入排序</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     lst：存储待排序的数据列表</span></span><br><span class="line"><span class="string">     dk:增量</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     分组排序后的数据列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(dk,len(lst)):</span><br><span class="line">        tmp = lst[i]</span><br><span class="line">        m = i - dk</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i-dk, -dk<span class="number">-1</span>,-dk):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span>(j &gt;= i%dk <span class="keyword">and</span> lst[j] &gt; tmp):</span><br><span class="line">                m = j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            lst[j+dk] = lst[j]</span><br><span class="line">        <span class="keyword">if</span> m != i - dk:</span><br><span class="line">            lst[m+dk] = tmp</span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dkHibbard</span><span class="params">(t, k)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    dkHibbard:</span></span><br><span class="line"><span class="string">     按照Hibbard增量生成方式生成增量</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     t：排序的总趟数</span></span><br><span class="line"><span class="string">     k：当前排序的趟数</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     当前趟数的Hibbard增量</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> (int)(math.pow(<span class="number">2</span>,t-k+<span class="number">1</span>)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(lst, t)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序：</span></span><br><span class="line"><span class="string">     对无序的数据列表排序，使之从小到大排列</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     lst：待排序的数据列表</span></span><br><span class="line"><span class="string">     t：排序当前数据列表的总趟数</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     从小到大排序的数据列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, t+<span class="number">1</span>):</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">"第&#123;&#125;次排序前序列:"</span>.format(i),lst)</span><br><span class="line">        lst = shell_insert(lst, dkHibbard(t, i))</span><br><span class="line">        print(<span class="string">"第&#123;&#125;次排序使用的增量&#123;&#125;"</span>.format(i,dkHibbard(t, i)))</span><br><span class="line">        print(<span class="string">"第&#123;&#125;次排序结果:"</span>.format(i),lst)</span><br><span class="line">        print()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        dk = (int)(math.pow(2,t-i+1)-1)</span></span><br><span class="line"><span class="string">        print("第&#123;&#125;次排序前序列:".format(i),lst)</span></span><br><span class="line"><span class="string">        print("第&#123;&#125;次排序使用的增量&#123;&#125;".format(i,dk))</span></span><br><span class="line"><span class="string">        for j in range(dk,len(lst)):</span></span><br><span class="line"><span class="string">            tmp = lst[j]</span></span><br><span class="line"><span class="string">            m = j - dk</span></span><br><span class="line"><span class="string">            for k in range(j-dk, -dk-1,-dk):</span></span><br><span class="line"><span class="string">                if not(k &gt;= j%dk and lst[k] &gt; tmp):</span></span><br><span class="line"><span class="string">                    m = k</span></span><br><span class="line"><span class="string">                    break</span></span><br><span class="line"><span class="string">                lst[k+dk] = lst[k]</span></span><br><span class="line"><span class="string">            if m != j - dk:</span></span><br><span class="line"><span class="string">                lst[m+dk] = tmp</span></span><br><span class="line"><span class="string">        print("第&#123;&#125;次排序结果:".format(i),lst)</span></span><br><span class="line"><span class="string">        print()</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序趟数等于log2(待排序的数据量大小 + 1)取整</span></span><br><span class="line">print(shell_sort([<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>, <span class="number">99</span>],(int)(math.log2(<span class="number">10</span>+<span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">第1次排序前序列: [84, 83, 88, 87, 61, 50, 70, 60, 80, 99]</span></span><br><span class="line"><span class="string">第1次排序使用的增量7</span></span><br><span class="line"><span class="string">第1次排序结果: [60, 80, 88, 87, 61, 50, 70, 84, 83, 99]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第2次排序前序列: [60, 80, 88, 87, 61, 50, 70, 84, 83, 99]</span></span><br><span class="line"><span class="string">第2次排序使用的增量3</span></span><br><span class="line"><span class="string">第2次排序结果: [60, 61, 50, 70, 80, 83, 87, 84, 88, 99]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第3次排序前序列: [60, 61, 50, 70, 80, 83, 87, 84, 88, 99]</span></span><br><span class="line"><span class="string">第3次排序使用的增量1</span></span><br><span class="line"><span class="string">第3次排序结果: [50, 60, 61, 70, 80, 83, 84, 87, 88, 99]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[50, 60, 61, 70, 80, 83, 84, 87, 88, 99]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p>大家可以对照上述程序的执行过程来体会希尔排序的排序流程。在实现希尔排序的过程中，默认采用了函数嵌套的写法。同时，我也写了不用函数嵌套的写法。（将50<del>54注释，将56</del>72行取消注释，即是不用函数嵌套的写法）。</p>
<p>在文章的最后，照例进行总结：</p>
<ol>
<li><strong>插入排序的主要流程：每次将一个待排序的数据，在前面已排好序的子序列中从后向前扫描，按其值大小找到适当的位置并插入其中，直到序列中的全部数据都插入完毕为止。</strong></li>
<li><strong>插入排序的时间复杂度为 $O(N^{2})$ 。</strong></li>
<li><strong>一种插入排序的改进算法，希尔排序，本质是一种分组排序方法。</strong></li>
<li><strong>利用Hibbard增量生成希尔排序中需要的增量序列，可以使得其时间复杂度变为 $O(N^{\frac{3}{2}})$ 。</strong></li>
</ol>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>算法趣解之基础排序算法（中）</title>
    <url>/2018/08/14/suan-fa-qu-jie-zhi-ji-chu-pai-xu-suan-fa-zhong/</url>
    <content><![CDATA[<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/14/cover.jpg?raw=true" alt="cover"></p>
<p>说起音乐，很多人都喜欢。大多数人的手机中几乎都至少有一款音乐app，这些app除了给你提供音乐播放的功能，也在悄悄记录着你的一些个性化信息。比如：某首歌你听了多少次、听歌在什么时候等等。这些数据杂乱无章，似乎没有任何价值，但是其中却深藏着你的喜好厌恶。在当今手机用户增长缓慢（甚至增长停滞）的阶段，各大同类型的app面临着非常激烈的竞争。不抓住这些用户数据，可能就会在这场残酷的竞争中败下阵来。</p>
<p>如何利用这些数据来留住留住用户，提升用户在产品上的粘性呢？很多app给出了如下的答卷：</p>
<p>这种方案便是基于用户的行为数据构建用户的标签，依据各种标签的综合，提供个性化的服务。</p>
<p>回到我们的音乐软件，如何利用音乐软件记录的用户行为数据来构建用户标签呢？我们先从简单的一方面——分析你对你听过的歌曲的喜爱程度——入手，其他方面可以类比解决。</p>
<p>首先，我们要量化“对歌曲的喜爱程度” 这个属性。我们做如下简单的规定（实际情况可能没这么简单）：对于一首歌的喜爱程度由用户听这首歌的次数决定，次数越多，说明喜爱程度越高。其次，尝试找到该用户前几个喜欢的歌曲，对这些歌曲的属性进行分析，寻找相似性，得到综合的标签，标记给这位用户。最后，依据这些标签做相似性推荐即可。</p>
<p>这个流程中关键的问题之一，便是依据听歌的次数找到用户最喜欢的几首歌（其他关键性问题这里不做讨论，不能偏题）。原本的数据是无序的，为了解决这个问题，我们就需要对数据进行排序。</p>
<p>之前的文章中，我们已经学会了利用冒泡排序，对一个无序的序列进行排序。那么还有没有其他的排序方法呢？</p>
<p>当然有，且听我慢慢道来。</p>
<p>一种可行的方法如下：</p>
<p>在所有用户听过的歌曲中，选择一个听的次数最多的，放在新开辟的一个序列的第一个位置；</p>
<p>在剩下的歌曲中，找到次数最大的的歌曲，放在第二个位置；</p>
<p>···（其他以此类推，直到整个序列有序）</p>
<p>这种方法的流程可以这样概括：在待比较的序列中，找到最大的，依此放到有序序列的末尾。循环上述操作，直至整个序列有序。</p>
<p>上述方法，我们可以很容易发现，需要两倍于数据容量大小的空间（一个用于存储原始的无序序列，另一个用于保存排序后的结果），这样做，对于空间的来说，是十分浪费的。可以将使用空间进行缩减吗？当然可以。我们可以将找到的最 $i$ 大的数据和序列中第 $i$ 个元素交换即可。</p>
<p>所以，改进后的流程可以这样概括：在剩余的待比较的数中选择一个最大的数与这个剩余序列的第1 个数交换位置。循环上述操作，直至整个序列有序。</p>
<p>这样的“选择”“交换”的排序算法，我们称它为“选择排序”。</p>
<p>由于这个算法流程比较简单，我们结合代码来观察一下它的排序过程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max</span><span class="params">(lst,start)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    find_max:</span></span><br><span class="line"><span class="string">     寻找列表从下标start开始的后续元素中最大值的下标</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     lst：待寻找的列表</span></span><br><span class="line"><span class="string">     start：开始搜索的下标</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     start下标后续元素最大值的下标</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    max_index = start</span><br><span class="line">    max_elem = lst[max_index]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start + <span class="number">1</span>, len(lst)):</span><br><span class="line">        <span class="keyword">if</span> lst[i] &gt; max_elem:</span><br><span class="line">            max_index = i</span><br><span class="line">            max_elem = lst[i]</span><br><span class="line">    <span class="keyword">return</span> max_index</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序：</span></span><br><span class="line"><span class="string">     将一个无序的列表变成一个从大到小的列表</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">     lst：待排序的列表</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">     排好序的列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst)):</span><br><span class="line">        max_index = find_max(lst,i)</span><br><span class="line">        lst[i], lst[max_index] = lst[max_index], lst[i]</span><br><span class="line">        print(<span class="string">"第&#123;&#125;次排序结果:"</span>.format(i+<span class="number">1</span>),lst)</span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试例子</span></span><br><span class="line"><span class="keyword">print</span> (selection_sort([<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">67</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">第1次排序结果: [88, 83, 84, 87, 67]</span></span><br><span class="line"><span class="string">第2次排序结果: [88, 87, 84, 83, 67]</span></span><br><span class="line"><span class="string">第3次排序结果: [88, 87, 84, 83, 67]</span></span><br><span class="line"><span class="string">第4次排序结果: [88, 87, 84, 83, 67]</span></span><br><span class="line"><span class="string">第5次排序结果: [88, 87, 84, 83, 67]</span></span><br><span class="line"><span class="string">[88, 87, 84, 83, 67]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p>选择排序的排序流程在上述输出结果中已有体现，这里留给大家观察思考，我不过多分析。</p>
<p>在实际实现选择排序这个算法时，我没有像传统的方式一样，将“选择”和“交换”写在一个函数里面；而是将“选择”和“交换”分开，先实现“选择”（即上面代码中的 find_max函数），在排序算法中调用，然后实现交换，并循环完成排序。这样做（称作“函数嵌套”），有优有劣。一方面，可以使算法的主要函数（如本例的selection_sort）的逻辑比较清晰，容易理解（这就像你写程序时，main函数写的非常简洁，只是调用了相关函数一样）；同时，子问题模块化（如本例的find_max），方便别的地方调用。另一方面，当代码量比较庞大时，可能会存在多层函数嵌套，这对于理解完整的实现细节流程无疑增加了难度。希望大家在这一方面，自己做好权衡。</p>
<p>这个算法的性能如何呢？其效率不是很高，时间复杂度为 $O ( N^{2} )$ 。具体的推算流程留给大家思考。</p>
<p>好了，在文章的最后，照例进行今天的总结：</p>
<ol>
<li><p><strong>排序操作其实是一种朴素的数据信息分析的手段：将无序的数据转换成有序的序列，也许就会发现潜在于数据中的价值。</strong></p>
</li>
<li><p><strong>选择排序算法的核心思想：在剩余的待比较的数中选择一个最大的数与这个剩余序列的第1个数交换位置。循环上述操作，直至整个序列有序（降序情况）。</strong></p>
<p><strong>P.S.升序情况也可类似实现</strong></p>
</li>
<li><p>*<em>选择排序的时间复杂度为 $O ( N^{2} )$ *</em></p>
</li>
<li><p><strong>函数嵌套作为一种实现手段，有优有劣，需要大家做好权衡</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>算法趣解之基础排序算法（上）</title>
    <url>/2018/08/09/suan-fa-qu-jie-zhi-ji-chu-pai-xu-suan-fa-shang/</url>
    <content><![CDATA[<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/09/cover.jpg?raw=true" alt="cover"></p>
<p><a href="https://cosmosning.github.io/2018/08/02/%E7%AE%97%E6%B3%95%E8%B6%A3%E8%A7%A3%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">之前的文章</a>中提到的二分查找算法中要求数据序列是有序的。然而，生活中的很多数据却是无序的。将无序转换为有序，这就需要排序算法。今天，我们就来一起探索一下几种常见的基础排序算法。</p>
<p>很多基础的排序算法都来源于实际生活中对于某些特定的问题情境的抽象、提炼和总结。你不信？我们一起来分析一下几个例子。</p>
<p>还记得很小的时候，上体育课时，体育老师是如何把你们从高到矮排队吗？老师先目测大家的身高，排出一个基本有序的队伍。然后，依据相邻同学的身高对比，再进行微调。调整的标准如下：</p>
<p>如果相邻两位同学的身高排序不符合当前队伍的高矮要求，那么交换这两个同学的位置；否则，不做调整。</p>
<p>将队伍中相邻的同学都做如上所述的调整，那么同学们就可以排成一个有序的队伍了。</p>
<p>这种排序方法的关键点，我相信大家可以很容易发现，即：比较相邻的两个数据，若顺序不对， 则将其位置交换。</p>
<p>那么这种方法如何交由计算机来实现呢？在从实际方法到计算机实现的过程中，我们经常会遇到一个困难，即，在具体情境下的处理流程不能直接拿来就用。这就需要我们做一定的转化。比如本例，老师可以先目测，排出基本有序的队伍，而计算机不会目测。如何解决这个问题呢？利用计算机可以机械地、重复地处理一些基本运算的特性，我们将每一种相邻的情况枚举出来，再判断处理，就可以实现这个排序方法。</p>
<p>有关这种排序方法的处理流程，我们通过一个具体的数字排序例子来感受一下。</p>
<p>比如有一个无序数字序列如下：</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/09/1.jpg?raw=true" alt="无序序列"></p>
<p>我们要使用上述的排序方法，使之从小到大排列。</p>
<p>我们从头开始对数据进行对比处理。</p>
<p>①对比第1个和第2个数据，第2个数据较小，因而需要交换。交换后的序列如下</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/09/2.jpg?raw=true" alt="交换1"></p>
<p>②对比第2个和第3个数据，两个数据排列符合排序要求，因而不需要交换。此次处理后的序列如下：</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/09/3.jpg?raw=true" alt="交换2"></p>
<p>③同样的方式处理，可以得到以下序列 </p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/09/4.jpg?raw=true" alt="交换3"></p>
<p>（P.S.87和88比较，顺序符合要求，不交换）</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/09/5.jpg?raw=true" alt="交换4"></p>
<p>（P.S.88和61比较，不符合顺序要求，交换）</p>
<p>经过这一轮的排序，我们发现序列中的最大值已经达到目标位置，但是整个序列还不是有序的。如何解决呢？可以仿照这一轮的排序对之前无序的序列做同样的操作。</p>
<p>第二轮的排序每次的序列如下所示：</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/09/6.jpg?raw=true" alt="交换5"></p>
<p>（P.S.83和84比较，顺序符合要求，不交换） </p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/09/7.jpg?raw=true" alt="交换6"></p>
<p>（P.S.84和87比较，顺序符合要求，不交换）</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/09/8.jpg?raw=true" alt="交换7"></p>
<p>（P.S.87和61比较，不符合顺序要求，交换）</p>
<p>经过这一轮的排序，次大值也到了目标位置。</p>
<p>第三轮：</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/09/9.jpg?raw=true" alt="交换8"></p>
<p>（P.S.83和84比较，顺序符合要求，不交换）</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/09/10.jpg?raw=true" alt="交换9"></p>
<p>（P.S.84和61比较，不符合顺序要求，交换）</p>
<p>第四轮</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/09/11.jpg?raw=true" alt="交换10"></p>
<p>（P.S.83和61比较，不符合顺序要求，交换）</p>
<p>通过上面这个实际的例子，我们发现，每一轮排序都会在前面无序的序列中通过交换相邻数字的方式找到其中的最大值，和后面的数字形成一个有序的部分。这个过程就像水中的一个气泡，从底端慢慢的飘升到水面的过程，所以我们将这种排序算法成为“冒泡排序”。</p>
<p>到了实现环节，就需要选择合适的存储结构，并利用三种基本的程序结构来描述这个算法的流程。</p>
<p>由于排序过程中涉及到交换，链表中的数据位置交换比较复杂，为了简单起见，我们利用数组来实现。算法流程中的很多次的比较可以通过循环加上分支来描述。</p>
<p>因而，有如下的Python代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    冒泡排序：</span></span><br><span class="line"><span class="string">      将一个无序的数据列表lst转换为从小到大的返回</span></span><br><span class="line"><span class="string">     参数：</span></span><br><span class="line"><span class="string">      lst：待排序的数据列表</span></span><br><span class="line"><span class="string">     返回：</span></span><br><span class="line"><span class="string">      排好序的数据列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst)):                          <span class="comment">#排序轮数</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(lst) - i - <span class="number">1</span>):              <span class="comment">#每一轮的排序次数</span></span><br><span class="line">            <span class="keyword">if</span> lst[j] &gt; lst[j+<span class="number">1</span>]:</span><br><span class="line">                lst[j],lst[j+<span class="number">1</span>] = lst[j+<span class="number">1</span>],lst[j]      <span class="comment">#这里交换相邻的数据，用到了python中的特殊写法。具体可以百度"python a,b=b,a"</span></span><br><span class="line">            print(<span class="string">"第&#123;&#125;轮第&#123;&#125;次排序后结果："</span>.format(i+<span class="number">1</span>, j+<span class="number">1</span>))</span><br><span class="line">            print(lst)</span><br><span class="line">            print()                                    <span class="comment">#打印空行</span></span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"调用函数:"</span>,bubble_sort(lst))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">第1轮第1次排序后结果：</span></span><br><span class="line"><span class="string">[83, 84, 88, 87, 61]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第1轮第2次排序后结果：</span></span><br><span class="line"><span class="string">[83, 84, 88, 87, 61]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第1轮第3次排序后结果：</span></span><br><span class="line"><span class="string">[83, 84, 87, 88, 61]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第1轮第4次排序后结果：</span></span><br><span class="line"><span class="string">[83, 84, 87, 61, 88]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第2轮第1次排序后结果：</span></span><br><span class="line"><span class="string">[83, 84, 87, 61, 88]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第2轮第2次排序后结果：</span></span><br><span class="line"><span class="string">[83, 84, 87, 61, 88]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第2轮第3次排序后结果：</span></span><br><span class="line"><span class="string">[83, 84, 61, 87, 88]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第3轮第1次排序后结果：</span></span><br><span class="line"><span class="string">[83, 84, 61, 87, 88]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第3轮第2次排序后结果：</span></span><br><span class="line"><span class="string">[83, 61, 84, 87, 88]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第4轮第1次排序后结果：</span></span><br><span class="line"><span class="string">[61, 83, 84, 87, 88]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">调用函数: [61, 83, 84, 87, 88]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p>最后，我们简单地评价一下这个算法的性能。在上面一个具体的算法流程中，我们可以发现如下的规律：</p>
<p>对于一个含有 $N$ 个数据元素的序列，它需要进行 $N – 1$ 轮比较，每一轮（记轮数为 $i$ ，从1开始计数）比较中又需要比较 $N – i$ 次比较。所以，一个完整的“冒泡排序”过程总共需要</p>
<p>$$<br>\begin{aligned}<br>&amp;\ \ \ \ \  ( N - 1 ) + ( N - 2 ) + ··· + 1\<br>&amp;=\frac{( N - 1 )( N - 1 + 1 )}{2}\<br>&amp;= \frac{N(N - 1)}{2}<br>\end{aligned}<br>$$</p>
<p>次比较。所以“冒泡排序”算法的时间复杂度为 $O(N^{2})$ 。</p>
<p>好了，今天就到这里。让我们简单回顾一下本文的要点：</p>
<ol>
<li><strong>冒泡排序算法的核心思想：比较相邻的两个数据，若顺序不对，则将其位置交换。</strong></li>
<li><strong>冒泡排序的时间复杂度为 $O ( N^{2} )$ 。</strong></li>
</ol>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>还只会用数组？你快被Out啦</title>
    <url>/2018/08/04/huan-zhi-hui-yong-shu-zu-ni-kuai-bei-out-la/</url>
    <content><![CDATA[<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/04/cover.jpg?raw=true" alt="cover"></p>
<p>上一篇文章中，我们一起探索了二分查找算法。（什么？你没看到？快戳<a href="https://cosmosning.github.io/2018/08/02/%E7%AE%97%E6%B3%95%E8%B6%A3%E8%A7%A3%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#more">本链接</a>去看一看）在算法的实现过程中，我们选择了数组作为存储算法中相关数据的载体。那样的选择合适吗？能否将它换为其他的存储结构实现？如果换作其他的存储结构，算法的效率又会如何？今天，我们就来一起探索一下。</p>
<p>熟悉数组的人都知道，数组在计算机内存中是连续存储的。具体如下图所示：</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/04/%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%A4%BA%E4%BE%8B.jpg?raw=true" alt="数组在内存中的存储示例"></p>
<p>实际运用中，数组由于是连续存储，我们可以很方便的通过数组下标来访问数组中的任意一个元素（这样的访问方式，给它一个高级一点的名字就叫做“随机访问”【Random access】）。举个例子，假设数组起始地址为 $a$ ，待访问的数据下标为 $i$ 【注意，下标从 0 开始】，存储每一个数据所需的空间大小为 $m$ ，那么该数据在内存中的地址可以由下式给出：</p>
<p>$$<br>a ＋ i × m<br>$$</p>
<p>观察这个式子，进一步，我们可以发现：该式中并不含表示数组容量大小的因子。换句话说，访问数组中的任意元素与数组的容量大小无关。无论数组的容量有多大，只需知道数据在数组中的下标，我们就可以很容易的通过上式在常数时间内获取数组中的对应的数据。用“大O”来描述在数组中访问任意一个数据的时间复杂度，就是  $O(1)$  。（这里的“1”的含义不是指常数时间等于 1 ，而是用 1 来代表常数时间）。</p>
<p>在很多程序和算法中，都要求数据的存储结构能够提供这样的方便的“随机访问”的功能，这也就是数组在日常编程中经常使用的原因。</p>
<p>但是，数组真的完美无缺吗？</p>
<p>我们尝试换一个角度来看待数组。一般来说，评价一个存储结构，不仅仅要考虑它访问其内部元素的性能，也要从，增添、插入、删除等几个方面来综合考虑。</p>
<p>首先，我们来看看增添的情况。</p>
<p>下图中，数组b中有10个元素。如果增添一个元素，新元素会被放在其当前末尾元素的后一个空闲空间内，此时增添成功（但是我不建议这么做）。</p>
<p>我们再来看看数组a。数组a有4个元素，要增加一个元素的话，需要在其末尾的后一个空间内存储新数据。但是这个空间暂时被其他程序占用了，无法增加新数据。怎么办？</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/04/%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%A4%BA%E4%BE%8B.jpg?raw=true" alt="数组在内存中的存储示例"></p>
<p>方法1，将新数据放在之后的任意一个空闲空间内。如果这样做，就会导致数组的随机访问特性遭到破环。也就是说，你将无法通过数组下标来获取新增数据的值。</p>
<p>方法2，重新申请一片包含连续5个空闲空间的内存区域，将原来的数组和新增数据复制过来，完成后再释放原空间。这看似是一个比较好的解决方案，但是考虑一个极端情况，如果内存中不存在这样的连续的5个存储空间，那么就无法向数组中增添新的元素。</p>
<p>那究竟怎么解决呢？通常的编程惯例，我们会申请足够大的数组空间来处理。比如我们大约需要50个存储空间，我们可以定义的时候申请60个、70个甚至更多，从而留下向数组增添数据的的空间。不过，这样的方法自然免不了对空间的浪费。</p>
<p>其次，让我们来看一看数组的插入。如果要将数据插入到数组中间的某一位置，那么为了避免新数据将旧数据覆盖，则需要插入位置及其之后的元素统一向后移动一位。移动一位这个操作，在数据量小的时候几乎微不足道，但是当数据量过于庞大时，却是一件极其巨大的工作。除此以外，如果数组已满，那么又要重新申请空间，复制，插入，无疑降低了处理效率。</p>
<p>最后，一起来看看数组中的删除。为了保证数组可“随机访问”的特性，将数据从数组中删除这个操作也需要移动元素。这里移动元素虽说不可能出现“数组已满，需重新申请空间”的情况，但移动元素总会花费时间。</p>
<p>综合以上几点，数组并不是完美无缺的，它也存在缺点，比如在数组空间已满时，增添元素可能会操作失败；插入和删除都需要移动元素，且所花费的时间会随着数组的大小线性增长（用“大O”来描述其时间复杂度便是 $O(N)$  ）。</p>
<p>针对的这些问题，有人便设计出链表这个新的存储结构。与数组不同，链表是分散存储的，从而可以充分利用内存中“碎片化”的存储区域。链表中的数据分散在内存中不同的地方，如何将他们联系起来呢？设计者给出如下的方案：</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/04/%E9%93%BE%E8%A1%A8%E7%A4%BA%E4%BE%8B.jpg?raw=true" alt="链表示例"></p>
<p>每一个链表的元素单元除了存储的数据本身，再开辟一个空间用于存储下一个元素单元的地址，从而将他们连成一个整体。这也是“链表”名字的由来。</p>
<p>接下来，我们和对数组的分析一样，对链表的读取、增添、插入、删除做一个简单的分析。</p>
<p>首先，是对链表任意元素的访问。链表是分散存储的，每一个元素单元的地址由它上一个元素单元决定。因而，链表对元素的访问只能从第一个开始，逐一访问。这就给访问链表中的任意元素造成了极大的困难。随着链表规模的增大，其访问时间也在线性增长，所以链表访问任意一个元素的时间复杂度为 $O ( N )$ 。</p>
<p>其次，我们来看一看链表的增添操作。增添操作对于链表来说，十分简单。只需申请一个元素单元节点，将此节点的地址与链表末尾节点连接起来即可，无论链表规模有多大，该操作都在常数时间内完成，因而链表增添操作的时间复杂度为 $O(1)$ 。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/04/%E9%93%BE%E8%A1%A8%E5%A2%9E%E6%B7%BB%E7%A4%BA%E4%BE%8B.jpg?raw=true" alt="链表增添示例"></p>
<p>接着，我们来分析一下链表的插入操作。相较于数组，链表的插入不需要移动元素，只需申请一个新节点，将它和待插入位置的前后节点连接起来即可。其操作时间也是常数时间，时间复杂度也就是 $O(1)$ 。 </p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/04/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E7%A4%BA%E4%BE%8B.jpg?raw=true" alt="链表插入示例"></p>
<p>最后，便是对链表的删除的分析。想要删除一个元素，只需将它前一个节点和待删除节点连接起来，再将该元素节点空间释放即可。其时间复杂度为 $O(1)$ 。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/04/%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E7%A4%BA%E4%BE%8B.jpg?raw=true" alt="链表删除示例"></p>
<p>通过以上的探索，我们发现数组和链表各有优劣。那么，究竟如何选取合适的存储结构呢？我认为，要关注问题中对数据存储的要求，选择能发挥存储结构最大优势的那一个。比如，你的程序需要大量的随机访问一个集合中的元素，那么选择数组就OK；如果你的程序存在大量的插入、删除，那么链表会很有效率。</p>
<p>然而，现实中的问题都不是那么理想化。对数据的存储结构，既要求它能够提供随机访问的功能，又要在插入、删除方面具有极高的效率。有人为了解决这个问题，给出如下的数组和链表的混合结构。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/04/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E6%B7%B7%E5%90%88%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg?raw=true" alt="数组链表混合结构"></p>
<p>尝试自己分析一下这种存储结构在插入、删除、随机访问等方面的效率，看看它是否比数组和链表更加优异。</p>
<p>在文章的最后，我们按照惯例，将本文的要点总结一下：</p>
<ol>
<li><strong>数组作为一种存储结构，提供了随机访问的功能，可以方便地、快速地通过数组下标访问数组中任意的元素。但是，数组并不是完美无缺的，它在很多方面（增加、插入、删除）表现的并不理想。</strong></li>
<li><strong>为了解决数组在实际应用中存在的问题，链表应运而生。链表在增加、插入、删除方面表现的非常优秀，但在访问其中的元素的情况下，表现的并不出色。</strong></li>
<li><strong>对比存储结构的方式可以从随机访问、插入、删除等方面分析</strong></li>
<li><strong>选择合适的存储结构，关键是在运用到某一情境时，该存储结构的优点能够最大化。</strong></li>
<li><strong>尝试将基本的存储结构混合（这种结构称作混合结构【Hybird Structure】），各自取长补短，也许会达到一个比较好的效果。</strong></li>
<li><strong>数组和链表在几种情况下的时间复杂度对比：</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">数组</th>
<th align="center">链表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">访问</td>
<td align="center">O（1）</td>
<td align="center">O（N）</td>
</tr>
<tr>
<td align="center">插入</td>
<td align="center">O（N）</td>
<td align="center">O（1）</td>
</tr>
<tr>
<td align="center">删除</td>
<td align="center">O（N）</td>
<td align="center">O（1）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>算法趣解之二分查找</title>
    <url>/2018/08/02/suan-fa-qu-jie-zhi-er-fen-cha-zhao/</url>
    <content><![CDATA[<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/02/cover.jpg?raw=true" alt="cover"></p>
<p>在正式开始之前，我们先尝试来玩一个猜数游戏。游戏规则如下：</p>
<blockquote>
<p>游戏裁判会指定一个从小到大的数字范围，并从中抽取一个作为猜数的正确结果。参与游戏者在分隔的状态下开始猜数。他们的每一次猜数，游戏裁判会分别告知其所猜之数是大了还是小了。最终猜数次数少者获胜。</p>
</blockquote>
<p>为了获胜你会采取什么样的猜数策略呢？</p>
<p>第一种，随缘猜数。在脑中随便想一个数，猜中了都是缘分。</p>
<p>第二种，顺序猜数。从第一个数开始，一个数一个数地尝试，直到猜到最终结果。</p>
<p>第三种，折半猜数。每次猜数，都从数据范围的中间开始猜，依据裁判给出的反馈，丢掉不满足要求的一半。剩下的范围便作为下次猜数的参考。</p>
<p>我想，你看了这三种方法，应该会觉得第三种方法相较于另外两种算法靠谱一点，会选择第三种猜数策略。</p>
<p>拥有这种感觉，这非常棒！但是，个人感觉这种东西有时候不太好描述和形容，同时在与他人交流时也没有说服力。那么有什么好的方法来明确这种感受和并且证明你这种正确的感受呢？</p>
<p>让我们回到游戏本身，再此仔细阅读一下游戏规则：</p>
<p>游戏裁判会指定一个从小到大的数字范围，并从中抽取一个作为猜数的正确结果。参与游戏者在分隔的状态下开始猜数。他们的每一次猜数，游戏裁判会分别告知其所猜之数是大了还是小了。最终猜数次数少者获胜。</p>
<p>你会注意到，游戏本身已经给出来了评价的具体方式，这便是对比每一个人的猜数次数。</p>
<p>我们依照这种标准对三种策略来分析一下。</p>
<p>第一种，欧皇方式的猜数，含有大量的随机因素，猜数的次数不稳定。（这样猜数一点都不靠谱！）</p>
<p>第二种，如果正确答案是给定范围的第一个数，那么猜数次数只需一次；但如果正确答案是最后一个数，那么要遍历整个数据范围，才能猜到正确的数。平均下来，也要猜数次数也需要数据范围的一半的数据个数。（这多累啊···）</p>
<p>第三种，如果正确答案是给定范围的中间的数，那么很幸运，只需一次便可；如果正确答案是第一个或是最后一个数，那可能就会就会需要很多次。这里的很多次究竟是几次呢？这里我们一起研究一个具体的例子，来找找规律。</p>
<p>比如有一组数为从 1 开始，一直到 10 的 10 个整数，假定猜数的正确答案是 1 ，我们利用折半猜数的策略来分析一下：</p>
<p>第一次猜数，猜 5 ，</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/02/1.jpg?raw=true" alt="第一次猜数"></p>
<p>答案大了，数据范围切掉一半，剩下 1 ~ 4 ；</p>
<p>第二次猜数，猜 2，</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/02/2.jpg?raw=true" alt="第二次猜数"></p>
<p>答案大了，数据切掉一半，只剩下 1 ；</p>
<p>第三次猜数，猜 1 ，</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/08/02/3.jpg?raw=true" alt="第三次猜数"></p>
<p>答案正确，游戏结束。</p>
<p>如果将正确答案换作 10 ，上述过程又会怎样？推荐大家自己动手尝试一下，这里我不再讨论。在这种情况下，猜数次数为 4 次。</p>
<p>上述分析，我们很容易看到，10 个数据中猜一个数最多需要 3 ~ 4 次。这 3 和 4 究竟和 10 有什么关系呢？如果对数字敏感的同学一定会发现：log2(10) 约为 3.32 ，而这个数在 3 和 4 之间！</p>
<p>恭喜！这个发现是正确的！</p>
<p>这样想究竟有没有它的道理呢？在这里，不妨回顾一下log函数的含义。不用担心，这里不会提及太多数学上枯燥的定义，还请你耐心的看下去。结合本篇中的猜数游戏，我分享一下我对log的理解。</p>
<p>log2(10) 约为 3.32 ，也就是说连续的 2 相乘，需要 3.32 次，才能得到 10（前 3 个 2 相乘得到 8 ，最后一次相乘并不是乘的 2，而是比 2 小一点的数）。那么结合我们的猜数策略，每次折半猜数，以 2 为底数的 log 函数的含义便是将数据范围每次截取一半（截取到只剩一个数为止），最多能截取的次数。（脱离这个问题本身，我也推荐大家以此为引子，思考如果是以 3 为底数，log 函数又是什么意思。 4 、 5 或是其他数作为底数是否会呈现类似的规律。欢迎大家在公众号主页给我留言、和我一起探讨）</p>
<p>让我们再次回到之前对第三种猜数策略的分析，假设数据量为 N ，那么最多的猜数次数为 log2(N) 。结合只需猜 1 次就猜中的最好的情况，平均的猜数次数为 (1+ log2(N))/2 。</p>
<p>经过对三种情况的分析，仔细的你会发现，分析的时候，都会考虑到猜数次数的最好情况、最坏情况和平均情况，这对于一个思维策略来说是一个全方位的评价，他们之间的优劣也显而易见了。</p>
<p>其实，这样的表述还存在一点小瑕疵，就是书写不简洁。因而，那些追求简洁的理论家提出了“大O理论”来简化这里的书写。比如之前的顺序猜数，其简化写法为 O（N）；折半猜数，其简化写法为 O(log N) 。细心观察，你会发现，这里的“大O”都是在描述最坏情况下的次数，而且不计较一些常数（为什么常数会被丢弃？因为当数据量十分巨大时，这些常数对原式的影响非常少）。此外，还要注意一点，这里的“大O”只在讨论处理时间（我们称之为“时间复杂度”），用于存储数据的空间也可以类似的讨论（“空间复杂度”了解一下？）。</p>
<p>在这个具体的游戏中，我们一起探索并且找到了比较优异策略。这种策略能否迁移运用到其他方面？这就需要一点抽象的思维方式。迁移运用的第一步，需要我们找到各个问题的相同点，抽象出策略运用的问题场景。第二步，就是将解决问题的策略分解为一步一步切实可行的流程步骤（算法就是一系列为了完成某一任务的步骤序列），并通过某种形式表达（比如将它写成程序，从而让机器借人的智慧自动的处理某一具体问题）。</p>
<p>比如，本篇提到的游戏，就可以抽象为一个给定一个数据序列和待搜索的对象，进行查找的问题。在策略到流程步骤的转化中，我们就需要考虑如何存储数据、如何用三种基本的程序结构（顺序、分支、循环）去描述该策略。在查找问题中，可以利用数组存储数据，折半查找策略则可以利用循环、分支在不同的情况，对数组下标进行处理，从而完成对该策略的描述。</p>
<p>说了这么多，终于到了代码实现的环节。这里的代码实现，我遵循原书中的Python实现（因为这真的是一个非常简单易学的语言，并且十分适合算法的表达）。</p>
<p>具体代码如下（Python3.6.1测试通过）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(list, item)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    二分查找：</span></span><br><span class="line"><span class="string">      在一个从小到大排序的数据列表list中，</span></span><br><span class="line"><span class="string">      搜索是否存在数据item</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">      list： 保存从小到大排序的数字列表</span></span><br><span class="line"><span class="string">      item： 待查找的数字</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">      如果list中存在item，</span></span><br><span class="line"><span class="string">      那么返回item在list中的下标，</span></span><br><span class="line"><span class="string">      否则返回None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 列表的开始的下标</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 计算列表最后一个元素的下标</span></span><br><span class="line">    high = len(list) <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        <span class="comment"># 计算介于low和high范围中间元素的下标</span></span><br><span class="line">        mid = (int)((low + high)/<span class="number">2</span>)</span><br><span class="line">        <span class="comment">#取列表中间的元素</span></span><br><span class="line">        guess = list[mid]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 以下依据不同情况对下标进行处理</span></span><br><span class="line">        <span class="keyword">if</span> guess == item:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> guess &gt; item:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试例程</span></span><br><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">print(binary_search(lst,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 输出：0</span></span><br></pre></td></tr></table></figure>



<p>在文章的最后，我们简单回顾一下本篇文章的要点。</p>
<ol>
<li><strong>算法是一系列为了完成某一任务的步骤序列</strong></li>
<li><strong>对比算法的优劣可以从最好情况、最坏情况、平均情况三个方面入手</strong></li>
<li><strong>大O可以简洁地描述算法的时间性能和存储数据的空间占用（分别称为算法的“时间复杂度”和“空间复杂度”），并且其所描述的通常是最坏情况</strong></li>
<li><strong>二分查找算法可以很快的从一个有序的序列中，查找到待查找的元素。其时间复杂度为 O (log N )。而顺序查找却要慢很多，其时间复杂度为为 O( N )。</strong></li>
<li><strong>科学探索的一种方式：从一个简单的具体问题入手，探索发现它的规律，并尝试验证这些规律的正确性。随后，考虑将具体问题和它对应的规律（或者解决方案）抽象推广，最终获得一个具有一般意义的规律（或是解决方案）。</strong></li>
</ol>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的会编程吗</title>
    <url>/2018/07/30/ni-zhen-de-hui-bian-cheng-ma/</url>
    <content><![CDATA[<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/07/30/cover.jpg?raw=true" alt="cover"></p>
<p>当今是一个互联网时代，很多人为了赶上时代的步伐，开始自学编程。其数量之多，夸张到让人不禁感叹“这真是一个全民编程的时代”。</p>
<p>如果你到大街上，随便找几个人问问“你是否会编程”，他们大多数都会回答“我会，我会xx语言、xx语言”等。他们可以很快地给你写出一个“Hello World”或是对数据简单的处理程序。</p>
<p>但是，他们真的会编程吗？你试试让他们编一个链表、或是一些排序、查找算法，他们或许会变得力不从心了。</p>
<p>当下，大多数人对编程的理解便是这样：将编程的学习简化为语言的学习，将掌握语言与掌握编程对等。这种拘泥于语言形式的编程学习，在短时间内确实可以提高个人的编程水平，但从长期来看，容易遇到个人思维的瓶颈。</p>
<p>在我看来，编程并不应该只局限于某一种或是某几种语言的具体形式，而更应该关注逻辑思维的培养。逻辑思维，说得简单一点，其实就是一种思考问题和解决问题的一些套路。如果你掌握了这些套路，并能够将他们组合应用，那么我恭喜你，你已经比大多数人强了。这些套路，在编程中，我们给了它一个比较高端的名字，便是“算法”。</p>
<p>说到这里，一定有很多同学对算法产生了兴趣。这很棒！接下来的一段时间里，我会以《Grokking Algorithms －An illustrated guide for programmers and other curious people》这本书为参考，给大家分享一些常见的算法原理，以及它对应的实现。</p>
<p><img src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2018/07/30/book.jpg?raw=true" alt="book"></p>
<p>看到这儿，你肯定会有个疑问：为什么选择这本书呢？</p>
<p>当今市面上有很多算法书，但是它们的侧重点不尽相同。</p>
<p>比如，《算法导论》这本书比较侧重严谨性和全面性，说白了就是会劝退一些新手和小白。</p>
<p>又如，《算法设计与分析基础》这本书侧重于课堂教学，是一本不错的算法入门教材。但是，课堂教学书籍却免不了会对一些问题和知识进行一些留白。为了鼓励学生自行探索研究，这样的教材编写目的的初衷是好的，但是没有对应的老师进行答疑，这对于一些没有解决相关问题经验或者缺少前置知识的人会很头疼。我想，如果是你，你也不会希望利用自己宝贵的“碎片化”时间来和这种书较劲。</p>
<p>除此以外，还有一些算法书，专注于一些竞赛，主要涉及一些竞赛技巧。这对于竞赛来说，是一剂速成药水；但对于长远的逻辑思维培养来说，会使自己的知识体系不够全面，思维逻辑存在漏洞。</p>
<p>我所推荐的这本书，即《Grokking Algorithms －An illustrated guide for programmers and other curious people》，在文字方面，没有使用过多的专业术语，而是结合大量的实际例子来引出并解释算法的原理。就我个人而言，读起来很轻松。轻松的阅读体验仅仅依靠文字可不够，因而作者在本书中，利用手绘的方式绘制了大量的算法原理图。我想，在你阅读这本书，绞尽脑汁理解算法原理的时候，突然蹦出一个手绘原理图，想必会扑哧一笑吧。:)</p>
<p>这本书除了有趣，易于阅读，在内容安排上也非常用心。</p>
<p>在第一章，作者会做一个简单的引入，解释一下有关算法的一些基础概念。（比如对算法含义的描述、用于评价算法效率的大O理论解释等）</p>
<p>随后会介绍一些基础的数据结构（数组、链表等）、常见的排序算法（选择排序、快速排序等）、查找算法（二分查找、哈希查找等）、递归编程思想。</p>
<p>在这些基础数据结构和算法之后，会有一些更复杂一点的数据结构（图等）、配套的算法（宽度优先搜索、Dijkstra’s 算法等）和它的经典应用。</p>
<p>最后本书会进一步深入，介绍一些有趣并且有用的算法（贪婪算法、动态编程【Dynamic programming】、K-近邻算法、并行算法、SHA算法等）</p>
<p>各位同学们，准备好了吗？准备好了的话，请关注，点赞，时刻关注我的更新。:)</p>
]]></content>
      <categories>
        <category>一起读</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Grokking Algorithms</tag>
      </tags>
  </entry>
</search>
