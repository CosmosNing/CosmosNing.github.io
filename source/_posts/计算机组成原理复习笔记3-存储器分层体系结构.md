---
title: 计算机组成原理复习笔记3-存储器分层体系结构
toc: true
mathjax: true
date: 2019-10-04 22:25:24
description: 整理一下计算机组成原理中存储器分层体系结构的知识
tags: 
- 计算机组成原理
categories: 
- 笔记
---

# 3．存储器分层体系结构
## （★★）存储器的分层结构及存储硬件概述

### 存储系统的分层

* 寄存器
* Cache
* 主存
* 辅存（外存）

注：从上到下，速度变慢，容量变大，成本变低

### 半导体随机访问存储器的组织

* 基本结构（详见教材）
* 支持**随机存取**，**掉电数据丢失**
* 分为 SRAM 和 DRAM

|      特点      |   SRAM   |   DRAM   |
| :------------: | :------: | :------: |
|    存储信息    |  触发器  |   电容   |
|   破坏性读出   |    非    |    是    |
|    需要刷新    |   不要   |    要    |
|   送行列地址   |  同时送  |  分两次  |
|    运行速度    |    快    |    慢    |
|     集成度     |    低    |    高    |
| 发热量（功耗） |    大    |    小    |
|    存储成本    |    高    |    低    |
|    主要用途    | 高速缓存 | 主机内存 |

### 只读存储器及主存的主要技术指标

* 支持**随机存取**，**掉电非易失**
* 分为
  * MROM：内容出厂前写入，无法后期改动
  * PROM：一次可改
  * EPROM：可多次擦除，多次写入
  * Flash Memory（闪存，如 **U 盘**）
  * SSD
* 性能指标（★★★）
  * $存储容量=存储字数\times 字长$ ，**存储字数**表示存储器**地址空间大小**，**字长**表示一次存储操作的**数据**量
  * $存储速度=\frac{数据的宽度}{存储周期}$
    * 其中存储周期中包括两个部分，一个是**存取时间**，另一个是**恢复时间**

### 存储器芯片与CPU的连接

* 主存与 CPU 之间有三条线相连，分别是
  * 数据线（双向）
  * 控制信号线（CPU $\rightarrow$ 主存）
  * 地址线（CPU $\rightarrow$ 主存）
* 主存容量扩展（★★★★）
  * 位扩展
    * 用多个芯片对字长进行扩充（如 8 片 8K × 1 位芯片位扩展后，得到 8K × 8 位）
    * 连接方式
      * ![位扩展](https://github.com/CosmosNing/CosmosNing.github.io/blob/master/2019/10/04/Bit.png?raw=true)
  * 字扩展
    * 用多个芯片对字的数量进行扩充（如 8 片 8K × 1 位芯片位扩展后，得到 64K × 1 位）
    * 连接方式
      * ![字扩展](https://github.com/CosmosNing/CosmosNing.github.io/blob/master/2019/10/04/Word.png?raw=true)
  * 字位同时扩展
    * 同时扩充字和位，组合上述两种扩展
    * 连接方式
      * ![字位同时扩展](https://github.com/CosmosNing/CosmosNing.github.io/blob/master/2019/10/04/Bit-Word.png?raw=true)

### 多模块存储器的交叉存储

* **低位**地址为**体号**，**高位**地址为**体内地址**，所以又称为低位交叉编址
* 交叉编址：每个模块按 **“模 m”** 交叉编址。（即 0，m，···，( k - 1 )m，···存储在第一个单元，其他以此类推）
  ![多模块存储器的交叉存储](https://github.com/CosmosNing/CosmosNing.github.io/blob/master/2019/10/04/Cross.png?raw=true)
* 一些公式（★★）
  * 设模块字长等于数据总线宽度，模块存取一个字的周期为 *T*，总线传送周期为 *r*， 为实现流水线方式存取，存储器交叉模块数应**大于等于**
    * $m=\frac{T}{r}$ （*m* 称为**交叉存取度**）
  * 连续存储 *m* 个字的时间为
    * $t=T+(m-1)r$

##  （★★）Cache

### 高速缓冲存储器的CPU基本访存过程

![带Cache的CPU基本访存过程](https://github.com/CosmosNing/CosmosNing.github.io/blob/master/2019/10/04/Cache.png?raw=true)

###  Cache和主存之间的映射方式（★★★★★★★★）

#### 直接映射

* 映射关系
  * $cache\ 行号 = 主存块号\ Mod\ cache\ 行数$
* 地址结构

| 标记 | cache **行号** | 块内地址 |
| :--: | :------------: | :------: |
|      |                |          |

![直接映射](https://github.com/CosmosNing/CosmosNing.github.io/blob/master/2019/10/04/Direct.png?raw=true)

#### 全相联映射

* 映射关系
  * 主存块可装入 cache 中任意一行
* 地址结构

| 标记 | 块内地址 |
| :--: | :------: |
|      |          |

![全相联映射](https://github.com/CosmosNing/CosmosNing.github.io/blob/master/2019/10/04/Full.png?raw=true)

#### 组相联映射

- 映射关系
  - $cache\ 组号 = 主存块号\ Mod\ cache\ 组数$
- 地址结构

| 标记 | cache **组号** | 块内地址 |
| :--: | :------------: | :------: |
|      |                |          |

![组相联映射](https://github.com/CosmosNing/CosmosNing.github.io/blob/master/2019/10/04/Group.png?raw=true)

### 程序访问的局部性原理对编程的影响及Cache-friendly的程序

（详见教材）

### Cache替换算法和Cache写策略

#### 替换算法

类似操作系统中内存管理页面置换

* FIFO
* LRU
* LFU
* 随机替换

#### Cache 写策略

* 全写法
  * 基本做法：写操作时，若写命中，则同时写 Cache 和主存；若写不命中，则有以下两种处理方法
    * 写分配法：先在主存块中更新相应存储单元，然后分配一个 Cache 行，将更新后的主存块装到分配的 Cache 行中
    * 非写分配法：仅更新主存单元而不装入主存块到 Cache 中
* 回写法
  * 基本做法：若写命中，则写入 Cache 而不写入主存；若写不命中，则在 Cache 中分配一行，将主存块调入该 Cache 行中并更新相应单元的内容。

### 平均访问时间的计算

* 命中率：$H=\frac{N_c}{N_c+N_m}$ ，其中 $N_c$ 为命中 cache 的次数，$N_m$ 为访问主存的次数
* 平均访存时间：$T_a=Ht_c+(1-H)t_m$ ，$t_c$ 为命中时 cache 访存的时间，$t_m$ 为未命中时的访存时间

## （★★）虚拟存储器

### 基本概念

（详见教材）

### 三种实现方案

* 页式
* 段式
* 段页式

### 缺页的处理及TLB的原理和作用（重点：虚拟地址和物理地址的转换问题、查段表和页表）

（参见操作系统-内存管理部分的[**离散（非连续）内存分配方法**](https://cosmosning.github.io/2019/09/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)）

# 解题技巧及重要结论

* 有关SRAM、DRAM芯片引脚数的计算：
  * 引脚包括**地址线**、**数据线**、**片选信号线**、**读信号线**、**写信号线**、**电源信号线**、**接地线**
  * 地址线、数据线条数由芯片容量确定（如 **1024 × 8 位** 有 10 根地址线，8根数据线）（地址线的计算注意题设条件，若采用**地址复用技术**，地址线条数要相应**除以二**，此时**片选**分为**两根**：**行通选**、**列通选**）
  * 读信号线和写信号线有时候会合并成**一根**
* 确定某地址 A 所在芯片的最小地址
  * 例题：假定用若干 2K × 4 位的芯片组成一个 8K × 8 位的存储器，则地址 0B1FH 所在芯片的最小地址为
  * 分析
    * 2K 说明每一片芯片地址位数为 11 位，8K 对应的有 13 位（其中低 11 位为片内选，2 位为片选）
    * 0B1FH 写成二进制，将片内选部分写成全 0 即可得相应的最小地址
* 根据地址范围确定芯片地址线位数
  * 先计算：**最大地址 - 最小地址 + 1**
  * 上一步的结果，从低位（第 1 位）到高位，第一个出现 1 的位数**减去 1**，即为相应芯片的地址线位数
* 芯片接线问题
  * 从**低位**开始接**地址线**，然后接**译码**线
* 交叉编址中的访存冲突的判定：
  * 先计算对应访存地址所在的模块序号：**模块序号( id ) = 访存地址( A ) % 存储器交叉模块数 ( n ) **
  * 判定访存冲突的规则：给定的访存地址在相邻的 n 次访问中出现在同一存储模块内。
* 交叉编址中的流水线存取的时间（或周期等）计算
* cache **组相联映射**中组号的计算
  * 将**主存单元块号除以主存块大小**即可；或者将块号写成二进制，根据主存块大小确定块内地址位数（如 32 B 代表有 5 位），块号二进制中低地址为块内地址，剩下的位数为块号，把相应的位数转换成十进制即可。
* cache **直接映像（直接映射）** 的地址划分
  * 基本公式：$cache\ 行数=\frac{cache 容量}{主存块每块大小}​$
  * $cache\ 块内地址位数=log_2(cache\ 行大小【以B为单位】)​$
  * $cache\ 行号位数=log_2(cache\ 行数)=log_2(\frac{cache 容量}{主存块每块大小})$
  * 主存标记位数
    * $主存标记位数=log_2(主存容量大小)-cache\ 块内地址位数-cache\ 组号位数$
    * $主存标记位数=log_2(\frac{主存容量}{cache\ 能存放的数据容量})$（注意是**数据容量**，cache 的总容量【具体见下】不同）
  * 应用：主存装入 cache 的地址：将主存地址写成二进制，取这个二进制的低位，这些低位与 cache  地址结构中除主存标记位以外的对应，即为装入 cache 的地址
* cache **组相联映射** 的地址划分
  * $cache\ 块内地址位数=log_2(主存块大小【以B为单位】)$
  * $cache\ 组号位数=\frac{cache\ 容量}{主存块大小\times 路数}​$
  * $主存标记位数=log_2(主存容量大小)-cache\ 块内地址位数-cache\ 组号位数​$
* **直接映射**分**行**，**组相联映射**分**组**
* cache容量的计算
  * cache 容量包括**存储容量**和**标记阵列容量**（有效位【1位，一定有】、标记位【一定有，由 cache 地址划分】、一致性维护位【指明采用**回写法**才有】、替换算法控制位）
  * $cache\ 容量 = cache\ 行数\times (标记位位数之和 +主存每块存储容量【注意单位为 bit】)$
  * 其中
    * $cache\ 行数=\frac{cache\ 容量}{主存块大小}$
    * $标记位数之和=1【代表有效位】+主存标记位数+···（根据题意要求，增补）$
    * $主存每块大小=字节数\times 字节数位数$

# 参考资料

1. 计算机组成与系统结构.袁春风等
2. 2020年计算机组成原理考研复习指导.王道论坛